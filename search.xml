<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[YAML语法说明]]></title>
    <url>%2F2020%2F03%2F09%2Fyaml%2Findex%2F</url>
    <content type="text"><![CDATA[现代编程中，少不了编写配置文件，常用的配置文件编写格式有：xml，json，在前端工程化开发中，甚至还有使用 js 作为配置文件的。本文将介绍一种更适合编写配置的语言 YAML（Yet Another Markup Language）。并记录其标准语法。 前言YAML 的语法和其他高级语言类似，并且可以简单表达 清单（数组）、散列表（对象），标量（纯量） 等数据形态。它使用 空白符号 缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和 YAML 非常接近）。 YAML 的配置文件后缀为 .yml，如：_config.yml 。 基本语法规则123451. 大小写敏感。2. 使用缩进表示层级关系。3. 缩进时不允许使用 Tab 键，只允许使用空格。4. 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可。5. 键值对之间，一定要存在空格。 注释在 YAML 中，使用 # 进行注释标识。以 # 开头的行都会被解析器忽略。 1# 我是一行注释 支持的数据结构YAML 支持的数据结构有 3 种。 123对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）纯量（scalars）：单个的、不可再分的值 接下来，介绍他们各自的书写语法。并以 js-yaml 的实现为例进行讲解。 对象在 YAML 中，对象的一组键值对，使用 : 冒号结构进行表示。 1foo: hello yaml 转换为 javascript 如下。 123&#123; foo: 'hello yaml'&#125; 除了使用上面的语法，还支持将所有键值对写成一个行内对象的形式。 1foo: &#123; name: little hong, age: 18 &#125; 转换为 javascript 如下。 123456&#123; foo: &#123; name: 'little hong', age: 18 &#125;&#125; 数组在 YAML 中，使用一组连词线 - 开头的行，构成一个数组。 123- little hong- elenh- yisibell 转换为 javascript 如下。 1['little hong', 'elenh', 'yisibell'] 如果想继续嵌套层级，使其有多维数组形式，可以使用 空格 （注意，不可使用 Tab 键）进行表示。 1234- - little hong - elenh - yisibell 转换为 javascript 如下。 123[ ['little hong', 'elenh', 'yisibell']] 同样的，数组类型，也可以使用行内表示方式。 1elenh: [little, hong, 18] 转换为 javascript 如下。 123&#123; elenh: ['little', 'hong', 18]&#125; 复合结构对象，数组可以结合使用，形成复合结构。 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 转换为 javascript 如下。 123456789&#123; languages: [ 'Ruby', 'Perl', 'Python' ], websites: &#123; YAML: 'yaml.org', Ruby: 'ruby-lang.org', Python: 'python.org', Perl: 'use.perl.org' &#125; &#125; 纯量纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 12345671. 字符串2. 布尔值3. 整数4. 浮点数5. Null6. 时间7. 日期 数值数值直接以字面量的形式表示。 1number: 12.30 转为 javaScript 如下。 123&#123; number: 12.30 &#125; 布尔值布尔值用 true和 false 表示。 1isSet: true 转为 javaScript 如下。 123&#123; isSet: true &#125; nullnull 用 ~ 表示。 1parent: ~ 转为 javaScript 如下。 123&#123; parent: null &#125; 时间时间采用 ISO8601 格式。 1iso8601: 2001-12-14t21:59:43.10-05:00 转为 javaScript 如下。 123&#123; iso8601: new Date('2001-12-14t21:59:43.10-05:00') &#125; 日期日期采用复合 iso8601 格式的 年、月、日 表示。 1date: 1976-07-31 转为 javaScript 如下。 123&#123; date: new Date('1976-07-31') &#125; 转换YAML 允许使用 两个感叹号，强制转换 数据类型。 12e: !!str 123f: !!str true 转为 javaScript 如下。 1234&#123; e: '123', f: 'true' &#125; 字符串字符串 是最常见，也是最复杂的一种数据类型。 字符串默认不使用引号表示。 1str: 这是一行字符串 转为 javaScript 如下。 123&#123; str: '这是一行字符串' &#125; 注： 如果字符串之中包含空格或特殊字符，需要放在引号之中。 1str: '内容： 字符串' 转为 javaScript 如下。 123&#123; str: '内容: 字符串' &#125; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 12s1: '内容\n字符串's2: "内容\n字符串" 转为 javaScript 如下。 1234&#123; s1: '内容\\n字符串', s2: '内容\n字符串' &#125; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 1str: 'labor''s day' 转为 javaScript 如下。 123&#123; str: 'labor\'s day' &#125; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 123str: 这是一段 多行 字符串 转为 avaScript 如下。 123&#123; str: '这是一段 多行 字符串' &#125; 多行字符串可以使用 | 保留换行符，也可以使用 &gt; 折叠换行。 123456this: | Foo Barthat: &gt; Foo Bar 转为 javaScript 代码如下。 1234&#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125; + 表示保留文字块末尾的换行，- 表示删除字符串末尾的换行。 123456789s1: | Foos2: |+ Foos3: |- Foo 转为 javaScript 代码如下。 12345&#123; s1: 'Foo\n', s2: 'Foo\n\n\n', s3: 'Foo' &#125; 字符串之中可以插入 HTML 标记。 12345message: | &lt;p style="color: red"&gt; 段落 &lt;/p&gt; 转为 javaScript 如下。 123&#123; message: '\n&lt;p style="color: red"&gt;\n 段落\n&lt;/p&gt;\n' &#125; 引用锚点 &amp; 和别名 *，可以用来引用。 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults 等同于下面的代码。 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost &amp; 用来建立锚点（defaults），&lt;&lt; 表示合并到当前数据，* 用来引用锚点。 下面是另一个例子。 12345- &amp;showell Steve - Clark - Brian - Oren - *showell 转为 javaScript 代码如下。 1[ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ] 函数和正则表达式的转换这是 js-yaml 库特有的功能，可以把函数和正则表达式转为字符串。 123# example.ymlfn: function () &#123; return 1 &#125;reg: /test/ 解析上面的 example.yml 文件的代码如下。 1234567891011var yaml = require('js-yaml');var fs = require('fs');try &#123; var doc = yaml.load( fs.readFileSync('./example.yml', 'utf8') ); console.log(doc);&#125; catch (e) &#123; console.log(e);&#125; 从 javaScript 对象还原到 yml 文件的代码如下。 1234567891011121314151617var yaml = require('js-yaml');var fs = require('fs');var obj = &#123; fn: function () &#123; return 1 &#125;, reg: /test/&#125;;try &#123; fs.writeFileSync( './example.yml', yaml.dump(obj), 'utf8' );&#125; catch (e) &#123; console.log(e);&#125; 好了，以上就是全部内容，玩得开心！]]></content>
      <categories>
        <category>YAML</category>
      </categories>
      <tags>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在javascript和sass之间共享变量]]></title>
    <url>%2F2020%2F02%2F27%2Fwebpack%2Fhow-to-share-var-between-javascript-and-sass%2F</url>
    <content type="text"><![CDATA[在编程开发中，变量共享一直是程序员们所热爱的东西，因为我们都最求极简主义，代码的高可维护性。这篇短文将介绍一种在 javascript 和 sass 之间进行变量共享的实现方式。 前言我们都知道，同语言之间实现变量共享是很简单的，因为他们都有自己的模块机制。 javascript 中有 ES Modules 12// a.jsexport const foo = 1 123// b.jsimport &#123; foo &#125; from './a'console.log(foo) // 1 sass 中有 @import 12// variables.scss$--color-prey: #ddd; 123456// main.scss@import './variables.scss'.fc-prey &#123; color: $--color-prey;&#125; 但，当我们想要在 b.js 中使用 variables.scss 中的变量时，看起来好像没那么简单。 幸运的是，当有了 webpack 和 CSS Modules 后，一切都变得简单起来了。接下来，开始讲解如何去实现它。 准备首先确保你的项目是工程化的，基于 webpack 构建的。你可以自行搭建，也可以使用现有的脚手架，比如 @vue/cli 、create-react-app 、create-nuxt-app 等。 然后确保安装了 sass 的编译器和对应 loader。你可以使用以下的任一种方式安装。 1$ npm i node-sass sass-loader -D 或 12# 使用 dart 作为 sass 编译器依赖$ npm i sass sass-loader -D 使用为了方便，我们直接使用 @vue/cli 进行构建。 现在，我们在项目中新建一个 variables.scss 文件，来定义样式变量。得益于 CSS Modules，我们可以在 variables.scss 中使用 :export 指令来向 javascript 导出变量，这就像 es6 中的 export 关键字一样。 12345678// @/styles/variables.scss$--color-primary: skyblue;$--border-width: 2px;:export &#123; colorPrimary: $--color-primary; borderWidth: $--border-width;&#125; 如上所示，该 scss 文件向外导出了一个 javascript 对象。类似于这样。 1234export default &#123; colorPrimary: 'skyblue', borderWidth: '2px'&#125; 接着，我们就可以这样使用它。 123456789101112131415161718&lt;template&gt; &lt;div :style="&#123;color: styleVar.colorPrimary&#125;"&gt;CSS Modules&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import styleVariables from '@/styles/variables.scss'export default &#123; name: 'App', data() &#123; return &#123;&#125; &#125;, computed: &#123; styleVar() &#123; return styleVariables &#125; &#125;&#125;&lt;/script&gt; 打开浏览器，你会看到有着 skyblue 字体颜色的 CSS Modules 文本。Yep！ 好了，这就是这篇短文的全部内容了，玩的开心！]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>sass</tag>
        <tag>CSS Modules</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在 vue 项目中构建权限菜单]]></title>
    <url>%2F2019%2F10%2F26%2Fvue%2Fdemo%2FhowToCreateADynamicRoutesByAuthTree%2F</url>
    <content type="text"><![CDATA[在使用 vue 做中后台管理系统项目时，我们经常会涉及到权限管理，即对菜单树进行权限控制，由于不同框架本身的一些特性，通常实现权限功能的方式也大不相同。 本文就 vue 项目来介绍一种菜单树的权限管理方式。 前言对于 vue 项目来说，我们通常会将 菜单树 和 路由表 进行关联，也就是说，最终的菜单树 会根据 完整的路由表 生成。 这里 完整的路由表 可以分为：静态路由 和 动态路由 这两部分。 静态路由 指的是，用户可正常访问的路由，诸如 /login 、/404 、/about 等。这些路由信息不会与菜单树关联。 动态路由 指的是，有对应权限的用户才可以访问，这些路由信息会与菜单树进行关联。 那么，最终的菜单树 又可以如何确定呢？ 我们可以借鉴像 vue-element-admin 这样的后台模板框架实现菜单树的思路，对 完整的路由表 中路由对象 hidden 属性为 false 的项作为一个菜单树节点。 123456789[ &#123; name: 'system', path: '/system', //当设置 true 的时候该路由不会在侧边栏出现 如 401，login等页面，或者如一些编辑页面 /edit/1 hidden: false, component: () =&gt; import('@/views/system') &#125;] 资源管理为了做到对页面菜单项的灵活控制，我们的项目中应该有一个叫做 资源管理 的页面。该页面主要的作用是可以很方便的 新增、修改、删除 一个权限菜单项。 而该资源菜单树的每一个菜单项可以使用一个唯一的 权限编码(code) 与动态路由对象进行关联。 也就是说，后台存储的是一个有 权限编码(code) 信息的菜单树形数据结构，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839const authTree = [ &#123; code: "system_manage", name: "系统管理", child: [ &#123; code: "system_user_menu", name: "用户管理" &#125;, &#123; code: "system_role_menu", name: "角色管理" &#125;, &#123; code: "system_function_menu", name: "资源管理" &#125; ] &#125;, &#123; code: "product_manage", name: "商品管理", child: [ &#123; code: "product_add_menu", name: "添加商品" &#125;, &#123; code: "product_all_menu", name: "所有商品" &#125;, &#123; code: "product_attribute_menu", name: "属性管理" &#125; ] &#125;]; 如上数据结构所示，code 属性表示该菜单节点的权限编码，name 属性表示该菜单节点的名称，当然，你也可以加入一些其他的可控字段。 动态路由定义我们已经维护好了一份资源菜单树，那么，接下来的工作就是对每个 权限编码 去定义对应的路由对象信息，这样，我们就可以在后面通过 遍历权限菜单树 去生成一份动态路由表出来。 前端定义的 动态路由 类似于下面这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const dynamicRoutes = &#123; system_manage: &#123; name: "systemmanage", path: "/systemmanage", component: "this is a component load with import() method", meta: &#123; title: "系统管理", icon: "iconfont icon-xitongguanli" &#125; &#125;, system_user_menu: &#123; name: "usermanage", path: "/usermanage", component: "this is a component load with import() method", meta: &#123; title: "用户管理", icon: "iconfont icon-xitongguanli" &#125; &#125;, system_role_menu: &#123; name: "rolemanage", path: "/rolemanage", component: "this is a component load with import() method", meta: &#123; title: "角色管理", icon: "iconfont icon-xitongguanli" &#125; &#125;, system_function_menu: &#123; name: "sourcemanage", path: "/sourcemanage", component: "this is a component load with import() method", meta: &#123; title: "资源管理", icon: "iconfont icon-xitongguanli" &#125; &#125;, product_manage: &#123; name: "productmanage", path: "/productmanage", component: "this is a component load with import() method", meta: &#123; title: "商品管理", icon: "iconfont icon-xitongguanli" &#125; &#125;, product_add_menu: &#123; name: "addproduct", path: "/addproduct", component: "this is a component load with import() method", meta: &#123; title: "添加商品", icon: "iconfont icon-xitongguanli" &#125; &#125;, product_all_menu: &#123; name: "allproduct", path: "/allproduct", component: "this is a component load with import() method", meta: &#123; title: "所有商品", icon: "iconfont icon-xitongguanli" &#125; &#125;, product_attribute_menu: &#123; name: "attributemanage", path: "/attributemanage", component: "this is a component load with import() method", meta: &#123; title: "属性管理", icon: "iconfont icon-xitongguanli" &#125; &#125;&#125;; 根据权限树生成路由表权限树数据 和 动态路由定义已经处理好了，现在，我们就要根据这两份数据生成 vue-router 可用的路由表数据了。 可以使用如下函数进行生成： 123456789101112131415161718// 根据权限树生成可用的路由表function filterMenu(res, authTree, routes) &#123; authTree.forEach(v =&gt; &#123; const routeObj = routes[v.code], name = v.name, child = v.child; if ( name ) routeObj.meta.title = name; if (child &amp;&amp; child.length &gt; 0) routeObj.children = filterMenu([], child, routes); res.push(routeObj); &#125;); return res;&#125;console.log(filterMenu([], authTree, dynamicRoutes)); 插入到路由表中最后，我们可以使用 addRoutes 方法将生成的路由表数据添加到路由中，这样，路由、权限和菜单就进行了很好的关联，后续对菜单项的控制也会非常方便。 12345678// ...import router from '@/router'// ...router.addRoutes( routes )// ... 上面的 routes 就是通过比对权限后生成的路由表数据了。 用户角色管理通常，我们的权限是绑定到角色的，不同的角色有不同的权限，所以，我们可以在 用户角色管理 模块去绑定对应的菜单权限。 页面如何设计就看你自己了。 动态路由与后台关联的另一种方式在第一种方式中，当将菜单权限赋予某个角色后，那么，该角色对于的菜单树结构就已经成型了，只不过需要将菜单 权限code 替换为真正的路由对象。再在适合的时机插入到路由表中。 这里还有另一种实现方式。我们将完整的动态路由同步到后台数据库，除了路由对象中的 component 字段变为 String 类型以外，该动态路由没有任务其他特殊之处。 12345678910111213141516171819202122232425[ &#123; name: 'system', path: '/system', component: 'Layout', meta: &#123; title: '系统管理', icon: 'system-icon', roles: ['admin'] &#125;, children: [ &#123; name: 'rolesManagement', path: 'roles_management', component: 'rolesManagement', meta: &#123; title: '角色管理', icon: 'roles-icon', roles: ['admin'] &#125; &#125; // ... ] &#125;] 如上动态路由所示，我们可以看到两个比较特殊的地方，第一个是 component 字段，第二个是 meta 中的 roles 字段。他们有什么意义呢？ component字段 该字段表示路由对象所映射的组件。由于我们需要将整个动态路由表存储到后台数据库，所以，原先的 component 设置方式不再适用，这里我们该用字典关联的方式来解决。我们会有这样一个文件，存储着动态路由中的所有动态组件。 123456// dynamicRoutesMap.jsexport default &#123; Layout: () =&gt; import('@/layout'), rolesManagement: () =&gt; import('@/views/system/rolesManagement'), // ...&#125; roles字段 该字段表示路由对象所关联的角色有哪些。也就是说，只要某个路由对象中的 roles 信息中的角色是当前用户所拥有的，那么该路由对象就该被显示出来。当然，roles 字段是后台动态追加进去的，可在 用户角色管理 页面进行处理。 如何过滤出当前用户有权访问的路由表获取当前用户信息 我们首先需要获取当前用户信息，即，当前用户拥有的角色信息。 12345&#123; name: '张三', id: 1, roles: ['role1', 'role2', 'role3']&#125; 如上所示，张三 同时拥有 role1、role2 和 role3 这三个角色。 获取动态路由信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445[ &#123; name: 'system', path: '/system', component: 'Layout', meta: &#123; title: '系统管理', icon: 'system-icon', roles: ['role1', 'admin'] &#125;, children: [ &#123; name: 'rolesManagement', path: 'roles_management', component: 'rolesManagement', meta: &#123; title: '角色管理', icon: 'roles-icon', roles: ['role1', 'admin''] &#125; &#125;, &#123; name: 'usersManagement', path: 'users_management', component: 'usersManagement', meta: &#123; title: '用户管理', icon: 'users-icon', roles: ['role1', 'admin'] &#125; &#125;, &#123; name: 'resourceManagement', path: 'resource_management', component: 'resourceManagement', meta: &#123; title: '资源管理', icon: 'resource-icon', roles: ['admin'] &#125; &#125;, // ... ] &#125;] 如上所示，这一个经过后台处理的含有完整 roles 信息的动态路由表。每个路由对象都有对应的 roles 信息。表示该路由对象对哪些角色可见。 经过过滤处理后，实际生成的动态路由表示这样的。 1234567891011121314151617181920212223242526272829303132333435[ &#123; name: 'system', path: '/system', component: 'Layout', meta: &#123; title: '系统管理', icon: 'system-icon', roles: ['role1', 'admin'] &#125;, children: [ &#123; name: 'rolesManagement', path: 'roles_management', component: 'rolesManagement', meta: &#123; title: '角色管理', icon: 'roles-icon', roles: ['role1', 'admin''] &#125; &#125;, &#123; name: 'usersManagement', path: 'users_management', component: 'usersManagement', meta: &#123; title: '用户管理', icon: 'users-icon', roles: ['role1', 'admin'] &#125; &#125;, // ... ] &#125;] 因为，当前用户没有 admin 角色权限，所以 资源管理 这个路由对象被剔除。 最后，我们依然会使用 addRoutes 方法将生成的 动态路由表 插入到路由表中，菜单树，也会根据动态路由渲染出来。]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>auth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题集]]></title>
    <url>%2F2019%2F10%2F02%2Finterview%2Findex%2F</url>
    <content type="text"><![CDATA[本文记录前端面试中的一些常见题型，如果有幸让你看到了这篇文章，欢迎探讨学习！ 编程题实现 call 函数call 函数的作用，可以改变调用者函数内部的 this 指向，立即执行，第二个参数为 rest 类型参数。如果没有指定第一个参数，则 this 指向 window。 123456789101112131415161718192021222324252627282930Function.prototype.myCall = function(con) &#123; // 获取执行环境，如果传入的值为 非真值 则将 window 作为 上下文环境 let context = con || window, _fn = Symbol("_fn"); // 谁调 myCall 这里的 this 就指的是谁。将调用者挂载到当前指定的 上下文执行环境 上 context[_fn] = this; // 取出传入 myCall 中 除了第一个参数外的其他参数 let arg = [...arguments].slice(1); let res = context[_fn](...arg); // 执行完后，删除 fn delete context[_fn]; // 返回执行结果 return res;&#125;;function a(num) &#123; console.log(this.foo + num);&#125;let foo = 4;let obj = &#123; foo: 5 &#125;;a.myCall(obj, 1);a.call(obj, 1); 我们在使用 _fn 作为临时属性时，使用的是 Symbol 类型，这是为了避免与上下文环境中的其他属性重复而发生冲突。 实现 apply 函数apply 函数的作用，可以改变调用者函数内部的 this 指向，立即执行，第二个参数为数组类型。如果没有指定第一个参数，则 this 指向 window。 1234567891011121314151617181920212223Function.prototype.myApply = function(con, arr = []) &#123; let context = con || window, _fn = Symbol("_fn"); context[_fn] = this; let res = context[_fn](...arr); delete context[_fn]; return res;&#125;;function a(num1, num2, num3) &#123; console.log(this.foo + num1 + num2 + num3);&#125;var foo = 2;var obj = &#123; foo: 4 &#125;;a.myApply(obj, [1, 2, 3]);a.apply(obj, [1, 2, 3]); 实现 bind 函数bind 函数的作用，返回新的函数，该函数内的 this 指向 bind 函数的第一个参数对象，第二个参数为传入新函数内的 rest 参数。如果没有指定第一个参数，则 this 指向 window。 12345678910111213141516171819202122232425262728293031Function.prototype.myBind = function(con) &#123; if (typeof this !== "function") throw new Error("error"); var context = con || window; var _this = this; var args = [...arguments].slice(1); return function Fn() &#123; // 因为返回了一个函数，我们可以 new Fn()，所以需要判断 if (this instanceof Fn) &#123; return new _this(...args, ...arguments); &#125; return _this.apply(context, [...args, ...arguments]); &#125;;&#125;;var foo = 1;var obj = &#123; foo: 2 &#125;;function a(num1, num2) &#123; console.log(this.foo + num1 + num2);&#125;// 参数是累计的，多出的参数不会被使用var fn1 = a.bind(obj, 2, 2);fn1(3, 5);var fn2 = a.myBind(obj, 2, 2);fn2(3, 5); 对多维数组进行降维（扁平化）实现的效果类似这样： 1let arr = [[1, [2]], [3], [4]]; 扁平化后，如下所示： 1let flatArr = [1, 2, 3, 4]; 方式 1： 123let arr1 = [1, [2, [4, [5]]], 3].flat(Infinity);console.log("方式1", arr1); 方式 2： 123456789const flattenDeep = arr =&gt; &#123; return Array.isArray(arr) ? arr.reduce((a, b) =&gt; [...a, ...flattenDeep(b)], []) : [arr];&#125;;let arr2 = flattenDeep([1, [[2], [3, [4]], 5]]);console.log("方式2", arr2); 方式 3： 使用 generater 函数 和 for ...of 循环 或 使用 扩展运算符 ... 也行。 12345678910111213141516171819function* iterArr(arr) &#123; if (Array.isArray(arr)) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; yield* iterArr(arr[i]); &#125; &#125; else &#123; yield arr; &#125;&#125;let newArr = [], arr3 = [1, [[2], [3, [4]], 5]];for (let v of iterArr(arr3)) &#123; newArr.push(v);&#125;console.log("方式3", newArr);console.log("方式3(扩展运算符)", [...iterArr(arr3)]); 实现支持注册、分发和解绑的事件类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 数组置空的方法：// arr = []; arr.length = 0; arr.splice(0, arr.length)class Event &#123; constructor() &#123; this._cache = &#123;&#125;; &#125; // 注册事件：如果不存在此种type，创建相关数组 on(type, callback) &#123; this._cache[type] = this._cache[type] || []; let fns = this._cache[type]; if (fns.indexOf(callback) === -1) &#123; fns.push(callback); &#125; return this; &#125; // 触发事件：对于一个type中的所有事件函数，均进行触发 trigger(type, ...data) &#123; let fns = this._cache[type]; if (Array.isArray(fns)) &#123; fns.forEach(fn =&gt; &#123; fn(...data); &#125;); &#125; return this; &#125; // 删除事件：删除事件类型对应的array off(type, callback) &#123; let fns = this._cache[type]; // 检查是否存在type的事件绑定 if (Array.isArray(fns)) &#123; if (callback) &#123; // 卸载指定的回调函数 let index = fns.indexOf(callback); if (index !== -1) &#123; fns.splice(index, 1); &#125; &#125; else &#123; // 全部清空 fns = []; &#125; &#125; return this; &#125;&#125;// 以下是测试函数const event = new Event();event .on("test", a =&gt; &#123; console.log(a); &#125;) .trigger("test", "hello"); 实现斐波那契数列1234567891011121314function* fib() &#123; // 两个变量，第 3 个值为 prev + curr ... let [prev, curr] = [1, 1]; for (;;) &#123; yield curr; [prev, curr] = [curr, prev + curr]; &#125;&#125;for (let v of fib()) &#123; if (v &gt; 55) break; console.log(v);&#125; 利用 Generater 函数 和 for ...of 循环可以很巧妙的实现，注意，generator 函数在被执行后，里面的代码并不会立即执行，需要依靠遍历器驱动 yield 执行。 所以，for(;;){} 并不会有什么性能问题。 实现防抖和节流函数 防抖 功能：触发高频事件后 interval 毫秒内函数只会执行一次，如果 interval 毫秒 内高频事件再次被触发，则重新计算时间。 会清除定时器，对于高频率触发的动作，会限制其频率降低。 1234567891011function debounce(fn, interval = 300) &#123; let timer = null; return function() &#123; // 每次执行该函数时，就清除已注册的定时器程序 clearTimeout(timer); // 生成新的定时器程序，如果用户没有在指定延时时间内再次出发该函数，则该函数会被执行 timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125; 节流 功能：高频事件触发，但在 interval 毫秒内只会执行一次，所以节流会稀释函数的执行频率。 不会清除定时器，对于高频率触发的动作，会减少其触发次数。 12345678910111213function throttle(fn, interval = 1000) &#123; let canRun = true; return function() &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 实现对字符串进行金额格式化的功能函数显示类似如下的字符串格式转换功能。 12let num = 52545455454;num.toLocaleString(); // 52,545,455,454 实现： 1234567891011121314function toPriceRight(str, gap, type) &#123; return String(str) .split("") .reduce((init, v, i) =&gt; &#123; if (i % gap == gap - 1) &#123; init += type + v; &#125; else &#123; init += v; &#125; return init; &#125;, "");&#125;console.log(toPriceRight("52545455454", 3, ",")); // 52,545,455,454 对指定数组生成树形结构数据题目：对于如下数据，pid 表示 父节点的值，如果没有 pid 则表示该对象对象为根节点，请将其格式化为树形数据结构，要求可以达到无限深度。 1234567891011let origin = [ &#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;, &#123; id: 11, pid: 1 &#125;, &#123; id: 12, pid: 1 &#125;, &#123; id: 111, pid: 11 &#125;, &#123; id: 112, pid: 11 &#125;, &#123; id: 21, pid: 2 &#125;, &#123; id: 31, pid: 3 &#125;]; 实现： 123456789101112131415function tree(arr, ori) &#123; if (arr.length === 0) arr = ori.filter(v =&gt; !("pid" in v)); arr.forEach(v =&gt; &#123; let childs = ori.filter(item =&gt; item.pid === v.id); if (childs.length &gt; 0) &#123; v.children = tree(childs, ori); &#125; &#125;); return arr;&#125;console.log(tree([], origin)); 实现倒计时功能12345678910111213141516const endtime = +new Date("2019/12/15 0:0:0"); //定义结束时间日期function daojishi() &#123; let nowtime = +new Date(), //获取当前的时间日期 leftime = (endtime - nowtime) / 1000, //获取剩余的秒数 d = parseInt(leftime / 60 / 60 / 24), //获取剩余天数 h = parseInt((leftime / 60 / 60) % 60), //获取剩余小时数 m = parseInt((leftime / 60) % 60), //获取剩余分钟数 s = parseInt(leftime % 60); //获取剩余秒数 console.log(`距离结束还有：$&#123;d&#125; 天 $&#123;h&#125; 小时 $&#123;m&#125; 分钟 $&#123;s&#125;秒`); if (nowtime &lt;= endtime) setTimeout(daojishi, 1000); //递归循环刷新时间&#125;daojishi(); 给定一个数组，对里面所有的奇数求和12345678let arr = ["1", "2", "3", 6, 4, -99, -101];let res = arr.reduce((init, v) =&gt; &#123; if (v % 2 !== 0) init += Number.parseFloat(v); return init;&#125;, 0);console.log(res); // -196 函数柯里化题目：完成 bindLeft 实现函数参数的部分绑定功能。 1234function bindLeft() &#123; // 完成这里的代码 // 绑定参数个数以传进来的为准&#125; 使用方法如下： 123let fn1 = (a, b, c, d) =&gt; a - b * c + d;let fn2 = bindLeft(fn1, 1, 2); // 绑定参数 a = 1, b = 2console.log(fn2(3, 4)); // 1 - 2 * 3 + 4 输出 -1 实现： 123456789101112131415let fn1 = (a, b, c, d) =&gt; a - b * c + d;function bindLeft(fn) &#123; let args = [...arguments].slice(1); return function() &#123; return fn.apply(this, [...args, ...arguments]); &#125;;&#125;let fn2 = bindLeft(fn1, 1, 2);console.log(fn2(3, 4));console.log(1 - 2 * 3 + 4); 使用冒泡排序对数组中所有正整数排序（非正整数位置保持不变）123456789101112131415161718192021222324252627282930let arr = [11, -1, 6, 5, -4, -7, 9, 8];function bubbleSort(arr) &#123; let len = arr.length; let ori = arr.reduce((init, v, i) =&gt; &#123; if (v &lt; 0) &#123; init.push(&#123; value: v, index: i &#125;); &#125; return init; &#125;, []); for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; let index = arr.findIndex(v =&gt; v &gt;= 0), right = arr.slice(index); ori.forEach(v =&gt; &#123; right.splice(v.index, 0, v.value); &#125;); return right;&#125;console.log(bubbleSort(arr)); // [5, -1, 6, 8, -4, -7, 9, 11] 已知一个对象 obj ，在不知道第一个属性键名的情况下，如何获取第一个属性的值123let obj = &#123; a: 1, b: 2 &#125;;console.log(Object.values(obj)[0]); 将数组去除重复项并按降序排列123456789101112let arr = [2, 0, 1, 8, 0, 2, 1, 5];let res = arr .sort((a, b) =&gt; b - a) .reduce((init, v) =&gt; &#123; if (init.length === 0 || init[init.length - 1] !== v) &#123; init.push(v); &#125; return init; &#125;, []);console.log(res); // [8, 5, 2, 1, 0] 看题作答 请写出下面程序的打印结果 12345678910var p = new Promise((resolve, reject) =&gt; &#123; console.log("a"); resolve();&#125;);setTimeout(() =&gt; console.log("d"), 0);p.then(() =&gt; console.log("c"));console.log("b"); 对于以上这类型的题，看到 Promsie 和 setTimeout 这样的字眼，就知道肯定考察的是与 js 的运行机制 事件循环 相关的。 ok，我们捋一下上面代码的执行过程： 首先，new Promise() 构造函数被执行，console.log(&#39;a&#39;) 被率先执行。打印出 a。 然后，遇到 setTimeout() 函数，其被执行后，回调函数被推入 宏任务 队列中，等待下一轮事件循环时执行。 紧接着，p.then() 被执行，其中的回调函数被推入 微任务 队列中，等到这一轮事件循环的执行栈为空时，再清空 微任务 队列。 接下来，同步代码 console.log(&#39;b&#39;) 被执行。打印出 b 此时，执行栈空，清空 微任务 队列，console.log(&#39;c&#39;) 被压入执行栈中执行。打印出 c。 最后，开始第二轮事件循环，console.log(&#39;d&#39;) 出队，压入执行栈中执行，打印出 d。程序结束。 所以最终的打印结果为： 1// a b c d 请写出下面程序的打印结果 12345678910var x = 0;function test() &#123; console.log(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m.apply(); // 0test(); // 0 ok！定眼一看，这是一道有关 this 问题的题目。所以，你的脑中应该迅速回忆起 this 相关的知识点。 该题涉及到 3 种 this 指向情况： 普通函数中的 this 对象方法中的 this 被 apply 改变过的 this 首先，代码中，在全局定义了 3 个变量：变量x 、test函数、对象o。 第一条执行语句，使用 apply 的方式调用了 o.m() 方法。这里只要使用了 apply 函数，没有指定 thisArg 的话，那么 o.m() 方法中的 this 就指向 window。所以打印出 0 第二条执行语句，test() 被直接调用，其中的 this 指向全局 window，打印出 0。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>node</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单页应用之预渲染(prerendering)]]></title>
    <url>%2F2019%2F09%2F10%2Fvue%2Fcli%2Fprerender-spa-plugin%2F</url>
    <content type="text"><![CDATA[如果你调研 服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要 预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。 我们可以使用 webpack 的插件 prerender-spa-plugin 来轻松地添加预渲染。它已经被 Vue 应用程序广泛测试，并且它的作者是 Vue 核心团队的成员。 这篇文章会基于 @vue/cli-3.x 说明 预渲染 如何配置。 安装首先使用 npm 安装最新版的 prerender-spa-plugin 插件。 1$ npm install prerender-spa-plugin --save-dev 由于 prerender-spa-plugin新的 3.x 版本依赖于 puppeteer 库，并且 puppeteer 是很大的，大约有200多M，所以对于网速很慢的同学，经常会在下载这个库的时候超时失败。鉴于这样的情况，推荐使用nrm 工具将下载源设置为淘宝源，然后再安装 prerender-spa-plugin。 123$ npm i nrm -g$ nrm use taobao$ npm i prerender-spa-plugin --save-dev vue.config.js 配置安装完毕后，我们在 vue.config.js 文件中添加如下配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// vue.config.jsconst path = require('path')const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; //部署应用包时的基本 URL。 publicPath: "/", // 打包输出文件路径（文件名，默认 dist ）。 outputDir: "dist", //打包后静态静态资源的放置位置，该项配置默认为 "" , 即直接将 ( js/css/img/fonts/...) 这些文件夹放在了 dist 文件夹下 //这里将这些静态资源放置在 assets 文件夹中。 assetsDir: "assets", //添加 webpack 配置 configureWebpack: &#123; //追加插件配置 plugins: [ new PrerenderSPAPlugin(&#123; // 预渲染打包后的静态资源存放目录（必须），要跟 outputDir 配置对应上 staticDir: path.join(__dirname, 'dist'), // 预渲染的输出路径，默认使用 staticDir 字段设置的值 // outputDir: path.join(__dirname, 'dist/prerendered'), // 本地的 html 页面模块文件（必须） indexPath: path.join(__dirname, 'dist', 'index.html'), // 要匹配的预渲染路由（必须） routes: ['/', '/about'], // 渲染器（必须） renderer: new Renderer(&#123; // 默认挂在 window.__PRERENDER_INJECTED 对象上，可以通过 window.__PRERENDER_INJECTED.foo 在预渲染页面取值 inject: &#123; foo: 'bar' &#125;, headless: false, // 定义渲染事件名称， document.dispatch(new Event('render-event')) renderAfterDocumentEvent: 'render-event', // 延迟渲染时间 //renderAfterTime: 5000, // 触发渲染的元素，该元素生成后就保存渲染结果 //renderAfterElementExists: '#app' &#125;), // 服务器配置 // server: &#123; // // 代理，用于发送请求，设置与 webpack-dev-server 并不完全相同 // proxy: &#123; // '/api': &#123; // // 代理地址 // target: '', // // pathRewrite: &#123; // // '^/api': '/', // // &#125;, // &#125;, // // proxy的属性用于express: app.use(key, proxy[key]) // // '/:foo': &#123; target &#125;, 可以不匹配 '/' // &#125;, // &#125;, &#125;) ] &#125;&#125; main.js接下来，main.js 文件中，在构造 Vue 实例配置的 mounted 钩子中添加 预渲染 的事件发布。 1234567891011121314// main.js// 忽略其他代码 ...new Vue(&#123; el: '#app', router, store, render: h =&gt; h(App), mounted()&#123; // 实例被挂载后，触发渲染事件 document.dispatchEvent(new Event('render-event')); &#125;&#125;) 路由模式最后，我们需要将路由模式修改为 mode: history 模式。 构建1$ npm run build 执行构建命令后，我们可以看到多出了 about 文件夹。在使用 /about 访问关于页面时，展示的就是 about 文件夹下的 index.html 页面了。 配置说明更多的详细配置信息请参考 prerender-spa-plugin 。]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>prerender-spa-plugin</tag>
        <tag>vue-cli3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更好的维护你的 npm 包]]></title>
    <url>%2F2019%2F09%2F06%2Fnpm%2FhowToMaintainYourPckBetter%2F</url>
    <content type="text"><![CDATA[我们已经知道如何发布一个 node 包到 npm，整个操作过程也不是很复杂，在看这篇文章之前，如果你还不知道如何发布，你可以参考我之前的一篇文章 如何发布一个自己的node模块到npm 。 这篇文章将介绍如何在后期维护你已发布的 npm 包，以及如何更好的管理你的 包版本。 前言首先，我们来思考一个问题。假设，我们已经成功的发布了一个自己开发的插件包到 npm ，在使用这个插件包的过程中，我们不时的会发现一些 BUGS ，或者，有了一些新的 IDEAS ，这时我们就需要及时的修复这些 BUGS，并不定时的把新的想法（功能或优化）添加到你的插件包中，然后悄悄咪咪地发布到 npm。那么，请问你如何管理该插件包的版本呢？ 小众的操作是每次的代码更新（BUGS fix, new APIS）都简单的使用 npm version patch 或 npm version minor 对版本号进行递增升级后，直接来一行： 1npm publish 将所有更新发布到 npm。 注意： 这种操作方式只能将版本号 向上递增式 的进行维护，而无法对 低的大版本 进行持续维护。这里的 低的大版本 指的是，比如你的插件包已经持续更新到 2.x，那么相对于 2.x 版本更低的大版本，比如 1.x 就是 低的大版本。虽然插件包已经更新到了 2.x，相对于 1.x 的版本在功能 APIS 上有了较大的优化改变，但依然有很大一部分使用者在使用着 1.x 的版本，并且他们不得不继续使用 1.x（原因或许是因为 2.x的版本实现太过激进，以至于较老的环境难以支持 whatever！）此时，作为包的开发者，我们就该继续维护 1.x 的版本，因为该大版本依然可能会存在某些漏洞。那么上面的那种包版本升级方式就不再适用了。因为，我们现在既需要保持最新版本的更新，又要对低版本的代码进行维护。 在正式开始案例教程之前，我们还需要了解一些必要的知识点。如果你很了解以下说的这些命令，你可以跳过它们，直接看案例。 npm verison 命令npm version 命令用来升级 npm包 的版本号，该升级操作符合 语义化版本规则。 1npm version &lt;newversion&gt; 其中 &lt;newversion&gt; 参数的值包括以下这几种： 假定，当前包的版本为 1.0.0。 patch 补丁版本的升级。版本号第三位递增 +1。 12$ npm version patchv1.0.1 minor 小版本升级。版本号第二位递增 +1。 12$ npm version minorv1.1.0 major 大版本升级。版本号第一位 +1。 12$ npm version majorv2.0.0 prepatch 预先补丁版本。版本第三位 +1，第四位递增（从 0 开始）。 12$ npm version prepatchv1.0.1-0 preminor 预先小版本。版本号第二位 +1，第四位递增（从 0 开始）。 12$ npm version preminorv1.1.0-0 premajor 预先大版本。版本号第一位 +1，第四位递增（从 0 开始）。 12$ npm version premajorv2.0.0-0 prerelease 预先发布版本。版本号第四位递增（从 0 开始）。 12$ npm version prerelease [--preid=&lt;prelease-id&gt;]v1.0.0-0 使用 --preid 参数时，会添加 tag 类型值。 12$ npm version prerelease --preid=betav1.0.0-beta.0 from-git 使用关联 git 仓库中的最新 tag 作为版本号。 123$ npm version from-git# 绑定的 git 仓库中的最新一个标签 tag 为 v1.1.0v1.1.0 自定义版本号 除了使用 npm 提供的规则值外，你还可以自定义版本号更新。这跟直接修改 package.json 文件中的 version 字段的方式如出一辙。 12$ npm version 1.0.1v1.0.1 以上就是 npm version 命令的所有可选参数值。本篇文章所用到的重点则是 npm version from-git 这条命令。 npm dist-tag 命令npm dist-tag 命令的作用是对 npm 包的 dist-tags 进行增删改操作。说白了就是给包的某个版本号打上标签 tag。使得用户可以通过 npm i hello-npm-test@alpha --save 的方式去安装 npm 包。其中 alpha 就是该包的一个标签名。 注： pckname 包名；version 版本号；tagname 标签名。 新增标签 1$ npm dist-tag add &lt;pckname&gt;@version [&lt;tagname&gt;] 新增时，tagname 参数可选，默认值为 latest，即最后版本。如果执行新增命令时，已存在相同的 tagname 则会被覆盖。 删除标签 1$ npm dist-tag rm &lt;pckname&gt; &lt;tagname&gt; 查看存在的标签 1$ npm dist-tag ls [&lt;pckname&gt;] 列出包中已添加的 tags。会给出各标签名对应的版本号。 npm publish 命令1$ npm publish [--tag &lt;tagname&gt;] 执行该命令后，当前版本的包就会在 npm 上得到更新，并对该版本打上 &lt;tagname&gt; 标签，如果没有传入 --tag 参数，则其默认值为 latest。 git tag 命令这条命令是在 git push 之前为该代码版本打上标签 tag。通常我们会使用附注标签。 1$ git tag -a &lt;tagversion&gt; -m '&lt;tagmessage&gt;' 例如，我们给当前仓库代码打上 v1.2.0 的标签 tag。 12# 假定 working tree is clean$ git tag -a v1.2.0 -m 'version 1.2.0' 然后执行： 1git push --tags 现在我们的远程仓库中就有名为 v1.2.0 的 tags 标签版本了。 案例OK！需要了解的额外知识就是以上这些了。现在开始一个简单的案例。 首先，我们在之前已经有发布过一个 npm 包了，名字就叫做 hello-npm-test。现在，我们开始对它进行更新及版本维护。 当前 hello-npm-test 的版本图是这样的： 观察上图，hello-npm-test 的最后版本(latest)是 2.0.1，还有一个预先发布的测试版本(alpha) 2.0.3-alpha.0。 经过一段时间的测试，alpha 版 2.0.3-alpha.0 已经可以升级为最后的稳定版（latest）发布了。 首先 git 工作区是干净的，所有修改已全部提交至 github，然后我们对版本进行更新。 12$ npm version patchv2.0.3 hello-npm-test 的版本从 2.0.3-alpha.0 更新到了 2.0.3。然后执行发布命令：、 1$ npm publish 发布成功后的版本如下： 现在 2.0.3-alpha.0 这个版本的 dist-tag alpha 就可以删除了。 12$ npm dist-tag rm hello-npm-test alpha-alpha: hello-npm-test@2.0.3-alpha.0 现在 Current Tags 中就只有 2.0.3 这个 latest 标签了。其作为最后的稳定版本。 最高版本的小版本升级一段时间后，我们对 hello-npm-test 又加入了一些新的功能，这时，我们需要对其进行小版本(minor)的升级了。 先更新版本号： 12$ npm version minorv2.1.0 再发布： 1$ npm publish 更新后的版本图： 低的大版本持续维护当前 hello-npm-test 的最新版本为 2.x。但是此时，还在使用着 1.x 的同学们提交了 issue 说是有 BUGS 存在，希望尽快修复。那么我们会这样做： 注：在 hello-npm-test 的版本还是 1.x 的时，2.x准备开发的时候，我们创建了名为 1.x 的分支来管理 1.x 的代码。 好，我们切换到 1.x 分支。 1$ git checkout 1.x 然后一顿操作，BUGS 修复了，真快呢！嗯，男人不能说快，这叫猛！好了，提交至 github。这时，注意一定要打上标签附注版本号。 1234$ git add .$ git commit -m 'bug fix'$ git tag -a v1.2.1 -m 'bug fix to 1.2.1'$ git push --tags 然后根据这个 git tag 来为 1.x 升级版本。 123$ npm version from-gitv1.2.1$ npm publish 这样发布之后，1.2.1 就变为最后版本（latest）。我们需要将 2.1.0 重新设置为 latest。 1$ npm dist-tag add hello-npm-test@2.1.0 latest 这样就完成了一次 低的大版本 升级。然后我们就可以切换回 master 分支，继续 2.x 版本的开发维护了。 升级大版本为了响应新时代的召唤，我们决定对 hello-npm-test 进行一次大的颠覆性的改动，好刺激呢！ 首先，我们新建一个 2.x 的分支，用于之后维护 2.x 版本的代码。 12$ git checkout -b 2.x$ git push origin 2.x 推送到 github 上之后，我们再切换回 master 分支，进行 3.x 的开发工作。 1$ git checkout master 又是一顿华丽操作后，我们需要将 hello-npm-test 升级为 3.x。 123$ npm version majorv3.0.0$ npm publish 现在最新版本就是 3.0.0 了。 之后的各种升级就大同小异了，玩的愉快呢！]]></content>
      <categories>
        <category>npm相关</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>package</tag>
        <tag>version</tag>
        <tag>dist-tag</tag>
        <tag>git tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的EventLoop]]></title>
    <url>%2F2019%2F09%2F04%2Fjavascript%2FEventLoop%2FEventLoop%2F</url>
    <content type="text"><![CDATA[本文介绍 javascript 引擎中的事件循环（EventLoop）是如何工作的。 数据在内存中的存储方式在 javascript 中，数据类型分为 基本类型 和 引用类型。那么 基础类型 是存储在 栈内存(stack) 中的简单数据，按值存取，例如：Boolean，String，Number，undefined，null，Symbol，BigInt。 而 引用类型（Object，Function）则是存储在 堆内存(heap) 中，并在 栈内存 中存储着该 引用类型 数据的一个引用，指向该数据在 堆内存 的存储地址。 123456var a = ''var b = 14var obj = &#123; foo: '' &#125;var fn = function()&#123; console.log( 'hello' )&#125; 上面代码中各变量在内存中的存储形式如下： 执行栈（call stack）javascript 中，变量声明，函数调用都会按照程序的逻辑依次被压入栈内执行。 观察下面的代码： 12345678910111213// main.jsfunction multiply(a, b)&#123; return a * b;&#125;function calcSquare(n)&#123; return multiply(n, n);&#125;function printSquare(n)&#123; var result = calcSquare(n); console.log(result);&#125;printSquare(4); 我们在主程序 main.js 中依次定义了 multiply , calcSquare 和 printSquare 这3个函数。在 printSquare 中调用了 calcSquare，而 calcSquare 中又调用了 multiply。 主程序开始后，printSquare() 首先被压入执行栈，随后 calcSquare() 压入执行栈，最后是 multiply()。 栈具有 先进后出，后进先出 的特点，所以位于栈顶的函数先执行，依次类推。 以下是进栈后的情况： 现在，让我们看看上面代码在执行栈内执行的动态示意图： 栈内异常如果代码在栈内执行遇到错误，javascript 引擎会抛出如下错误，并终止主程序的继续执行。 栈满错误有时，由于程序过于庞大或代码编写失误，导致栈内任务剧增，使得执行栈满，javascript 引擎会抛出如下错误。 同步阻塞在主线程执行栈中，只能存在同步代码。也就是说，在执行栈中的任务都是同步任务。如果存在耗时较长的同步任务，那么我们的程序就会阻塞，直到上一个任务完成才会继续向下执行。 例如下面这样的代码： 123456789var a = $.getSynchronous("/a");var b = $.getSynchronous("/b");var c = $.getSynchronous("/c");// get data done, now log them outconsole.log(a);console.log(b);console.log(c); 在上方代码中，有3行耗时较长的同步代码，在这 3 行代码执行完之前，后面的打印操作便会一直处在等待状态（阻塞），那么在这个阻塞的事件段内，用户界面一直会处于白屏或 loading 态，这对于用户体验是很糟糕的。 异步回调观察下面的代码，思考其打印结果是什么？ 1234567console.log("Hello");setTimeout(function ()&#123; console.log("World");&#125;, 5000);console.log("Hi"); 打印结果： 123HelloHiWorld 那么，为什么会是这样的结果呢？它的执行过程是怎么样的？ 让我们再看一下上面代码的执行过程： 由于执行栈中只能存在同步代码，从执行栈内的动态示意图来看，同步的 console.log(&#39;Hello&#39;) , setTimeout(callback) （callback并没有被立即执行）, console.log(&#39;Hi&#39;) 被一次压入了执行栈内，而 setTimeout 中的回调函数最后被压入执行栈中。 事件循环到这里，终于可以谈一谈 事件循环 了，当我们的代码中出现了异步任务时，javascript 引擎是如何工作的呢？ 首先，javascript 引擎在完成代码解析后，将同步代码依次压入执行栈中，在遇到异步代码，例如：DOM 事件，AJAX请求，setTimeout/setInterval 这样的异步任务时，会在异步任务完成后，将其回调函数推进一个叫做 回调队列(Callback Queue) 的队列中，等待执行栈内的任务结束后，再依次从 回调队列 的队头取出回调函数压入执行栈中继续执行。 再让我们站在 事件循环 的角度看一次上面代码的执行过程： 如果 setTimeout(callback, 0) 会是怎样？1234567console.log("Hi");setTimeout(function ()&#123; console.log("there");&#125;, 0);console.log("Welcome"); 我们直接看上面代码的执行效果： 没错！依然是同步的任务先执行，异步任务的回调函数依然会在异步时间到的时候被推进 回调队列 中，在同步任务结束后执行栈空时，回调队列 中的任务才会被压进 执行栈。 在这里的延时时间 0，并不能阻碍 setTimeout() 是一个异步代码，其回调函数依然会被推进 回调队列 中。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>EventLoop</tag>
        <tag>heap</tag>
        <tag>stack</tag>
        <tag>call stack</tag>
        <tag>callback queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的this问题]]></title>
    <url>%2F2019%2F09%2F02%2Fjavascript%2Fthis%2Fthis%2F</url>
    <content type="text"><![CDATA[本文记录 javascript 中有关 this 的问题。 先看一道题如下代码，思考其中的各个打印都是什么？原因又是什么？ 123456789101112131415161718192021222324function fn() &#123; // 当前函数环境 console.log(this); // log1 var arr = [1, 2, 3]; // 立即执行函数 (function() &#123; console.log(this); // log2 &#125;)(); // es5普通函数 arr.map(function(item) &#123; console.log(this); // log3 return item + 1; &#125;); // es6箭头函数 let brr = arr.map(item =&gt; &#123; console.log("es6", this); // log4 return item + 1; &#125;);&#125;fn.call(&#123; a: 100 &#125;); 在上面代码中，我们首先声明了一个函数 fn，并在其后使用 fn.call() 的方式对其进行了调用，传入的 {a: 100} 对象使得 fn 函数中的 上下文环境 变为了 {a: 100}。再看 fn 函数内部： log1 打印，该行代码身处 fn 函数，上下文环境 为 {a: 100} ，所以，this 为 {a: 100}。 log2 打印，该行代码不再处于 fn 函数的 上下文环境，而是在一个 立即执行函数 中执行，this 指向全局 window。 log3 打印，这句打印被写在了 es5 的一个普通回调函数中，同样的 this 指向 window。 log4 打印，这次的回调函数使用了 es6 中的箭头函数，由于 箭头函数 本身没有 this 所需的执行环境上下文，所以会沿着作用域链向上查找，直到找到 fn 函数的上下文环境 {a: 100}。 最终结果： 12345678ObjectWindowWindowWindowWindowes6 Objectes6 Objectes6 Object 上面打印中的 Object 就是 {a: 100} 了。 再看一个例子12345678910var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 1foo() // 2 如上代码，执行的结果会有所不同。 这种差异的原因，就在于函数体内部使用了 this 关键字。很多教科书会告诉你，this 指的是函数运行时所在的环境。对于obj.foo()来说，foo运行在obj环境，所以this指向obj；对于foo()来说，foo运行在全局环境，所以this指向全局环境。所以，两者的运行结果不一样。 这种解释没错，但是教科书往往不告诉你，为什么会这样？也就是说，函数的运行环境到底是怎么决定的？举例来说，为什么obj.foo()就是在obj环境执行，而一旦var foo = obj.foo，foo()就变成在全局环境执行？ 下面就来解释 JavaScript 这样处理的原理。理解了这一点，你就会彻底理解 this 的作用。 内存的数组结构JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量 obj。JavaScript 引擎会先在内存里面，生成一个对象 { foo: 5 }，然后把这个对象的内存地址赋值给变量 obj。 也就是说，变量 obj 是一个地址（reference）。后面如果要读取 obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的 foo 属性，实际上是以下面的形式保存的。 注意，foo属性的值保存在属性描述对象的 value 属性里面。对象属性描述请参考 Object.defineProperty APIS。 对象属性为函数这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 foo 属性的 value 属性。 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() 环境变量JavaScript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量 x。该变量由运行环境提供。 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this 就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的 this.x 就是指当前运行环境的 x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x 指向全局环境的x。 当在 obj 环境中执行，this.x 则指向 obj.x。 回到第二个例子，obj.foo() 是通过 obj 找到 foo，所以就是在 obj 环境执行。一旦var foo = obj.foo，变量 foo 就直接指向函数本身，所以 foo() 就变成在全局环境执行。 构造函数12345678function Person( name , age )&#123; this.name = name this.age = age&#125;var p = new Person('hong', 18)console.log( p.name , p.age ) // hong 18 如上代码所示，对于构造函数中的 this 始终指向当前实例对象。 DOM事件那么，在DOM事件处理函数中，this 指向当前被绑定事件的 DOM 元素。 12345var body = document.querySelector('body')body.addEventListener('click', function(e)&#123; console.log( this === e.target ) // true&#125;) 总结this 的指向与函数定义时所处的环境无关，而是与其执行环境相关。各种情况如下： 作为普通函数调用时，函数中的 this 始终指向全局环境。 作为对象属性调用时，函数中的 this，指向该对象。 构造函数中的 this 指向实例对象。 DOM 事件中的 this 指向被绑事件 DOM 元素。 箭头函数中无执行上下文，this 沿作用域向上查找。 被 call、apply 和 bind 改变过 上下文环境 的函数调用，this 指向被绑对象。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中实现继承的几种方式]]></title>
    <url>%2F2019%2F09%2F01%2Fjavascript%2Finherit%2Finherit%2F</url>
    <content type="text"><![CDATA[本文介绍在 javascript 中如何实现继承，从 es5 到 es6 的各个实现方式。 绑定父类构造函数仅继承父类构造函数内的属性和方法。 12345678910111213141516171819202122function Person( name , age )&#123; this.name = name this.age = age this.play = function()&#123; console.log('i can play!') &#125;&#125;Person.prototype.say = function()&#123; console.log('hello i am' + this.name )&#125;function Man()&#123; // 调用父类的构造函数 Person.apply( this , arguments )&#125;var p = new Man('hong', 18)console.log( p.name , p.age ) // hong 18p.play() // i can play!p.say() // Uncaught TypeError: p.say is not a function 如上代码，我们在子类 Man 的构造函数内部使用了 apply 的方式调用了父类 Person 的构造方法，使得 Person 中的 this 指向 Man 的实例对象，从而实现了对 Person 构造函数内属性和方法的继承。但是无法继承 Person 原型上的属性和方法。 来自父类原型将父类的原型转接给子类的方式。 1234567891011121314151617181920212223242526272829function Person( name , age )&#123; this.name = name this.age = age this.play = function()&#123; console.log('i can play!') &#125;&#125;Person.prototype.say = function()&#123; console.log('hello i am a person')&#125;function Man( name , age )&#123; this.name = name this.age = age&#125;Man.prototype = new Person()Man.prototype.constructor = Man // 修复原型链指向// Man 自定义的方法或属性Man.prototype.foo = function()&#123; console.log('this is foo func in Man')&#125;var p = new Man('小红', 14) console.log( p.name , p.age ) // 小红 14p.say() // hello i am a personp.foo() // this is foo func in Manp.play() // Uncaught TypeError: p.play is not a function 如上代码，我们为了实现原型继承，将父类 Person 的实例对象赋值给了 Man.prototype 这时候 Man 便拥有了 Person 原型上的所有属性和方法。但是要注意，为了不破坏 Man 的原型链，必须将 Man.prototype.constructor 指向 Man。此时，我们没有继承到父类 Person 构造函数内的属性及方法。 组合继承通过上面的两种方式，我们已经可以继承到父类构造函数中的属性和方法，以及父类原型上的属性和方法了，那么，现在我们将其组合处理一下。 1234567891011121314151617181920212223function Person( name , age )&#123; this.name = name this.age = age this.play = function()&#123; console.log('i can play!') &#125;&#125;Person.prototype.say = function()&#123; console.log('hello i am' + this.name)&#125;function Man()&#123; Person.apply( this , arguments )&#125;Man.prototype = new Person()Man.prototype.constructor = Manvar p = new Man('小红', 14)console.log( p.name , p.age ) // 小红 14p.play() // i can play!p.say() // hello i am小红 经过如上处理，我们已经实现了对 Person 的非静态继承（继承自构造函数内属性和方法及原型上的属性和方法）。 Object.create 方法Object.create() 方法创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__。 语法1Object.create(proto[, propertiesObject]) 参数proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties() 的第二个参数。 返回值一个新对象，带着指定的原型对象和属性。 例子1234567891011function Person( name )&#123; this.name = name&#125;Person.prototype.say = function()&#123; console.log('hello')&#125;var p = Object.create(new Person('hong'))p.say() // hello 如上代码，通过 Object.create 创建的新对象 p 拥有了 Person 的原型方法和属性。 寄生组合继承现在让我们把所有的知识点结合起来，优化继承的实现。 1234567891011121314151617181920212223242526272829303132/** * 寄生组合继承的核心代码 * @param &#123;Function&#125; sub 子类 * @param &#123;Function&#125; parent 父类 */function inheritPrototype(sub, parent) &#123; // 拿到父类的原型 var prototype = Object.create(parent.prototype); // 改变constructor指向 prototype.constructor = sub; // 父类原型赋给子类 sub.prototype = prototype;&#125;function Person(name) &#123; this.name = name;&#125;Person.prototype.func = function() &#123; console.log("Person");&#125;;function Man() &#123; // 调用父类的构造函数 Person.apply(this, arguments); &#125;inheritPrototype(Man, Person);var p = new Man("小红");p.func(); // Personconsole.log(p.name); // 小红 es6中的继承class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 12345class Person &#123;&#125;class Man extends Person &#123;&#125; 上面代码定义了一个 Man 类，该类通过 extends 关键字，继承了 Person 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Person 类。下面，我们在Man 内部加上代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Person &#123; // 构造方法 constructor( name , age )&#123; this.name = name this.age = age &#125; // 原型方法 say()&#123; console.log('hello i am' + this.name + '(Preson)' ) &#125; // 静态方法 static foo()&#123; console.log('this is a static method foo') &#125;&#125;class Man extends Person &#123; constructor(name, age , height)&#123; // 调用父类的构造方法 super(name, age) // 之后，添加自身的实例属性或方法 this.height = height &#125; // 自身的挂载在原型上的方法 play()&#123; console.log('i can play') &#125; // 如果子类中有与父类相同的属性或方法，则优先调用子类的属性或方法 // say()&#123; // console.log('hello i am' + this.name + '(Man)' ) // &#125; // 自身的静态方法 static bar()&#123; console.log('this is a static method bar') &#125;&#125;let p = new Man('小红', 14, 188)console.log( p.name , p.age , p.height ) // 小红 14 188p.play() // i can playMan.bar() // this is a static method barp.say() // hello i am小红(Preson)Man.foo() // this is a static method foo 如上代码，我们可以对父类的 实例属性和方法，静态属性和方法以及原型属性和方法 进行继承，并且语法上更为清晰简单。 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。 12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint 继承了父类 Point，但是它的构造函数没有调用 super 方法，导致新建实例时报错。 ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。 另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。 super关键字super 这个关键字，既可以当作 函数 使用，也可以当作 对象 使用。在这两种情况下，它的用法完全不同。 作为函数时 super 作为函数调用非时，表示父类的构造函数 Parent.prototype.constructor，es6 规定，在使用 extends 实现继承时，必须先在子类的构造函数中优先调用一次 super()，否则直接使用 this 会报错。并且 super 作为函数调用时，只能出现在子类的构造函数中，用在其他地方会报错。 作为对象时 当 super 作为对象调用时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 ES6 规定，在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。 另外，在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。 注意，使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 Mixin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 1234567const a = &#123; a: 'a'&#125;;const b = &#123; b: 'b'&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: 'a', b: 'b'&#125; 上面代码中，c 对象是 a 对象和 b 对象的合成，具有两者的接口。 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。 12345678910111213141516171819202122232425262728function mix(...mixins) &#123; class Mix &#123; constructor() &#123; for (let mixin of mixins) &#123; copyProperties(this, new mixin()); // 拷贝实例属性 &#125; &#125; &#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); // 拷贝静态属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== 'constructor' &amp;&amp; key !== 'prototype' &amp;&amp; key !== 'name' ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的 mix 函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 123class DistributedEdit extends mix(Loggable, Serializable) &#123; // ...&#125;]]></content>
      <tags>
        <tag>inherit</tag>
        <tag>extends</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天然吸顶效果之sticky属性]]></title>
    <url>%2F2019%2F08%2F28%2Fcss%2Fcss3-sticky%2F</url>
    <content type="text"><![CDATA[元素吸顶效果很常见，最常见的实现方式莫过于通过 js 实现，但现如今我们有了更简便，更直接的方式来实现某元素吸顶效果，那就是使用 css3 中的 position: sticky 来实现。 效果 具体实现html结构 12345&lt;div&gt; this is a div &lt;/div&gt;&lt;h3&gt; this is a sticky h3 element &lt;/h3&gt;&lt;p&gt; this is a p&lt;/p&gt; css样式 1234567891011121314151617181920212223242526html,body &#123; margin: 0;&#125;div,h3,p &#123; text-align: center;&#125;p &#123; height: 2000px;&#125;div &#123; height: 50px;&#125;h3 &#123; width: 100%; height: 50px; line-height: 50px; background-color: aliceblue; /* 核心代码 */ position: -webkit-sticky; position: sticky; top: 0px;&#125; 如上代码所示，仅仅需要将 position 的属性设置为 sticky 并且使 top 是有值的，那么天然的吸顶效果瞬间达成。 sticky 说明经测试总结，position: sticky 规则有如下特性： 该规则属性，相当于 position: relative 和 position: fixed 的结合体。 必须明确设置（top,right,bottom,left）其中一个值，否则无粘滞效果。例：top: 10px 表示元素产生粘滞效果时，距离顶部的距离。 父元素不能设置 overflow: hidden，否则无粘滞效果。 父级元素也不能设置固定的 height 高度值，否则也没有粘滞效果。 同一个父容器中的 sticky 元素，如果定位值相等，则会重叠；如果属于不同父元素，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。 可能还会有其他意想不到的效果，后续发现后再补充说明。]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>sticky</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个元素吸顶效果指令实现]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%2Fdirectives%2Fv-affix%2F</url>
    <content type="text"><![CDATA[本文介绍基于 vue 的自定义吸顶指令 v-affix 的实现。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 // @/directives/affix.js // 导入 dom 处理工具 import dom from '@/utils/dom' export default &#123; bind(el)&#123; dom.css(el , &#123; width: '100%', zIndex: '1994214' &#125;) &#125;, inserted( el , &#123;value&#125; )&#123; if ( !value ) return const nextEl = el.nextElementSibling, // 后一兄弟节点元素 nextElPaddingTop = Number.parseFloat( dom.getStyleValue( nextEl , 'paddingTop') ), // 后一兄弟节点元素 padding-top 值 elOffsetTop = Number.parseFloat( dom.offset( el ).top ) , // 当前元素距离屏幕顶部的距离值 elHeight = Number.parseFloat(dom.getStyleValue( el , 'height' )); // 当前元素的高度值 // 滚动处理 el._affix_scroll_handle = function(e)&#123; let scroll_instance = window.pageYOffset || window.scrollY, position = 'static', paddingTop = nextElPaddingTop; if ( scroll_instance &gt;= elOffsetTop )&#123; position = 'fixed' paddingTop = elHeight + nextElPaddingTop + 'px' &#125;else&#123; position = 'static' paddingTop = nextElPaddingTop + 'px' &#125; dom.css( el , &#123; position, left: '0px', top: '0px' &#125;) dom.css(nextEl , &#123;paddingTop&#125;) &#125; // 点击处理（点击被绑指令元素时，自动滚动到顶部） el._affix_click_handle = function()&#123; window.scrollTo(0,0) &#125; window.addEventListener( 'scroll' , el._affix_scroll_handle ) el.addEventListener( 'click', el._affix_click_handle ) &#125;, unbind(el)&#123; el._affix_scroll_handle &amp;&amp; window.removeEventListener( 'scroll' , el._affix_scroll_handle ) el._affix_click_handle &amp;&amp; el.removeEventListener( 'click' , el._affix_click_handle ) &#125;&#125; dom.js工具函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 // /utils/dom.js const dom = &#123; // 设置样式 css( el , styles )&#123; for ( let k in styles )&#123; if ( styles.hasOwnProperty(k) ) el.style[k] = styles[k] &#125; &#125;, //获取指定样式 getStyleValue(elObj,attr)&#123; var view = elObj.ownerDocument.defaultView; if (!view || !view.opener) &#123; view = window; &#125; if(elObj.currentStyle)&#123; //IE return elObj.currentStyle[attr]; &#125;else&#123; return view.getComputedStyle(elObj)[attr]; //Firefox &#125; &#125;, //获取元素偏移量( top , left ) offset(curEle)&#123; var totalLeft = null,totalTop = null,par = curEle.offsetParent; //首先把自己本身的进行累加 totalLeft += curEle.offsetLeft; totalTop += curEle.offsetTop; //只要没有找到body，我们就把父级参照物的边框和偏移量累加 while(par)&#123; if(navigator.userAgent.indexOf("MSIE 8.0") === -1)&#123; //不是标准的ie8浏览器，才进行边框累加 //累加父级参照物边框 totalLeft += par.clientLeft; totalTop += par.clientTop; &#125; //累加父级参照物本身的偏移 totalLeft += par.offsetLeft; totalTop += par.offsetTop; par = par.offsetParent; &#125; return &#123;left:totalLeft,top:totalTop&#125;; &#125;, &#125;export default dom; 使用方式 注册 v-affix 指令。 1234567// main.jsimport Vue from 'vue'import affix from '@/directives/affix'Vue.directive( 'affix' , affix )// 忽略其他代码 ... 对需要吸顶的元素或组件添加 v-affix 指令即可。 1234567&lt;template&gt;&lt;div&gt; &lt;some-comp&gt;&lt;/some-comp&gt; &lt;some-comp2 v-affix&gt;&lt;/some-comp2&gt; &lt;some-comp3&gt;&lt;/some-comp3&gt;&lt;/div&gt;&lt;/template&gt; 然后，在窗体滚动到一定距离后，吸顶效果就会出现。 如果需要控制吸顶效果的开启状态，可向 v-affix 指令传入一个 Boolean 类型值。 1234567&lt;template&gt;&lt;div&gt; &lt;some-comp&gt;&lt;/some-comp&gt; &lt;some-comp2 v-affix="false"&gt;&lt;/some-comp2&gt; &lt;some-comp3&gt;&lt;/some-comp3&gt;&lt;/div&gt;&lt;/template&gt; 这样，就可以控制 v-affix 的开启状态。]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue自定义指令</tag>
        <tag>吸顶效果</tag>
        <tag>v-affix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm源管理器nrm]]></title>
    <url>%2F2019%2F08%2F26%2Fnpm%2Fnpm-nrm%2F</url>
    <content type="text"><![CDATA[本文介绍 npm 的源管理器 nrm 如何使用。nrm 可以帮助你快速、方便的在各个下载源之间切换，目前已经包括有：npm, cnpm, taobao, nj(nodejitsu). 等可供选择切换。 安装nrm 是一个 node 模块，所以使用 npm 命令安装即可。 1$ npm install nrm -g 可以通过 nrm -V 查看 nrm 的版本号。 123$ nrm -V$ 1.2.1 命令nrm ls查看可用的源。 123456789$ nrm ls$ * npm -------- https://registry.npmjs.org/ yarn ------- https://registry.yarnpkg.com/ cnpm ------- http://r.cnpmjs.org/ taobao ----- https://registry.npm.taobao.org/ nj --------- https://registry.nodejitsu.com/ npmMirror -- https://skimdb.npmjs.com/registry/ edunpm ----- http://registry.enpmjs.org/ 如上打印所示，以 * 号开头的表示当前正在使用的源，默认使用的则是npm 官方源地址。 nrm use切换 npm 的源。例如，切换到淘宝的源。 1$ nrm use taobao nrm add新增一个自定义的源。你可以增加定制的源，特别适用于添加企业内部的私有源，执行命令 nrm add &lt;registry&gt; &lt;url&gt;，其中 reigstry 为源名，url 为源的路径。 1nrm add myregistry http://192.168.10.127:8081/repository/npm-public/ 添加完后，你可以使用 nrm ls 命令查看可用源列表，使用 nrm use 切换源。 nrm del删除指定源。 1$ nrm del &lt;registry&gt; 例如，删除 myregistry 这个源：nrm del myregistry。 nrm test测试指定源的响应速度。 1$ nrm test &lt;registry&gt; 例：nrm test npm，测试官方源的响应速度。 1$ * npm ---- 812ms 测试淘宝源的速度：nrm test taobao。 1$ taobao - 132ms 可以看出淘宝源是要快很多的！所以对于网速慢的同学，可以通过 nrm 这个工具灵活切换合适的源，提高开发效率。]]></content>
      <categories>
        <category>npm相关</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>nrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XMLHttpRequest2新技巧]]></title>
    <url>%2F2019%2F05%2F03%2Fjavascript%2Fajax%2FXMLHttpRequestLevel2%2F</url>
    <content type="text"><![CDATA[HTML5 世界中有这样一位无名英雄：XMLHttpRequest。严格地说，XHR2 并不属于 HTML5。不过，它是浏览器供应商对于核心平台不断做出的改进中的一部分。我之所以将 XHR2 加入我们新的百宝囊中，就是因为它在如今复杂的网络应用中扮演了不可或缺的角色。 结果呢，我们这位老朋友来了个大变身，很多人都不知道它的新功能了。2 级 XMLHttpRequest 引入了大量的新功能（例如跨源请求、上传进度事件以及对上传/下载二进制数据的支持等），一举封杀了我们网络应用中的疯狂黑客。这使得 AJAX 可以与很多尖端的 HTML5 API 结合使用，例如File System API、Web Audio API 和 WebGL。 此教程重点介绍 XMLHttpRequest 中的新功能，尤其是可用于处理文件的功能。 抓取数据以前通过 XHR 抓取二进制 blob 形式的文件是很痛苦的事情。从技术上来说，这甚至是不可能的实现。有一种广为流传的一种技巧，是将 MIME 类型替换为由用户定义的字符集，如下所示： 提取图片的旧方法： 123456789101112131415161718var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);// Hack to pass bytes through unprocessed.xhr.overrideMimeType('text/plain; charset=x-user-defined');xhr.onreadystatechange = function(e) &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; var binStr = this.responseText; for (var i = 0, len = binStr.length; i &lt; len; ++i) &#123; var c = binStr.charCodeAt(i); //String.fromCharCode(c &amp; 0xff); var byte = c &amp; 0xff; // byte at offset i &#125; &#125;&#125;;xhr.send(); 虽然这种方法可行，但是 responseText 中实际返回的并不是二进制 blob，而是代表图片文件的二进制字符串。我们要巧妙地让服务器在不作处理的情况下，将这些数据传递回去。虽然这个技巧有用，但是我不推荐大家走这种歪门邪道。只要是通过玩弄字符代码和字符串操控技巧，强行将数据转化成所需的格式，都会出现问题。 指定响应格式在前一个示例中，我们通过替换服务器的 MIME 类型并将响应文本作为二进制字符串处理，下载了二进制“文件”形式的图片。现在，让我们利用 XMLHttpRequest 新增的 responseType 和 response 属性，告知浏览器我们希望返回什么格式的数据。 xhr.responseType 在发送请求前，根据您的数据需要，将 xhr.responseType 设置为 “text”、“arraybuffer”、“blob” 或 “document”。请注意，设置（或忽略）xhr.responseType = &#39;&#39; 会默认将响应设为 “text”。 xhr.response 成功发送请求后，xhr 的响应属性会包含 DOMString、ArrayBuffer、Blob 或 Document 形式（具体取决于 responseTyp 的设置）的请求数据。凭借这个优秀的新属性，我们可以修改上一个示例：以 ArrayBuffer 而非字符串的形式抓取图片。将缓冲区移交给 BlobBuilder API 可创建 Blob： 1234567891011121314151617BlobBuilder = window.MozBlobBuilder || window.WebKitBlobBuilder || window.BlobBuilder;var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);xhr.responseType = 'arraybuffer';xhr.onload = function(e) &#123; if (this.status == 200) &#123; var bb = new BlobBuilder(); bb.append(this.response); // Note: not xhr.responseText var blob = bb.getBlob('image/png'); ... &#125;&#125;;xhr.send(); 看，这不就好多了嘛！你觉得呢？ ArrayBuffer 响应ArrayBuffer 是二进制数据通用的固定长度容器。如果您需要原始数据的通用缓冲区，ArrayBuffer 就非常好用，但是它真正强大的功能是让您使用 JavaScript 类型数组 创建底层数据的“视图”。实际上，可以通过单个 ArrayBuffer 来源创建多个视图。例如，您可以创建一个 8 位整数数组，与来自相同数据的现有 32 位整数数组共享同一个 ArrayBuffer。底层数据保持不变，我们只是创建其不同的表示方法。 例如，下面以 ArrayBuffer 的形式抓取我们相同的图片，但是现在，会通过该数据缓冲区创建无符号的 8 位整数数组。 1234567891011var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);xhr.responseType = 'arraybuffer';xhr.onload = function(e) &#123; var uInt8Array = new Uint8Array(this.response); // this.response == uInt8Array.buffer // var byte3 = uInt8Array[4]; // byte at offset 4 ...&#125;;xhr.send(); Blob 响应如果您要直接处理 Blob 且/或不需要操作任何文件的字节，可使用 xhr.responseType=&#39;blob&#39;： 123456789101112131415161718192021window.URL = window.URL || window.webkitURL; // Take care of vendor prefixes.var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);xhr.responseType = 'blob';xhr.onload = function(e) &#123; if (this.status == 200) &#123; var blob = this.response; var img = document.createElement('img'); img.onload = function(e) &#123; window.URL.revokeObjectURL(img.src); // Clean up after yourself. &#125;; img.src = window.URL.createObjectURL(blob); document.body.appendChild(img); ... &#125;&#125;;xhr.send(); Blob 可用于很多场合，包括保存到 indexedDB、写入HTML5 文件系统 或创建 Blob 网址（如本例中所示）。 发送数据能够下载各种格式的数据固然是件好事，但是如果不能将这些丰富格式的数据送回本垒（服务器），那就毫无意义了。XMLHttpRequest 有时候会限制我们发送 DOMString 或 Document (XML) 数据。但是现在不会了。现已替换成经过修改的 send() 方法，可接受以下任何类型：DOMString、Document、FormData、Blob、File、ArrayBuffer。本部分的其余内容中的示例演示了如何使用各类型发送数据。 发送字符串数据：xhr.send(DOMString)12345678910111213function sendText(txt) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.onload = function(e) &#123; if (this.status == 200) &#123; console.log(this.responseText); &#125; &#125;; xhr.send(txt);&#125;sendText('test string'); 12345678910111213function sendTextNew(txt) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.responseType = 'text'; xhr.onload = function(e) &#123; if (this.status == 200) &#123; console.log(this.response); &#125; &#125;; xhr.send(txt);&#125;sendText2('test string'); 这没有新内容，只是正确的代码段略有不同。其中设置了 responseType=&#39;text&#39;作为对比。再次说明，省略此行会得到同样的结果。 提交表单：xhr.send(FormData)很多人可能习惯于使用 jQuery 插件或其他库来处理 AJAX 表单提交。而我们可以改用 FormData，这是另一种针对 XHR2 设计的新数据类型。使用 FormData 能够很方便地实时以 JavaScript 创建 HTML &lt;form&gt;。然后可以使用 AJAX 提交该表单： 1234567891011function sendForm() &#123; var formData = new FormData(); formData.append('username', 'johndoe'); formData.append('id', 123456); var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.onload = function(e) &#123; ... &#125;; xhr.send(formData);&#125; 实质上，我们只是动态创建了 &lt;form&gt;，并通过调用 append 方法为其附加了 &lt;input&gt; 值。 当然，您无需从一开始就创建 &lt;form&gt;。FormData 对象可通过页面上现有的 HTMLFormElement 进行初始化。例如： 12345&lt;form id="myform" name="myform" action="/server"&gt; &lt;input type="text" name="username" value="johndoe"&gt; &lt;input type="number" name="id" value="123456"&gt; &lt;input type="submit" onclick="return sendForm(this.form);"&gt;&lt;/form&gt; 12345678910111213function sendForm(form) &#123; var formData = new FormData(form); formData.append('secret_token', '1234567890'); // Append extra data before send. var xhr = new XMLHttpRequest(); xhr.open('POST', form.action, true); xhr.onload = function(e) &#123; ... &#125;; xhr.send(formData); return false; // Prevent page from submitting.&#125; HTML 表单可包含文件上传（例如 &lt;input type=&quot;file&quot;&gt;），而 FormData 也可以处理此操作。只需附加文件，浏览器就会在调用 send() 时构建 multipart/form-data 请求。 1234567891011121314151617function uploadFiles(url, files) &#123; var formData = new FormData(); for (var i = 0, file; file = files[i]; ++i) &#123; formData.append(file.name, file); &#125; var xhr = new XMLHttpRequest(); xhr.open('POST', url, true); xhr.onload = function(e) &#123; ... &#125;; xhr.send(formData); // multipart/form-data&#125;document.querySelector('input[type="file"]').addEventListener('change', function(e) &#123; uploadFiles('/server', this.files);&#125;, false); 上传文件或 blob：xhr.send(Blob)我们也可以使用 XHR 发送 File 或 Blob。请注意，所有 File 都是 Blob，所以在此使用两者皆可。 该示例使用 BlobBuilder API 从头开始创建新的文本文件，并将该 Blob 上传到服务器。该代码还设置了一个处理程序，用于通知用户上传进度： 1&lt;progress min="0" max="100" value="0"&gt;0% complete&lt;/progress&gt; 123456789101112131415161718192021222324function upload(blobOrFile) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.onload = function(e) &#123; ... &#125;; // Listen to the upload progress. var progressBar = document.querySelector('progress'); xhr.upload.onprogress = function(e) &#123; if (e.lengthComputable) &#123; progressBar.value = (e.loaded / e.total) * 100; progressBar.textContent = progressBar.value; // Fallback for unsupported browsers. &#125; &#125;; xhr.send(blobOrFile);&#125;// Take care of vendor prefixes.BlobBuilder = window.MozBlobBuilder || window.WebKitBlobBuilder || window.BlobBuilder;var bb = new BlobBuilder();bb.append('hello world');upload(bb.getBlob('text/plain')); 上传字节：xhr.send(ArrayBuffer)最后也是相当重要的一点就是，我们能以 XHR 的有效负载形式发送 ArrayBuffer。 123456789function sendArrayBuffer() &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.onload = function(e) &#123; ... &#125;; var uInt8Array = new Uint8Array([1, 2, 3]); xhr.send(uInt8Array.buffer);&#125; 跨源资源共享 (CORS)CORS 允许一个域上的网络应用向另一个域提交跨域 AJAX 请求。启用此功能非常简单，只需由服务器发送一个响应标头即可。 启用 CORS 请求假设您的应用已经在 example.com 上了，而您想要从 www.example2.com 提取数据。一般情况下，如果您尝试进行这种类型的 AJAX 调用，请求将会失败，而浏览器将会出现“源不匹配”的错误。利用 CORS，www.example2.com 只需添加一个标头，就可以允许来自 example.com 的请求： 1Access-Control-Allow-Origin: http://example.com 可将 Access-Control-Allow-Origin 添加到某网站下或整个域中的单个资源。要允许任何域向您提交请求，请设置如下： 1Access-Control-Allow-Origin: * 启用跨源请求是非常简单的，因此如果您的数据是公开的，请务必 启用 CORS！ 提交跨域请求如果服务器端已启用了 CORS，那么提交跨域请求就和普通的 XMLHttpRequest 请求没什么区别。例如，现在 example.com 可以向 www.example2.com 提交请求了： 1234567var xhr = new XMLHttpRequest();xhr.open('GET', 'http://www.example2.com/hello.json');xhr.onload = function(e) &#123; var data = JSON.parse(this.response); ...&#125;xhr.send(); 实际示例：下载文件并保存到 HTML5 文件系统假设您有一个图片库，想要提取一些图片，然后使用 HTML5 文件系统本地保存这些图片。一种方法是以 ArrayBuffer 形式请求图片，通过数据构建 Blob，并使用 FileWriter 写入 blob： 123456789101112131415161718192021222324252627282930window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;function onError(e) &#123; console.log('Error', e);&#125;var xhr = new XMLHttpRequest();xhr.open('GET', '/path/to/image.png', true);xhr.responseType = 'arraybuffer';xhr.onload = function(e) &#123; window.requestFileSystem(TEMPORARY, 1024 * 1024, function(fs) &#123; fs.root.getFile('image.png', &#123;create: true&#125;, function(fileEntry) &#123; fileEntry.createWriter(function(writer) &#123; writer.onwrite = function(e) &#123; ... &#125;; writer.onerror = function(e) &#123; ... &#125;; var bb = new BlobBuilder(); bb.append(xhr.response); writer.write(bb.getBlob('image/png')); &#125;, onError); &#125;, onError); &#125;, onError);&#125;;xhr.send(); 请注意：要使用此代码，请参阅“探索 FileSystem API”教程中的浏览器支持和存储限制。 分割文件并上传各个部分使用 File API，我们可以将操作简化为上传大文件。我们采用的技术是：将要上传的文件分割成多个部分，为每个部分生成一个 XHR，然后在服务器上将各部分组合成文件。这类似于 Gmail 快速上传大附件的方法。使用这种技术还可以规避 Google 应用引擎对 http 请求的 32 MB 限制。 123456789101112131415161718192021222324252627282930313233343536window.BlobBuilder = window.MozBlobBuilder || window.WebKitBlobBuilder || window.BlobBuilder;function upload(blobOrFile) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.onload = function(e) &#123; ... &#125;; xhr.send(blobOrFile);&#125;document.querySelector('input[type="file"]').addEventListener('change', function(e) &#123; var blob = this.files[0]; const BYTES_PER_CHUNK = 1024 * 1024; // 1MB chunk sizes. const SIZE = blob.size; var start = 0; var end = BYTES_PER_CHUNK; while(start &lt; SIZE) &#123; // Note: blob.slice has changed semantics and been prefixed. See http://goo.gl/U9mE5. if ('mozSlice' in blob) &#123; var chunk = blob.mozSlice(start, end); &#125; else &#123; var chunk = blob.webkitSlice(start, end); &#125; upload(chunk); start = end; end = start + BYTES_PER_CHUNK; &#125;&#125;, false);&#125;)(); 用于在服务器上重组文件的代码并未在此显示。 参考 2 级 XMLHttpRequest 规范 跨源资源共享 (CORS) 规范 File API 规范 FileSystem API 规范]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>XMLHttpRequest2</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的对象类型拷贝问题]]></title>
    <url>%2F2019%2F04%2F03%2Fjavascript%2Finstance%2FdeepCloneInJavscript%2F</url>
    <content type="text"><![CDATA[在这篇文章中，我们将讨论 对象类型(objects)、或者说引用类型在 javascript 中的拷贝问题，会分别对 浅拷贝 和 深拷贝 进行说明。 在开始之前，我们需要了解一些基础知识：Objects 在 javascript 中只是一块内存地址的简单引用，任何变量都可以指向这块地址，以至于有的时候，这使其变得难以琢磨，比如，将一个对象的引用复制给另一个变量，此时，这块地址就会有2处引用。 123456789101112131415var foo = &#123; a : "abc"&#125;console.log(foo.a); // abcvar bar = foo;console.log(bar.a); // abcfoo.a = "yo foo";console.log(foo.a); // yo fooconsole.log(bar.a); // yo foobar.a = "whatup bar?";console.log(foo.a); // whatup bar?console.log(bar.a); // whatup bar? 如上面代码，我们声明了一个 foo 变量，该变量指向 { a: &quot;abc&quot;} 对象所在的内存地址，此时，可以使用 foo.a 查看其中的属性 a 的值为 abc。之后，我们又将 foo 赋值给了 bar 变量，即将 { a: &quot;abc&quot;} 对象的地址赋值给了 bar 变量，这时候，该对象就被2个变量所引用，随后，我们执行 foo.a = &quot;yo foo&quot; 改变了该对象中 a 属性的值，再次打印 foo.a 和 bar.a 后显示的结果都是 yo foo。同理，修改 bar.a 得到的也是一样的结果，因为他们改变的都是同一个对象的属性值。 浅拷贝(shallow copy)如果你的对象里所有的属性值都是 值类型，那么你可以使用 es6 中新的对象API Object.assign() 或者使用扩展运算符 ... 进行拷贝操作，俗称 浅拷贝。 123var obj = &#123; foo: "foo", bar: "bar" &#125;;var copy = &#123; ...obj &#125;; // Object &#123; foo: "foo", bar: "bar" &#125; 123var obj = &#123; foo: "foo", bar: "bar" &#125;;var copy = Object.assign(&#123;&#125;, obj); // Object &#123; foo: "foo", bar: "bar" &#125; 上面的两种方式都可以将多个源对象中的属性拷贝到目标对象上。 12345var obj1 = &#123; foo: "foo" &#125;;var obj2 = &#123; bar: "bar" &#125;;var copySpread = &#123; ...obj1, ...obj2 &#125;; // Object &#123; foo: "foo", bar: "bar" &#125;var copyAssign = Object.assign(&#123;&#125;, obj1, obj2); // Object &#123; foo: 但问题是，对于上面的两种方式，如果被拷贝的对象中的属性值也是一个对象类型，那么，对于该属性的拷贝只是拷贝一个对象的引用，这跟第一个例子是一样的情况 var bar = foo; ： 12345678var foo = &#123; a: 0 , b: &#123; c: 0 &#125; &#125;;var copy = &#123; ...foo &#125;;copy.a = 1;copy.b.c = 2;console.dir(foo); // &#123; a: 0, b: &#123; c: 2 &#125; &#125;console.dir(copy); // &#123; a: 1, b: &#123; c: 2 &#125; &#125; 也就是说，你并没有拷贝出一个副本出来，不管对哪个变量进行了修改，那个属性值为对象类型的属性都会被改变。 深拷贝(deep copy)为了能够 深拷贝 一个对象类型的值，一种解决方法是，首先将该对象序列化成一个 JSON 字符串，然后再将其解析回来。 12var obj = &#123; a: 0, b: &#123; c: 0 &#125; &#125;;var copy = JSON.parse(JSON.stringify(obj)); 不幸的是，这种方式只对那些可以序列化为 JSON 格式的数据有用，并且要求这些属性值不存在任何的循环引用。比如，Date 对象，当你对其进行 字符串化 后，再解析回来的时候，该数据就只是一个时间字符串了，而不是原先的 Date 对象。 123var d = new Date() // Wed Apr 10 2019 16:49:10 GMT+0800 console.log(JSON.parse( JSON.stringify(d) )) // "2019-04-10T08:49:10.865Z" 最终解决综上所述，我们需要对不同的数据类型进行处理，所以有如下方法： 1234567891011121314151617181920212223242526272829303132333435363738394041function deepClone(obj) &#123; var copy; // Handle the 3 simple types, and null or undefined if (null == obj || "object" != typeof obj) return obj; // Handle Date if (obj instanceof Date) &#123; copy = new Date(); copy.setTime(obj.getTime()); return copy; &#125; // Handle Array if (obj instanceof Array) &#123; copy = []; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; copy[i] = deepClone(obj[i]); &#125; return copy; &#125; // Handle Function if (obj instanceof Function) &#123; copy = function() &#123; return obj.apply(this, arguments); &#125; return copy; &#125; // Handle Object if (obj instanceof Object) &#123; copy = &#123;&#125;; for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) copy[attr] = deepClone(obj[attr]); &#125; return copy; &#125; throw new Error("Unable to copy obj as type isn't supported " + obj.constructor.name);&#125; 具体思路，就是针对不同类型的数据做不同的拷贝处理，对于有循环引用的数据进行递归操作。上面的函数可以直接应用在实际项目中。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>引用类型</tag>
        <tag>深浅拷贝</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS radial-gradient() 函数]]></title>
    <url>%2F2019%2F04%2F02%2Fcss%2Fcss3-radial-gradient%2F</url>
    <content type="text"><![CDATA[CSS radial-gradient() 函数创建一个 &lt;image&gt;，用来展示由 原点（渐变中心） 辐射开的颜色渐变。这个方法得到的是一个 CSS &lt;gradient&gt; 数据类型的对象。本篇文章记录其简单使用及案例。 案例首先献上 佐助万花筒写轮眼 效果案例。 以下是源码： 12345&lt;div class="ordit"&gt; &lt;div class="maga1 mage"&gt;&lt;/div&gt; &lt;div class="maga2 mage"&gt;&lt;/div&gt; &lt;div class="maga3 mage"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425.ordit&#123; width: 400px; height: 400px; background: #525252; border-radius: 50%; position:relative; &#125; .mage&#123; width: 395px; height: 150px; position:absolute; top:50%; background: radial-gradient(197.5px 75px ellipse,transparent 112px,#E24545 190px,#000 196px,transparent 197.5px) , radial-gradient(50px circle,#525252 47px,#000 49px,transparent 50px); &#125; .maga1&#123; transform:translateY(-50%) rotate(90deg); &#125; .maga2&#123; transform:translateY(-50%) rotate(45deg); &#125; .maga3&#123; transform:translateY(-50%) rotate(135deg); &#125; 介绍由于 radial-gradient() 创建的是一个 &lt;image&gt; 类型，所以其只能作用于像 background-image 或 border-image 这样的定义图片的 css 规则上。 径向渐变的形成径向渐变(Radial gradients) 由其 中心点、边缘形状轮廓 及 位置、色值结束点（color stops） 定义而成。 径向渐变的 中心点 至 边缘形状 以及其延伸的部分，由连续缩放的若干同心轮廓 组成，这个轮廓由设定的边缘形状决定。色值结束点 用于设定 虚拟渐变射线（virtual gradient ray） 的变化方式，由 中心点 水平变化至右侧（如下图）。色值结束点 由百分比设定时，则是相对于终点为 渐变射线 与边缘形状相交点的 渐变半径，渐变半径 的终点位置即为 100%。每个轮廓均为纯色，颜色由 渐变射线 上相应 横切点 所定义的颜色决定。边缘形状只能为圆形或者椭圆形。 语法radial-gradient() 只存在两种渐变形状，正圆（circle）和椭圆（ellipse），大体的语法如下。 1radial-gradient( [ x [, y] ] [ circle | ellipse ] [ extent-keyword ] at [ position ] , [color-stop [, length | persentage]]+ ) 只设置起始颜色和结束颜色对于径向渐变，在不指定渐变类型以及起点位置的情况下，其渐变距离和位置是由容器的尺寸决定的。渐变的起点位置会在容器的正中间开始，渐变的类型则和容器的宽高比例相关。 123456.a&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient(yellow,red);&#125; 1&lt;div class="a"&gt;&lt;/div&gt; circle关键字规定渐变形状为圆形circle 关键字规定渐变的形状为圆形，设置了渐变形状后，其渐变距离为圆的最长对角线距离的一半，渐变结束线既不是按照宽度来的，也不是按照高度来的，是按照最远边角距离作为渐变结束线的。 123456.b&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient(circle,yellow,red);&#125; 1&lt;div class="b"&gt;&lt;/div&gt; 渐变的半径形状关键字前只写一个值表示圆形的半径，此时 circle 关键字可缺省。 123456.c&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient(80px circle,yellow,red);&#125; 1&lt;div class="c"&gt;&lt;/div&gt; at关键字设置渐变起点at 后的第一个值表示：圆心（渐变起点）在容器中的横坐标，第二个值表示：圆心（渐变起点）在容器中的纵坐标 。 注：坐标值可以是百分比值 或者 像素值。 123456.d&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient(at 50px 50px,yellow,red);&#125; 1&lt;div class="d"&gt;&lt;/div&gt; 通过 at 关键字，设置渐变的起始位置,去掉 circle 关键字，则渐变形状会与容器比例保持一致。这是会变成默认的椭圆。 123456.e&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient(at 50px 50px,yellow,red);&#125; 1&lt;div class="e"&gt;&lt;/div&gt; 设置渐变的结束位置radial-gradient 径向渐变支持4个关键字可以指定渐变终止点位置，如下： 1234closest-side: 渐变中心距离容器最近的边作为终止位置。closest-corner: 渐变中心距离容器最近的角作为终止位置。farthest-side: 渐变中心距离容器最远的边作为终止位置。farthest-corner: 渐变中心距离容器最远的角作为终止位置(默认)。 123456.f&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient(closest-side at 50px 50px,yellow,red);&#125; 1&lt;div class="f"&gt;&lt;/div&gt; 设置颜色断点的位置如果指定多个颜色，但未指定具体断点的位置，则这些颜色会均匀分配 0%~100% 的渐变区域。 123456.g&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient( circle closest-side ,yellow,red 33.33%,orange 66.666%,white);&#125; 1&lt;div class="g"&gt;&lt;/div&gt; ellipse关键字设置椭圆渐变椭圆渐变需要确定两个方向上的轴距离，第一个值表示横轴的半径值，第二个值表示纵轴的半径值。 123456.h&#123; width: 400px; height: 200px; margin-bottom: 50px; background: radial-gradient(100px 50px ellipse at 100px 100px,yellow,red 33.33%,orange 66.666%,skyblue);&#125; 1&lt;div class="h"&gt;&lt;/div&gt; 渐变的累加12345678.j&#123; width: 200px; height: 100px; margin-bottom: 50px; background: radial-gradient(200px 100px ellipse,transparent 90px,yellow 91px,red 99px,transparent 100px), radial-gradient(30px circle, red, red 29px, transparent 30px);&#125; 1&lt;div class="j"&gt;&lt;/div&gt; 注意：当使用累加渐变背景的时候，需要给前一个渐变背景起始颜色设置为透明色否则无法显示出后设置的渐变背景。 作用在border-image123456789.i&#123; width: 100px; height: 100px; border: 50px solid; /* border-radius: 50%; */ margin-bottom: 50px; border-image: radial-gradient(circle, transparent 50px, yellow 51px, red) 50 stretch; /*可惜border-image无法和border-radius同时生效*/&#125; 1&lt;div class="i"&gt;&lt;/div&gt; 可惜 border-image 无法和 border-radius 同时生效，否则，天然镂空的铜钱效果随即出现…]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>radial-gradient</tag>
        <tag>径向渐变</tag>
        <tag>image type</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的相等性判断]]></title>
    <url>%2F2019%2F04%2F02%2Fjavascript%2Finstance%2FequalInJavascript%2F</url>
    <content type="text"><![CDATA[JavaScript 提供三种不同的值比较操作： 严格相等 (“triple equals” 或 “identity”)，使用 === 宽松相等 (“double equals”) ，使用 == 以及 Object.is （ECMAScript 2015/ ES6 新特性） 选择使用哪个操作取决于你需要什么样的比较。 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ); 而Object.is的行为方式与三等号相同，但是对于NaN和 -0 和 +0 进行特殊处理，所以最后两个不相同，而Object.is（NaN，NaN）将为 true。(通常使用双等号或三等号将 NaN 与 NaN 进行比较，结果为 false) 请注意，所有这些之间的区别都与其处理原语有关; 这三个运算符的原语中，没有一个会比较两个变量是否结构上概念类似。对于任意两个不同的非原始对象，即便他们有相同的结构， 以上三个运算符都会计算得到 false 。 严格相等 ===全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。 123456789101112131415var num = 0;var obj = new String("0");var str = "0";var b = false;console.log(num === num); // trueconsole.log(obj === obj); // trueconsole.log(str === str); // trueconsole.log(num === obj); // falseconsole.log(num === str); // falseconsole.log(obj === str); // falseconsole.log(null === undefined); // falseconsole.log(obj === null); // falseconsole.log(obj === undefined); // false 在日常中使用全等操作符几乎总是正确的选择。对于除了数值之外的值，全等操作符使用明确的语义进行比较：一个值只与自身全等。对于数值，全等操作符使用略加修改的语义来处理两个特殊情况：第一个情况是，浮点数 0 是不分正负的。区分 +0 和 -0 在解决一些特定的数学问题时是必要的，但是大部分情况下我们并不用关心。全等操作符认为这两个值是全等的。第二个情况是，浮点数包含了 NaN 值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。全等操作符认为 NaN 与其他任何值都不全等，包括它自己。（等式 (x !== x) 成立的唯一情况是 x 的值为 NaN） 宽松相等 ==相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符 === 的比较方式。 相等操作符满足交换律。 一般而言，根据 ECMAScript 规范，所有的对象都与 undefined 和 null 不相等。但是大部分浏览器允许非常窄的一类对象（即，所有页面中的 document.all 对象），在某些情况下，充当效仿 undefined 的角色。相等操作符就是在这样的一个背景下。因此，IsFalsy(A) 方法的值为 true ，当且仅当 A 效仿 undefined。在其他所有情况下，一个对象都不会等于 undefined 或 null。 1234567891011121314151617var num = 0;var obj = new String("0");var str = "0";var b = false;console.log(num == num); // trueconsole.log(obj == obj); // trueconsole.log(str == str); // trueconsole.log(num == obj); // trueconsole.log(num == str); // trueconsole.log(obj == str); // trueconsole.log(null == undefined); // true// both false, except in rare casesconsole.log(obj == null);console.log(obj == undefined); Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符 == 和严格相等运算符 ===。它们都有缺点，前者会自动转换数据类型，后者的 NaN 不等于自身，以及 +0 等于 -0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符 === 的行为基本一致。 1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true ES5 可以通过下面的代码，部署 Object.is。 12345678910111213Object.defineProperty(Object, 'is', &#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;); 判等对照表 x y == === Object.is() undefined undefined true true true null null true true true true true true true true false false true true true “foo” “foo” true true true 0 0 true true true +0 -0 true true false 0 false true false false “” false true false false “” 0 true false false “0” 0 true false false “17” 17 true false false [1,2] “1,2” true false false new String(“foo”) “foo” true false false null undefined true false false null false false false false undefined false false false false { foo: “bar” } { foo: “bar” } false false false new String(“foo”) new String(“foo”) false false false 0 null false false false 0 NaN false false false “foo” NaN false false false NaN NaN false false true]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>非严格相等 ==</tag>
        <tag>严格相等 ===</tag>
        <tag>Object.is</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何发布一个自己的node模块到npm]]></title>
    <url>%2F2019%2F04%2F01%2Fnpm%2FhowToPublishANodeModuleToNpm%2F</url>
    <content type="text"><![CDATA[本文介绍如何创建一个自己的 node 模块，以及怎样发布到 npm ，与其他开发人员共享你的模块。 前言作为一个前端开发人员，或者 nodejs 开发人员，目前我们使用最多的模块管理机制实属是 npm。我们可以使用很简单方式引用其他开发者发布到 npm 的模块。例如，当需要在你的项目中使用 vue。那么你可以： 1$ npm install vue --save 安装 vue 模块到你的项目中，然后通过简单的导入命令使用她： 123456789const Vue = require('vue')// 或者使用 es Module 语法import Vue from 'vue'new Vue(&#123; // ...&#125;) 那么，我们自己怎样去创建一个自己模块，并且发布到 npmjs 呢？ 准备在开始之前，你需要有 3 样关键的工具，请确保你已经安装或者注册了。 编辑器，推荐使用 Visual Studio Code Node.js 环境 npm 账户 创建一个模块npm init首先，我们要初始化一个 node 项目，也就是你的 node 包。随便在电脑的哪个位置创建一个新的文件夹，名字嘛，假定我们叫她 hello-npm-test。什么！你说她俗气？没办法！因为 苏大强 喜欢，我 苏明成 表示也没有办法。 OK！使用编辑器打开并进入到 hello-npm-test 文件夹，使用 npm init 初始化 package.json。 1$ npm init 这时你会看到一些提示： 123456789101112131415161718192021222324252627282930313233343536373839404142elenh@elenh MINGW64 ~/Desktop/hello-npm-test$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (hello-npm-test) hello-npm-testversion: (1.0.0)description: a node test module which will be published to npm.entry point: (index.js)test command:git repository:keywords: npm node testauthor: elenhlicense: (ISC)About to write to C:\Users\yisiw\Desktop\hello-npm-test\package.json:&#123; "name": "hello-npm-test", "version": "1.0.0", "description": "a node test module which will be published to npm.", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [ "npm", "node", "test" ], "author": "elenh", "license": "ISC"&#125;Is this ok? (yes) y 具体的意思就是确定 package.json 文件中的一些必要字段信息。比如，包的名字 name ，包的语义化版本号 version ，包的描述信息 description，包的入口点 （entry point）main，测试脚本命令 （test command）script，git 仓库地址 （git repository），在 npm 中的搜索关键字 keywords ，包的作者名 author 以及该包的开源许可证类别 license。 注：如果直接按回车的话，表示直接使用默认值设置该字段，但是作为一个即将要把包发布到 npm 的模块分享者来说，请仔细填写这些信息。因为这关系到该模块是否能正常使用（main 入口点），或者说别的开发者能够方便检索到你的模块（keywords, description）。很关键的一点是，你的 version 字段一定要遵循 npm 的语义化版本定义规则。以便使用此模块的开发者知道使用该模块的哪个版本。关于 语义化版本规则 请参考本博客的另一篇文章 npm使用说明。 编写模块现在，我们已经初始化好了 package.json 文件。是时候创建模块文件了。在 hello-npm-test 文件夹中新建一个名为 index.js 的文件。并在里面写入如下代码： 123module.exports = function ( str )&#123; console.log( 'hello' + str )&#125; 如上，使用 CommonJs 模块语法默认导出了一个函数，代码质量及其酷炫。苏明玉 都表示很惊讶！ 至于为什么使用名为 index.js 的文件呢？这边要说的话就需要展开 nodejs 的模块加载规则了，嗯，苏明哲让我别展开了，听大哥的话，所以请自行 Google。 另一点需要说的是，在 package.json 文件中，我们定义了模块的入口点（entry point）main 字段，其默认值就是 index.js。她表示当使用模块导入语法使用该模块时，使用哪个文件作为入口点。当然，你可以修改她，比如： 123&#123; "main": "src/index.js"&#125; 表示模块入口点为 src 文件夹下的 index.js 文件。 测试你的模块到目前为止，你的模块已经可用了，那么怎么测试你的模块呢？此时，因为还没有发布到 npm ，所以不能使用如下方式直接安装。 1$ npm install hello-npm-test 重新创建一个项目文件夹用来测试我们新写的模块，名为 my-project 。进入到该文件夹，初始化 node 项目。 1npm init -y 此时，我们直接使用默认的 package.json 的设置即可，因为只是用来测试的。 同样，我们新建一个 index.js 文件，并准备在该文件中使用 hello-npm-test 模块。 两种方式来引用她： 可以使用本地绝对路径引用的方式来使用她。 cd 进入到 my-project 文件夹中，并安装 hello-npm-test。 1$ npm install C:/Users/yisiw/Desktop/hello-npm-test 然后你可以看到 my-project 文件夹中的 package.json 文件中多出了 dependencies 字段如下： 123456789101112131415&#123; "name": "my-project", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC", "dependencies": &#123; "hello-npm-test": "file:../hello-npm-test" &#125;&#125; 在 index.js 中使用她。 12345// my-project/index.jsconst log = require('hello-npm-test')log('npm') 然后在终端执行： 12$ node index.jshellonpm 没错！成功的打印出了 hellonpm，鼓掌。 你也可以使用 npm link 将 hello-npm-test 包关联到全局后通过 npm link hello-npm-test 来使用她。 首先进入到 hello-npm-test 文件中，打开命令行，输入如下命令： 1npm link 这句命令的意思是将本模块地址关联到 nodejs 的全局环境中，以便可以在本机的任何项目中使用她。 1$ E:\nodejs\node_modules\hello-npm-test -&gt; C:\Users\yisiw\Desktop\hello-npm-test 执行完 npm link 后，会出现上方的提示信息，表示 hello-npm-test 模块的副本已经安装关联到 nodejs 的全局环境中了，你可以打开如上方的路径地址找到hello-npm-test 模块文件夹，就在 （E:\nodejs\node_modules\hello-npm-test）。 为了同第一种方式区分开，我们首先把之前的 node_modules 文件夹、package-lock.json 和 package.json 中的 dependencies 字段删除，然后进入到 my-project 文件夹中。输入如下命令： 12345npm link hello-npm-testelenh@elenh MINGW64 ~/Desktop/my-project$ npm link hello-npm-testC:\Users\yisiw\Desktop\my-project\node_modules\hello-npm-test -&gt; E:\nodejs\node_modules\hello-npm-test -&gt; C:\Users\yisiw\Desktop\hello-npm-test 执行完 npm link hello-npm-test 命令后，你会发现，my-project 文件夹中的 node_mnodules 右出现了，并且里面存在 hello-npm-test 包。那么我们再次执行： 12$ node index.jshellonpm 没错，同样是有用的。 将模块管理到 Github接下来，我们应该将我们的包使用版本控制工具管理起来，方便之后的维护及更新。没错！是 Github。理所当然！ 123456$ git init$ git add .$ git commit -m 'Initial commit'$ git remote add origin https://github.com/yisibell/hello-npm-test$ git push -u origin master 然后在 package.json 文件中加入 homepage 字段，并写上你的仓库地址。方便别人可以在 Github 中找到该项目。 123&#123; "homepage": "https://github.com/yisibell/hello-npm-test"&#125; 添加 README.md在开发完你的包功能后，你应该创建一个 README.md 文件来描述你的包。 这个包怎么安装 这个包是用来干什么的 这个包解决了什么问题 这个包有哪些配置项及APIS 添加.npmignore在开发你的包的过程中，你可能会新建一些依赖文件，测试文件等，比如：package-lock.json、node_modules、.gitignore、test、打包构建配置、以及 .npmignore 自身。这些都是不需要发布到 npm 上的。 判别的基本原则就是，与该包不相关且其他人引入时，不需要加载的，我们都应该进行忽略。 cd 进入到 hello-npm-test ，打开你的终端命令行敲入 touch .npmignore 在项目包的根目录下新建 .npmignore 文件。 1touch .npmignore 然后在该文件中写入你要忽略的文件、文件夹配置。 1234node_modules/.gitignoretest/package-lock.json 注意：可别把 package.json 忽略掉了。这是必须上传的关键文件，该包的信息都被保存在该文件中，使用者使用导入语法导入该模块时，也是通过 package.json 文件中的 main 字段来查找入口文件。 发布到 npm最后一步就是发布你的模块到 npm。进入到 hello-npm-test ，打开命令行。敲入如下命令： 1npm adduser 结果： 123456elenh@elenh MINGW64 ~/Desktop/hello-npm-test (master)$ npm adduserUsername: elenhPassword:Email: (this IS public) yisiwings@163.comLogged in as elenh on https://registry.npmjs.org/. 按提示输入 用户名（Username）、密码（Password）以及邮箱（Email）后，便会提示你已经作为谁谁谁登陆到了 npm。 1Logged in as elenh on https://registry.npmjs.org/. 你可以使用 npm version 查看该模块当前所处的版本： 1234567891011121314151617$ npm version&#123; 'hello-npm-test': '1.0.0', npm: '5.6.0', ares: '1.10.1-DEV', cldr: '32.0', http_parser: '2.8.0', icu: '60.1', modules: '57', napi: '3', nghttp2: '1.29.0', node: '8.11.2', openssl: '1.0.2o', tz: '2017c', unicode: '10.0', uv: '1.19.1', v8: '6.2.414.54', zlib: '1.2.11' &#125; 当前版本为 1.0.0。 紧接着就是将包发布。 1$ npm publish 在发布的过程中，你可能会遇到一些错误，比如 npm 中已经有存在你当前的这个包名了。那么修改你的包名再发布。 使用现在，你可以使用诸如：$ npm install hello-npm-test --save，这样的方式来安装你自己的包了，并且在其他项目中使用她。 123const log = require('hello-npm-test')log('，明玉') 打印结果： 123$ node index.jshello，明玉 维护和升级你的包在不断使用的过程中，使用者们或你自己会发现，她存在某些 BUGS ，或者需要优化，再或者你需要添加新的功能 APIS。 假定，你已经对包升级完毕，那么怎样更新 npm 上的包数据呢？这同样很简单，你只需要按照 语义化版本规则 更新你的版本号后，再修改下 README.md 说明文档，指出你的哪些改动，以及新的 API 用法。你就可以在该包根目录下打开命令行再次键入： 1npm publish 你的包就会在 npmjs 被更新为一个新的版本。使用者们，不定期的执行 npm outdated 就会看到你的包的更新情况，并更新他们本地的包文件。 版本号更新方式通常，当你的爱包中的代码被你优化修改了，你需要先升级你的包版本号，然后再 npm publish。你有以下两种更新版本号的方式。 手动修改 package.json 中的 version 字段，注意遵循 语义化版本规则。然后再 npm publish。 使用 npm version &lt;update_type&gt; 命令。 其中 update_type 参数有 3 个常用可选值：patch , minor 和 major。 patch 表示补丁级别的版本更新，即递增第三位版本号 minor 表示小版本级别的版本更新，即递增第二位版本号 major 表示大版本级别的版本更新，即递增第一位版本号 &lt;update_type&gt; 的其他值，不在此处列出，| premajor | preminor | prepatch | prerelease [--preid=&lt;prerelease-id&gt;] | from-git。 例：当前 hello-npm-test 的版本号为 1.0.1，我们现在对小版本进行更新。 12$ npm version minorv1.1.0 如上打印结果，版本号已经升级到了第二位上，注意，因为是递增制，所以第三位版本号恢复从 0 开始。 然后你就可以将新的版本发布到 npm 了。 1npm publish 注意：在使用 npm version &lt;update_type&gt; 更新版本号之前，你需要先将你的代码提交到 github 否则会调用命令失败！]]></content>
      <categories>
        <category>npm相关</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中数据类型的几种判断方式]]></title>
    <url>%2F2019%2F04%2F01%2Fjavascript%2Finstance%2FhowToCheckDataTypeInjavascript%2F</url>
    <content type="text"><![CDATA[在开发中，我们经常需要对数据类型进行判断，再做不同的操作，这篇文章将讲解在 javascript 中对不同数据类型进行判断的方式。 数据类型既然要判断 javascript 中的数据类型，那么首先你需要知道在 javascript 中有哪些数据类型。 基本数据类型Number类型数值类型，如：0, 1, -1, 2.3 , Infinity , -Infinity 等都是 Number类型。 String类型字符串类型，如：&#39;foo&#39; , &#39;123&#39; 等都是 String 类型。 Boolean类型值为 true 或 false。 引用类型Array类型数组类型，如：let arr = [1,2] 或 let arr = new Array(1,2)。 Object类型对象类型，如：let obj = { name: &#39;foo&#39; } 或 let obj = new Object({name: &#39;bar&#39;})。 Function函数申明，函数表达式的类型都为 function 。例：12345// 函数申明function foo()&#123;&#125;// 函数表达式const bar = function()&#123;&#125; 其他undefiend变量已申明未赋值时的默认值都为 undefined，默认的函数返回值也是 undefined。例：1234567let foo; console.log( foo ) // undefinedconst bar = function()&#123;&#125;console.log( bar() ) // undefined null空类型，只有单一的一个值，即 null 本身，由于历史问题，null 在 javascript 中被认为是复杂数据类型(引用类型)。当使用 typeof null，它返回的是 object。 es6Symbol类型es6 中新增的数据类型，其是作为全局函数而非构造函数 Symbol()，表示独一无二的唯一值，常被用来定义对象的属性名。 123let obj = &#123; [Symbol('foo')]: 'foo'&#125; 类型判断typeoftypeof 运算符可以判断简单类型的数据类型，但对于复杂数据类型则无法准确判断。 123456789101112typeof 1 // numbertypeof '' // stringtypeof true // booleantypeof false // booleantypeof undefined // undefinedtypeof null // objecttypeof new Array() // objecttypeof new Object() // objecttypeof new Date() // objecttypeof new RegExp() // objecttypeof function foo()&#123;&#125; // functiontypeof Symbol('bar') // symbol 如上方代码所示，typeof 运算符只能用于判断 Number , String , Boolean , undefined Function , 和 Symbol 类型。其他类型都统一返回 object。 instanceofinstanceof 运算符用于判断对象是否为某个构造函数的实例。返回值为 Boolean 类型。她只可用来判断对象类型数据。 12345678let arr = [1]arr instanceof Array // truearr instanceof Object // truelet obj = &#123;name: 'foo'&#125;obj instanceof Object // true 当用在简单类型数据上是，其始终返回 false。null 和 undefined 也总是返回 false。 123456789let num = 12, str = '', bol = true;num instanceof Number // falsestr instanceof String // falsebol instanceof Boolean // falseundefined instanceof Object // falsenull instanceof Object // false Function.prototype.name利用 Function 的实例属性 name 可以获取函数名称，所以可以通过查看目标数据类型的构造函数 constructor 的 name 属性来判断数据类型。 123456789101112131415let num = 1, str = '', bol = true, arr = [1], obj = &#123;foo: 'bar'&#125;, date = new Date(), reg = new RegExp();num.constructor.name // Numberstr.constructor.name // Stringbol.constructor.name // Booleanarr.constructor.name // Arrayobj.constructor.name // Objectdate.constructor.name // Datereg.constructor.name // RegExp undefined 、 null 和 Symbol 除外，因为他们没有构造函数。 Object.prototype.toString.call()借助 Object 的实例方法 toString 也可以判断数据的类型，该方法会返回类似于 [object xxx] 的字符串格式，xxx 表示该数据类型的构造函数名。但对于 undefined 、null 和 Symbol，不可把 xxx 理解为构造函数，因为他们真的没有。 1234567891011121314151617181920212223let num = 1, str = '', bol = true, arr = [1], obj = &#123;foo: 'bar'&#125;, date = new Date(), reg = new RegExp(), foo = null, bar = undefined, sym = Symbol('sym'), fun = function()&#123;&#125;;Object.prototype.toString.call(num) // [object Number]Object.prototype.toString.call(str) // [object String]Object.prototype.toString.call(bol) // [object Boolean]Object.prototype.toString.call(arr) // [object Array]Object.prototype.toString.call(obj) // [object Object]Object.prototype.toString.call(date) // [object Date]Object.prototype.toString.call(reg) // [object RegExp]Object.prototype.toString.call(foo) // [object Null]Object.prototype.toString.call(bar) // [object Undefined]Object.prototype.toString.call(sym) // [object Symbol]Object.prototype.toString.call(fun) // [object Function] 如上方代码，各种类型都可以很好的区分，为了使用方便，我们可以将其封装为一个简单的函数调用。 123456function getType(_val)&#123; let s = Object.prototype.toString.call(_val) return s.slice( s.indexOf(' ') + 1 , s.length - 1 )&#125;getType(1) // Number 综上前3中方式都有不同的缺陷，使用存在问题，而第4种方式对于所有的数据类型都可以很好的区分，所以可以直接应用在实际项目中。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>typeof</tag>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Grid网格布局]]></title>
    <url>%2F2019%2F03%2F25%2Fcss%2Fcss3-grid%2F</url>
    <content type="text"><![CDATA[Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。同时跟表格 &lt;table&gt; 也有些相似，也有 单元格 的概念。 Flex 布局是轴线布局，只能指定 “项目” 针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成 “行” 和 “列”，产生单元格，然后指定 “项目所在” 的单元格，可以看作是二维布局。Grid 布局是继 Flex 布局之后的又一布局利器。 基本概念容器和项目采用网格布局的区域，称为 “容器”（container）。容器内部采用网格定位的子元素，称为 “项目”（item）。 12345678&lt;div class="container"&gt; &lt;div class="item item-1"&gt; 1 &lt;/div&gt; &lt;div class="item"&gt; &lt;span&gt; 2 &lt;/span&gt; &lt;/div&gt; &lt;div class="item"&gt; 3 &lt;/div&gt; &lt;div class="item"&gt; 4 &lt;/div&gt; &lt;div class="item"&gt; 5 &lt;/div&gt; &lt;div class="item"&gt; 6 &lt;/div&gt;&lt;/div&gt; 上面代码中，最外层的 &lt;div&gt; 元素就是 容器，内层的 6 个 &lt;div&gt; 元素就是 项目。 注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 &lt;span&gt; 元素 和文本内容就不是项目。Grid 布局只对项目生效。 行和列容器里面的 水平区域 称为 “行”（row），垂直区域 称为 “列”（column）。 上图中，水平的深色区域就是 “行”，垂直的深色区域就是 “列”。 单元格行和列的交叉区域，称为 “单元格”（cell）。 正常情况下，n行 和 m列 会产生 n x m 个单元格。比如，3行3列 会产生 9 个单元格。 网格线划分网格的线，称为 “网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 正常情况下，n 行有 n + 1 根水平网格线，m 列有 m + 1 根垂直网格线，比如三行就有四根水平网格线。 上图是一个 4 x 4 的网格，共有 5 根水平网格线和 5 根垂直网格线。 容器规则Grid 布局的规则分成两类。一类定义在容器上面，称为 容器规则；另一类定义在项目上面，称为项目规则。这部分先介绍 容器规则。 display将容器元素的 display 规则设置为 grid 即可启用 网格布局。 123.grid &#123; display: grid;&#125; 默认情况下，容器元素都是块级元素，但也可以设成行内元素。 123.grid &#123; display: inline-grid;&#125; 注意，设为网格布局以后，容器的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 grid-template-rowsgrid-template-columns容器指定了网格布局以后，接着就要划分行和列。grid-template-columns 规则定义每一列的列宽，grid-template-rows 规则定义每一行的行高。 1234567.box-1 &#123; /* 定义网格的行：这里为 3 行 ，每行的高度分别为：100px 100px 100px */ grid-template-rows: 100px 100px 100px; /* 定义网格的列：这里为 3 列 ，每列的宽度分别为：100px 100px 100px */ grid-template-columns: 100px 100px 100px;&#125; 如上图，使用的是绝对单位，定义了 3*3 的网格布局，列宽和行高 还可以使用百分比，如下： 12345.box-2 &#123; height: 300px; grid-template-rows: 33.33% 33.33% 33.33%; grid-template-columns: 33.33% 33.33% 33.33%;&#125; 使用百分比单位时，会根据容器的宽高按比例自动分配行高和列宽。 网格线的名称grid-template-columns 和 grid-template-rows 的值中可以设置每条网格线的名称。下面代码指定网格布局为 2行 x 3列，因此有 4 根垂直网格线和 3 根水平网格线。方括号里面依次是这 7 根线的名字。网格布局允许同一根线有多个名字，比如 [fifth-line row-5]。 12345678&lt;div class="grid box-3"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt;&lt;/div&gt; 12345.box-3 &#123; height: 200px; grid-template-rows: [r1] 50% [r2] 50% [r3]; grid-template-columns: [c1] 33.33% [c2] 33.33% [c3] 33.33% [c4];&#125; grid-row-gapgrid-column-gapgrid-row-gap 定义网格中行与行之间的间距。grid-column-gap 定义网格中列与列之间的间距。 12345678&lt;div class="grid box-4"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt;&lt;/div&gt; 123456.box-4 &#123; grid-template-rows: 100px 100px; grid-template-columns: 200px 200px 200px; grid-row-gap: 50px; grid-column-gap: 50px;&#125; 如上图，定义了 2*3 的网格，行与行之间的间隔为 50px ，列与列之间的间隔为 50px。 grid-gapgrid-gap 是 grid-row-gap 和 grid-column-gap 的简写属性。 1grid-gap: [grid-row-gap] [grid-column-gap]; 如果 grid-gap 省略了第二个值，浏览器认为第二个值等于第一个值。 根据最新标准，上面三个属性名的 grid- 前缀已经删除，grid-column-gap 和 grid-row-gap 写成 column-gap 和 row-gap，grid-gap 写成 gap。 grid-template-areas网格布局允许指定 “区域”（area），一个区域由单个或多个单元格组成。grid-template-areas 属性用于定义区域。下面代码先划分出 6 个单元格，然后将其定名为 a 到 f 的 6 个区域，分别对应这 6 个单元格。 如果某些区域不需要利用，则使用 “点”（.）表示。 12345678&lt;div class="grid box-5"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt;&lt;/div&gt; 123456.box-5 &#123; grid-template-rows: 100px 100px; grid-template-columns: 200px 200px 200px; grid-template-areas: 'a b c' 'd e f';&#125; grid-auto-flow划分网格以后，容器中的子元素 (项目) 会按照顺序，自动放置在每一个网格。默认的放置顺序是 “先行后列”，即先填满第一行，再开始放入第二行，以此类推。 1grid-auto-flow: row; 将 grid-auto-flow 的值设置为 column 后，变为 “先列后行”。 1grid-auto-flow: column; grid-auto-flow 的值还可以设成 row dense 和 column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。 让 1号项目 和 2号项目 各占据两个单元格，然后在默认的 grid-auto-flow: row 情况下，会产生下面这样的布局。 1号项目 后面的位置是空的，因为 1号项目 的后方不够 2号项目 放置，并且 3号项目 默认跟着 2号项目，所以会排在2号项目后面。 12345678&lt;div class="grid box-8"&gt; &lt;div class="item item-1"&gt;1&lt;/div&gt; &lt;div class="item item-2"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt;&lt;/div&gt; 1234567891011.box-8 &#123; grid-template-columns: repeat(3, 100px); grid-template-rows: repeat(3, 100px); grid-auto-flow: row;&#125;.box-8 .item-1 &#123; background-color: #ef342a; grid-column-start: 1; grid-column-end: 3; &#125; 将 grid-auto-flow 的值设置为 row dense 后，表示 “先行后列”，并且尽可能紧密填满，尽量不出现空格。 如果将设置改为 column dense，表示 “先列后行”，并且尽量填满空格。 项目在单元格中的对齐方式justify-items设置项目在单元格中水平方向上的位置（左 start 中 center 右 end 拉伸(默认) stretch）。 align-items设置项目在单元格中垂直方向上的位置（左 start 中 center 右 end 拉伸(默认) stretch）。 1234start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。center：单元格内部居中。stretch：拉伸，占满单元格的整个宽度（默认值）。 place-itemsplace-items 属性是 align-items 属性和 justify-items 属性的合并简写形式。 1place-items: [align-items] [justify-items]; 单元格的内容左对齐，效果如下图。 1justify-items: start; 单元格的内容头部对齐，效果如下图。 1align-items: start; 项目在容器中的对齐方式justify-contentjustify-content 属性可以定义整个内容区域在容器里面的水平放置位置（左中右）。 align-contentalign-content 属性可以定义整个内容区域在容器里面的垂直放置位置（左中右）。 上面两个属性都可以使用如下值： 1234567start : 网格线开始位置，靠左或靠上。end : 网格线结束位置，靠右或靠下。center : 垂直或水平居中。stretch : 项目大小没有指定时，拉伸占据整个网格容器。space-around : 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。space-between : 项目与项目的间隔相等，项目与容器边框之间没有间隔。space-evenly : 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以 justify-content 属性为例，align-content 属性的图完全一样，只是将水平方向改成垂直方向。） start 对齐容器的起始边框。 end : 网格线结束位置，靠右或靠下。 center : 垂直或水平居中。 stretch : 项目大小没有指定时，拉伸占据整个网格容器。 space-around : 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between : 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly : 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-contentplace-content 属性是 align-content 属性和 justify-content 属性的合并简写形式。 1place-content: [align-content] [justify-content]; grid-auto-columnsgrid-auto-rowsgrid-auto-columns 和 grid-auto-rows 属性用来设置，浏览器自动创建的多余网格的列宽和行高。用法和 grid-template-columns 、grid-template-row 一毛一样。 12345678 &lt;div class="box-11 grid"&gt; &lt;div class="item item-1"&gt;1&lt;/div&gt; &lt;div class="item item-2"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt;&lt;/div&gt; 123456789.box-11 &#123; grid-template-columns: repeat(3,100px); grid-template-rows: repeat(2,100px);&#125;.box-11 .item-1 &#123; grid-column-start: 1; grid-column-end: 3;&#125; 如上图所示，区域 1 占据了 2 个单元格，导致第6个单元格无法放置在原本的网格内，浏览器自动根据第6块内容的大小创建了一个单元格。该单元格的宽高取决于这块内容自身的大小。 当我们设置了 grid-auto-columns 和 grid-auto-rows 属性时，浏览器则会根据这两个属性值去生成多余单元格的大小。 1234.box-11 &#123; grid-auto-columns: 100px; grid-auto-rows: 100px;&#125; 如下图： grid-templategrid-template 属性是 grid-template-columns、grid-template-rows 和 grid-template-areas 这三个属性的合并简写形式。 gridgrid 属性是 grid-template-rows、grid-template-columns、grid-template-areas、grid-auto-rows、grid-auto-columns、grid-auto-flow 这六个属性的合并简写形式。 函数minmax()使用 minmax() 函数约定长度范围。 12345&lt;div class="grid box-1"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt;&lt;/div&gt; 12345.box-1 &#123; height: 100px; /* 共定义了 3 列，第一、二列 占容器总宽度的 1/3 。第3列 最少占200px 宽度，最大占 容器总宽度的 1/3 */ grid-template-columns: 1fr 1fr minmax(200px , 1fr);&#125; 上方代码规则定义了 1*3 的网格，第 3 列单元格 使用了 minmax() 函数定义该列的列宽规则。表示，最小有 200px 宽，最大有 容器总宽度的 1/3。如下图，当缩小容器宽度的时候，前 2 列的宽度值由于是相对单位，会进行适应缩放，而第 3 列 则会 最小保持 200px 的列宽。 repeat()repeat() 函数可以某个值的次数。通常作用于 grid-template-rows 和 grid-template-columns。 第一个参数：重复的次数。第二个参数：要重复的值。 1234567891011&lt;div class="grid box-3"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt; &lt;div class="item"&gt;7&lt;/div&gt; &lt;div class="item"&gt;8&lt;/div&gt; &lt;div class="item"&gt;9&lt;/div&gt;&lt;/div&gt; 123456.box-3 &#123; /* 使用 repeat() 函数 简化 重复值 */ height: 300px; grid-template-rows: repeat( 3, 33.33% ); grid-template-columns: repeat( 3, 33.33% );&#125; 上面代码规则等同于： 12345.box-3 &#123; height: 300px; grid-template-rows: 33.33% 33.33% 33.33%; grid-template-columns: 33.33% 33.33% 33.33%;&#125; 也可以使用 repeat() 函数重复某种模式。第一个参数：重复模式的次数。第二个参数：要重复的模式。 123456789101112131415161718192021.box-4 &#123; /* 使用 repeat() 函数 以某种模式重复 */ grid-template-rows: repeat( 2, 200px 100px ); grid-template-columns: repeat( 2, 200px 100px ); /* 上面代码定义了 4 行 ，4 列 ，也就是有 4*4=16 的单元格 */ /* 拆分开来为： grid-template-rows: 200px 100px 200px 100px grid-template-columns: 200px 100px 200px 100px 第 1 个单元格的 高为 200px 宽为 200px 第 2 个单元格的 高为 200px 宽为 100px ...... */&#125; 123456789101112131415161718&lt;div class="grid box-4"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt; &lt;div class="item"&gt;7&lt;/div&gt; &lt;div class="item"&gt;8&lt;/div&gt; &lt;div class="item"&gt;9&lt;/div&gt; &lt;div class="item"&gt;10&lt;/div&gt; &lt;div class="item"&gt;11&lt;/div&gt; &lt;div class="item"&gt;12&lt;/div&gt; &lt;div class="item"&gt;13&lt;/div&gt; &lt;div class="item"&gt;14&lt;/div&gt; &lt;div class="item"&gt;15&lt;/div&gt; &lt;div class="item"&gt;16&lt;/div&gt;&lt;/div&gt; 关键字auto-fill使用 auto-fill 关键字 控制自动填充。 如下代码规则，列数自动填充，直到放不下为止，且每列的宽度为 200px。 123456&lt;div class="grid box-5"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;/div&gt; 12345678910.box-5 &#123; grid-auto-rows: 100px; /* 定义行高为 100px ，默认网格占据有 2 行的高度*/ grid-template-rows: repeat( 2 , 100px ); /* 列数自动填充，直到放不下为止，且每列的宽度为 200px */ grid-template-columns: repeat( auto-fill , 200px ); &#125; fr使用 fr 关键字表示比例关系。 如下代码规则，第二列为第一列的2倍宽。 123456&lt;div class="grid box-6"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;/div&gt; 123456.box-6 &#123; height: 300px; /* 第2列的宽度为第1列的 2 倍 */ grid-template-columns: 1fr 2fr; grid-template-rows: 100px 100px;&#125; fr 与 绝对单位 结合使用。第一列为固定宽度 200px，第3列宽为第2列的2倍。 12345678&lt;div class="grid box-7"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt; &lt;/div&gt; 12345.box-7 &#123; /* 第3列的宽度为第2列的 2 倍 */ grid-template-columns: 200px 1fr 2fr; grid-template-rows: 100px 100px;&#125; fr 之 圣杯布局12345 &lt;div class="grid box-8"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt;&lt;/div&gt; 12345.box-8 &#123; /* 经典的 高度固定，两端固定，中间自适应的三列布局 */ grid-template-columns: 200px 1fr 200px; grid-template-rows: 100px;&#125; autoauto 关键字，表示由浏览器自己决定宽度。 如下，第1、3列为固定100px宽度，中间的第2列宽度由浏览器自动计算，即自适应。 12345 &lt;div class="grid box-2"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt;&lt;/div&gt; 1234.box-2&#123; height: 100px; grid-template-columns: 100px auto 100px;&#125; 项目规则下面这些规则定义在项目上面。 grid-row-startgrid-row-endgrid-column-startgrid-column-end项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 1234grid-row-start 用来设置 `上边框` 所在的网格线位置。grid-row-end 用来设置 `下边框` 所在网格线的位置。grid-column-start 用来设置 `左边框` 所在网格线的位置。grid-column-end 用来设置 `右边框` 所在网格线的位置。 12345678&lt;div class="grid box box-1"&gt; &lt;div class="item item-1"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt;&lt;/div&gt; 12345678910.box &#123; grid-template-columns: repeat(3,100px); grid-template-rows: repeat(3,100px);&#125;.box-1 .item-1 &#123; background-color: red; grid-column-start: 2; grid-column-end: 4;&#125; 如上图：1号项目的左边框被设置在第2根垂直网格线上，右边框被设置在第4根垂直网格线上。使得 1 号项目横跨了 第2、3个单元格。 剩余项目则跟在其后自动排布。这时它们的位置由容器的 grid-auto-flow 属性决定，这个属性的默认值是 row，因此会”先行后列”进行排列。 这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。 1234.item-1 &#123; grid-column-start: header-start; grid-column-end: header-end; &#125; 这四个属性的值还可以使用 span 关键字，表示 “跨越”，即左右边框（上下边框）之间跨越多少个网格。 12345678&lt;div class="grid box box-2"&gt; &lt;div class="item item-1"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt;&lt;/div&gt; 如上图：第一个项目横跨了第一个和第二个单元格。这与下面代码效果一样： 123.item-1 &#123; grid-column-end: span 2; &#125; 使用这四个属性，如果产生了项目的重叠，则使用 z-index 属性指定项目的重叠顺序。 grid-columngrid-rowgrid-column 属性是 grid-column-start 和 grid-column-end 的合并简写形式，grid-row 属性是 grid-row-start 和 grid-row-end 的合并简写形式。 下面是一个例子： 1234567891011.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2; &#125; /* 等同于 */ .item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 这两个属性之中，也可以使用 span 关键字，表示跨越多少个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3; &#125; /* 等同于 */ .item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2; &#125; 斜杠以及后面的部分可以省略，默认跨越一个网格。 1234.item-1 &#123; grid-column: 1; grid-row: 1; &#125; 上面代码中，项目item-1占据左上角第一个网格。 grid-areagrid-area 属性指定项目放在哪一个区域。 1234567891011 &lt;div class="grid box-4"&gt; &lt;div class="item item-1"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt; &lt;div class="item"&gt;5&lt;/div&gt; &lt;div class="item"&gt;6&lt;/div&gt; &lt;div class="item"&gt;7&lt;/div&gt; &lt;div class="item"&gt;8&lt;/div&gt; &lt;div class="item"&gt;9&lt;/div&gt;&lt;/div&gt; 123456789101112.box-4 &#123; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i';&#125;.box-4 .item-1 &#123; background-color: #b03532; grid-area: e;&#125; 如上图：将 1 号项目放置在 e 区域中。 项目中内容的对齐方式justify-self设置单元格内容的水平位置（左中右），只作用于单个项目中。 align-self设置单元格内容的垂直位置（上中下），只作用于单个项目中。 这两个属性都可以去下面这些值： 1234start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 下面是 justify-self: start 的例子： place-selfalign-self 和 justify-self 的简写属性。 1place-self: [align-self] [justify-self]; 如果省略第二个值，place-self 属性会认为这两个值相等。]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>Grid</tag>
        <tag>css 布局</tag>
        <tag>网格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linear-gradient线性渐变说明]]></title>
    <url>%2F2019%2F03%2F19%2Fcss%2Fcss3-linear-gradient%2F</url>
    <content type="text"><![CDATA[记录 css3 中 linear-gradient 线性渐变的基本使用。 简介CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于&lt;gradient&gt; 数据类型，是一种特别的 &lt;image&gt; 数据类型。 列： 1234567891011121314.box &#123; width: 200px; height: 400px; /* 渐变轴为180度，从红色渐变到蓝色 */ background: linear-gradient( 180deg , red , blue ); /* 从右下到左上、从蓝色渐变到红色 */ background: linear-gradient(to left top, blue, red); /* 从下到上，从蓝色开始渐变、到高度40%位置是绿色渐变开始、最后以红色结束 */ background: linear-gradient(0deg, blue, green 40%, red); &#125; 线性渐变的形成某个容器元素的线性渐变效果由 渐变线 上的各 着色点 平滑形成。而 渐变线（Gradient Line） 的形成由容器元素 中心点 和 渐变角度 所决定。一但 渐变线 被确定，那么渐变效果会从 起始点（Starting Point） 开始，沿着 渐变线 ，将 渐变线 上各点的颜色映射到容器元素对应区域点上，直到 结束点（Ending Point）。这就像是，在一张画布上连续的放置了一排不同的颜料，刷子沿着这些颜料一刷后，你所看到的颜色效果。 渐变 起始点 的确定： 起始点 是 渐变线 上代表起始颜色值的点。起始点 由 渐变线 和过容器元素顶点的垂直线之间的交叉点来定义。（垂直线跟渐变线在同一象限内） 渐变 结束点 的确定： 结束点 是 渐变线 上代表最终颜色值的点。结束点 也是由 渐变线 和从最近的顶点发出的垂直线之间的交叉点定义的，然而从 起始点 的对称点来定义 结束点 是更容易理解的一种方式，因为 结束点 是 起始点 关于容器元素的 中心点 的反射点。 语法12linear-gradient( [ &lt;angle&gt; | to &lt;side-or-corner&gt; ,]? &lt;start color&gt; [ &lt;percentage&gt; | &lt;length&gt; ], &lt;colors&gt; [ &lt;percentage&gt; | &lt;length&gt; ] , &lt;end color&gt; [ &lt;percentage&gt; | &lt;length&gt; ]) 按顺序来解释linear-gradient() 函数的参数： 第一个参数： 角度 或者 边角，由此指定渐变的方向。角度值单位为 deg，边角的可选值有：left , right , top , bottom , left top , left bottom , right top , right bottom 。边角值只是角度值的快捷值，角度值是以容器元素中心点为轴顺时针旋转形成，如果不给定此参数的话，默认的角度值为 180deg ，即 to bottom，渐变效果是从上到下的。 第二个参数(必需)： 起始点颜色值及其断点长度。断点长度值单位可以是 px 或 百分比。 第三及其后的参数： 中间点颜色值及其断点长度。即中间可以设置多个不同的颜色渐变。 最后一个参数(必需)： 结束点颜色值及其断点长度。 例： 12345.box &#123; width: 400px; height: 300px; background: linear-gradient( 180deg , red 50% , blue , yellow );&#125;]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>linear-gradient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm使用说明]]></title>
    <url>%2F2019%2F03%2F14%2Fnpm%2Fnpm%2F</url>
    <content type="text"><![CDATA[介绍 npm 的使用。 npm简介npm有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。 npm不需要单独安装。在安装Node的时候，会连带一起安装npm。但是，Node附带的npm可能不是最新版本，使用下方命令查看npm的版本。 123$ npm -v# or$ npm --version 如果不是最新的，最好用下面的命令，更新到最新版本： 1$ npm install npm@latest -g 基本命令npm listnpm list 列出项目的依赖信息。也可以使用 npm ls 简写命令。 1234567891011# 列出当前项目的说有依赖项$ npm list# 只列出一层深度依赖项$ npm list --depth 0# 列出在全局的所有安装包信息$ npm list -g# 只列出全局的一层递归深度的安装包信息$ npm list -g --depth 0 npm init使用npm init初始化包。即初始化 package.json 文件。 1234567# 会有一系列提问设置，根据提问设置package.json文件中的基本字段内容$ npm init# 跳过提问环节，直接使用默认设置初始化package.json文件$ npm init -y# or$ npm init -yes 我们可以为 init 命令初始化一些值，如： 123&gt; npm set init.author.email "yisiwings@163.com"&gt; npm set init.author.name "hongwenqing"&gt; npm set init.license "MIT" npm installNode模块采用npm install命令安装。 每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如eslint和@vue/cli。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 123456# 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install --global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; 安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数。 1$ npm install &lt;package name&gt; --force 如果你希望，所有模块都要强制重新安装，那就删除node_modules目录，重新执行npm install。 12$ rm -rf node_modules$ npm install install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。 123$ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" 如果使用--save-exact参数，会在package.json文件指定安装模块的确切版本。 1$ npm install readable-stream --save --save-exact install命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在packages.json文件的哪一项中。 –save：模块名将被添加到dependencies，可以简化为参数-S。–save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。 12345$ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D npm install默认会安装dependencies字段和devDependencies字段中的所有模块，如果使用--production参数，可以只安装dependencies字段的模块。 123$ npm install --production# 或者$ NODE_ENV=production npm install 如果你的网速很慢，建议使用淘宝镜像代理。安装完后，你就可以使用 cnpm 代替 npm 命令。npm 特有的一些命令除外，比如：npm adduser 、npm login 、npm publish等等。 12# 安装cnpm 命令行工具 ，使用淘宝的npm 镜像$ npm install -g cnpm --registry=https://registry.npm.taobao.org npm updatenpm update命令可以更新本地安装的模块。 12345# 升级当前项目的指定模块或所有可以更新的模块$ npm update [package name]# 升级全局安装的模块$ npm update --global [package name] 它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。在升级包时，npm 会根据 package.json 文件中定义的 语义化版本规则 判断应该更新安装哪个版本的包。使用 npm outdated 命令可以准确查看通过 语义化版本规则 计算出来的版本号（Wanted字段）。 执行更新命令后 package.json 里面模块的版本号变化： 123456789// 更新之前的package.jsondependencies: &#123; dep1: "^1.1.1"&#125;// 更新之后的package.jsondependencies: &#123; dep1: "^1.2.2"&#125; :warning: 注意，从npm v2.6.1 开始，npm update只更新顶层模块，而不更新依赖的依赖，以前版本是递归更新的。如果想取到老版本的效果，要使用下面的命令： 1$ npm --depth 9999 update npm uninstallnpm uninstall命令，卸载已安装的模块。 12345# 卸载指定的本地模块$ npm uninstall [package name]# 卸载全局模块$ npm uninstall [package name] --global npm runnpm不仅可以用于模块管理，还可以用于执行脚本。package.json文件有一个scripts字段，可以用于指定脚本命令，供npm直接调用。 123456789101112&#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; 其他命令npm linknpm link 命令可以将某个模块关联安装到 nodejs 全局环境中，以便可以在本机的任何项目中引用她。 比如，我们在构建自己的模块的时候，我们需要对其进行测试，在没有发布到 npmjs 上之前，我们无法使用如下命令来安装她： 1npm install my-module 这时，npm link 就可以派上用场了，我们 cd 进入到 my-module 项目所在根目录后，打开终端命令行，键入： 1npm link 此时，my-module 模块的副本已经被关联并安装到 nodejs 的全局环境中。 1$ E:\nodejs\node_modules\my-module -&gt; C:\Users\yisiw\Desktop\my-module 当要使用 my-module 模块时，可以直接在项目内命令行中输入： 1npm link my-module my-module 模块就会被安装在 node_mnodules 文件夹中，此时，你就可以使用导入语法导入她了 1const foo = require('my-module') 这在编写自己的模块，需要测试的时候尤其有用。 npm home，npm reponpm home 命令可以打开一个模块的主页，npm repo 命令则是打开一个模块的代码仓库。 12$ npm home &lt;package name&gt;$ npm repo &lt;package name&gt; 这两个命令不需要模块先安装。 npm outdatednpm outdated 命令检查当前项目所依赖的模块，是否已经有新版本。 1$ npm outdated 它会输出当前版本（current version）、应当安装的版本（wanted version）和最新发布的版本（latest version）。 注：(wanted version) 是根据 package.json 文件中的依赖字段申明的语义化版本规则推算出来的。详见下方的语义化版本规则 查看说明。 npm prunenpm prune 检查当前项目的node_modules目录中，是否有package.json里面没有提到的模块，然后将所有这些模块输出在命令行。 1$ npm prune npm shrinkwrapnpm shrinkwrap 的作用是锁定当前项目的依赖模块的版本。 1$ npm shrinkwrap 运行该命令后，会在当前项目的根目录下生成一个npm-shrinkwrap.json文件，内容是node_modules目录下所有已经安装的模块，以及它们的精确版本。 下次运行npm install命令时，npm发现当前目录下有npm-shrinkwrap.json文件，就会只安装里面提到的模块，且版本也会保持一致。 npm owner模块的维护者可以发布新版本。npm owner 命令用于管理模块的维护者。 12345678# 列出指定模块的维护者$ npm owner ls &lt;package name&gt;# 新增维护者$ npm owner add &lt;user&gt; &lt;package name&gt;# 删除维护者$ npm owner rm &lt;user&gt; &lt;package name&gt; npm deprecate如果想废弃某个版本的模块，可以使用npm deprecate命令。 1$ npm deprecate my-thing@"&lt; 0.2.3" "critical bug fixed in v0.2.3" 运行上面的命令以后，小于0.2.3版本的模块的package.json都会写入一行警告，用户安装这些版本时，这行警告就会在命令行显示。 npm addusernpm adduser用于在npmjs.com注册一个用户。 1234$ npm adduserUsername: YOUR_USER_NAMEPassword: YOUR_PASSWORDEmail: YOUR_EMAIL@domain.com npm login用于登陆npm。 1$ npm login npm publish登陆过后可以使用 npm publish 发布一个版本。 1$ npm publish 如果当前模块是一个beta版，比如1.3.1-beta.3，那么发布的时候需要使用tag参数，将其发布到指定标签，默认的发布标签是latest。 1$ npm publish --tag beta package.json文件每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 package.json 文件至少要有两部分内容： name 全部小写，没有空格，可以使用下划线或者横线。 version x.x.x 的格式，符合语义化版本规则。 例： 1234&#123; "name": "my-module", "version": "1.0.0"&#125; 其他内容： description：描述信息，有助于搜索 main: 入口文件，一般都是 index.js scripts：支持的脚本，默认是一个空的 test keywords：关键字，有助于在人们使用 npm search 搜索时发现你的项目 author：作者信息 license：默认是 MIT bugs：当前项目的一些错误信息，如果有的话 dependencies：项目生产过程中的依赖包 devDependencies：项目开发、测试过程中的依赖包 homepage: 该包的项目主页地址 例： 12345678910111213141516171819202122232425262728293031&#123; "name": "demo", "version": "1.0.0", "description": "a vue project", "main": "index.js", "scripts": &#123; "build": "node build/build.js", "dev": "webpack-dev-server build/webpack.dev.conf.js", "start": "npm run dev" &#125;, "keywords": [ "vue" ], "author": "hongwenqing", "license": "MIT", "dependencies": &#123; "vue": "^2.5.17", "vuex": "~3.0.1" &#125;, "devDependencies": &#123; "babel-core": "^6.14.0", "babel-loader": "^6.2.5", "babel-preset-es2015": "^6.18.0", "eslint": "^3.5.0", "vue-loader": "^10.0.2", "serve": "^1.4.0", "webpack": "^4.13.2", "webpack-dev-server":"^3.1.10" &#125;, "homepage": "https://www.github.com/yisibell/hello-npm-test.git"&#125; 语义化版本规则官方说明地址 dependencies 或 devDependencies 的内容，以 &quot;vue&quot;: &quot;^2.5.17&quot; 为例，我们知道 key 是依赖的包名称，value 是这个包的版本。那版本前面的^ 、~或者版本直接是一个 * 是什么意思呢？ 这就是 npm 的 Semantic versioning，简称 Semver，中文含义即语义化版本规则。这些特殊符号被称作 semver 通配符 。 在开发中我们有过这样的经验：有时候依赖的包升级后大改版，之前提供的接口不见了，这对使用者的项目可能造成极大的影响。 因此我们在声明对某个包的依赖时需要指明是否允许 update 到新版本，什么情况下允许更新，npm 包提供者需要了解的 Semantic versioning 语义化版本规则。版本由三部分组成：X，Y，Z，分别是主要版本，次要版本和补丁版本。 作为包的开发者，应该从 1.0.0 版本开始。以后要升级版本应该遵循以下标准： 补丁版本：解决了 Bug 或者一些较小的更改，增加最后一位数字，比如 1.0.1 小版本：增加了新特性，同时不会影响之前的版本，增加中间一位数字，比如 1.1.0 大版本：大改版，无法兼容之前的，增加第一位数字，比如 2.0.0 作为包的使用者，可以针对自己的需要填写依赖包的版本规则： 作为使用者，我们可以在 package.json 文件中写明我们可以接受这个包的更新程度（假设当前依赖的是 1.0.4 版本）： 如果不打算更新任何版本，也就是只使用固定版本的包，可以这么写： 1.0.4 如果只打算接受补丁版本的更新（也就是最后一位的改变），就可以这么写： 1.0 1.0.x ~1.0.4 如果接受小版本的更新（第二位的改变），就可以这么写： 1 1.x ^1.0.4 如果可以接受大版本的更新（自然接受小版本和补丁版本的改变），就可以这么写： * x package-lock.json文件背景在 package.json 中定义这样的依赖项的真正好处是，任何有权访问 package.json 的人都可以创建一个包含运行应用程序所需模块的依赖项文件夹，但是让我们来看看事情可能出错的具体方式。 假设我们创建了一个将使用 vue 的新项目。我们安装了 vue ： 1$ npm install vue --save 在安装时，vue 的最新版本是2.5.17，所以 “vue”：“^2.5.17” 作为我的package.json中的依赖项添加，并且我的电脑安装了确切的版本。 现在也许明天，vue 的维护者会发布 bug 修复或新特性的添加，发布后的最新版本变为2.6.0。 显然，根据版本号的变化，我们知道，这是新增了新的特性了，vue 的这个版本添加 v-slot 指令，用于逐步替换掉 2.5.x 版本的 slot-scope 特性，并且计划在 3.x版本完全去除 slot-scope 特性。 然后，如果有人想要为我的项目做贡献，他们会克隆它，然后运行npm install。因 2.6.0是具有相同主要版本的更高版本，所以为它们安装。 我们都安装 vue ，但我们却是不同的版本。 从理论上讲，它们应该仍然是兼容的，但也许 bugfix 会影响我们正在使用的功能，而且当使用vue版本2.5.17和2.6.0运行时，我们的应用程序可能会产生不同的结果。（虽然 vue 的这次版本更新兼顾到了 2.5.x 的版本，你依然可以使用 slot-scope 特性，但其他库可就不一定了）。 目的package-lock.json 的目的是避免上述情况，其中从同一 package.json 安装模块会导致两种不同的安装。 在 npm 版本 5.x.x 中添加了 package-lock.json，因此如果你使用的是主要版本 5 或更高版本，除非禁用它，否则它会自动生成。 内容结构package-lock.json 是package.json 中列出的每个依赖项的大型列表，应安装的特定版本，模块的位置（URI），验证模块完整性的哈希，它需要的包列表 ，以及依赖项列表。 让我们来看看 vue 的列表是什么： 12345"vue": &#123;"version": "2.5.17", "resolved": "https://registry.npmjs.org/vue/-/vue-2.5.17.tgz", "integrity": "sha512-mFbcWoDIJi0w0Za4emyLiW72Jae0yjANHbCVquMKijcavBGypqlF7zHRgMa5k4sesdv7hv2rB4JPdZfR+TPfhQ==" "requires": &#123;&#125;, npm(^5.x.x) 之后的做法，npm 使用package-lock.json，而不是使用package.json 来解析和安装模块。也就是说，当你使用 npm install 安装所有项目依赖时，npm 会根据 package-lock.json 文件中各模块包的 version 字段来安装特定版本的依赖包。 因为 package-lock.json 为每个模块及其每个依赖项指定了版本，位置和完整性哈希，所以它每次创建的安装都是相同的。 无论你使用什么设备，或者将来安装它都无关紧要，每次都应该给你相同的结果，这非常有用。 如果我们想要更新 vue 的版本怎么办呢？常规操作是： npm outdated vue 查看 vue 的最新变动。 12345$ npm outdated vue# 下方为打印结果Package Current Wanted Latest Locationvue 2.5.17 2.6.9 2.6.9 demo 可以看出，vue 的最新版本变为 2.6.9 了。于是我们可以使用 npm update 命令来更新 vue。 12345$ npm update vue# 结果+ vue@2.6.9updated 1 package in 1.8s 现在 package-lock.json 文件中 vue 的变化。 12345"vue": &#123; "version": "2.6.9", "resolved": "https://registry.npmjs.org/vue/-/vue-2.6.9.tgz", "integrity": "sha512-t1+tvH8hybPM86oNne3ZozCD02zj/VoZIiojOBPJLjwBn7hxYU5e1gBObFpq8ts1NEn1VhPf/hVXBDAJ3X5ljg==" &#125;, 没错！她现在已经被锁定为 2.6.9 的版本了。此时，你应该将你的 package-lock.json 和 package.json 变更提交到代码控制仓库，这时，当你的同事 pull 代码的时候，发现这两个文件发生了变化，那么他应该重新执行 npm install ，已确保他项目的 node_modules 中的所有依赖与其他开发人员一致。 能够触发 package-lock.json 文件变更的操作。 手动修改 package.json 中依赖包的版本号，然后执行 npm install （不推荐）。 使用 npm update [package name[@version]] 来更新包。（推荐）]]></content>
      <categories>
        <category>npm相关</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>package-lock.json</tag>
        <tag>package.json</tag>
        <tag>Semver(语义化版本规则)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h-slide-picker移动端滑动单选弹出层说明]]></title>
    <url>%2F2019%2F03%2F01%2Fvue%2Fh-ui%2Fh-slide-picker%2F</url>
    <content type="text"><![CDATA[h-slide-picker 文档说明。 效果 Properties 特性 类型 默认值 可选值 描述 visible Boolean false - 控制滑动弹出层的显示状态，支持 .sync 语法。 dataList Array of Object [] - 滑动选项数据，如果不自定义每个选择项 slot , 则数据元素 Object 中必须包含 label 字段用来显示每个选项的文本内容 title String &#39;&#39; - 滑动组件的标题内容 itemHeight Number 37 - 每个选择项的高度值，单位px count Number 5 - 滑动选择项的可见个数 Events 事件 描述 confirm 点击确定按钮时触发事件。参数：data(选中数据) , index(当前数据在数组中的索引值) cancel 点击取消触发事件 Slots 插槽名 描述 title 弹出层标题处 slot。可用来自定义标题处的内容 Scope-slots 插槽名 描述 default 默认作用域插槽。可用来自定义每个选择项的内容，可用参数：curr , index。你可以使用如下方式使用，&lt;template v-slot=&quot;{curr, index}&quot;&gt;&lt;/template&gt; 仓库项目仓库地址]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>picker</tag>
        <tag>components</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js版本控制器nvm的使用]]></title>
    <url>%2F2019%2F02%2F01%2Fnodejs%2Fhowtousenvm%2F</url>
    <content type="text"><![CDATA[介绍如何使用 node.js 的版本控制工具 nvm。可用于切换不同版本的 node.js。 安装进入安装包下载地址 nvm 安装包 github地址 ，下载后，直接解压安装即可。 注： 如果已经单独安装了 node ，请先行卸载该 node ，因为nvm 会将你 use 的 node 版本安装到你设置的path 路径中。 如何修改当前 node 的保存路径在 nvm 文件夹下的 settings.txt 文件中修改 path 字段即可。 12root: E:\nvmpath: E:\nodejs 环境变量设置注： 在 nvm-1.1.6 及以下版本，默认不会在安装时自动配置环境变量，所以如果没有正确设置 nvm 的环境变量，会导致如下错误。 1234567891011elenh@elenh MINGW64 ~/Desktop$ node -vbash: node: command not foundelenh@elenh MINGW64 ~/Desktop$ npm -vbash: npm: command not foundelenh@elenh MINGW64 ~/Desktop$ nvm -vbash: nvm: command not found 新版的 nvm-1.1.7不存在这个问题，她会在安装时自动为你设置好环境变量。所以如果你使用的是 nvm-1.1.7 及以上版本，那么下面的环境变量设置流程你可以忽略不看。 window 10下设置流程： 找到控制面板 点击进入系统和安全 点击进入 系统 点击左侧高级系统设置 点击弹窗中的 环境变量 在 系统变量 模块 新建一个系统变量 NVM_HOME 并将值设置为 你安装的 nvm 所在目录。 再在系统变量 模块新建一个系统变量 NVM_SYMLINK 并将值设置为 node 所在目录。 最后将 %NVM_HOME% 和 %NVM_SYMLINK% 添加进 path 变量中保存确定即可。 到此便配置完成，现在你可以在任意地方打开 cmd.exe、powershell.exe 或 git.exe 。 12345678910111213141516171819202122232425# 查看 nvm 版本nvm -vRunning version 1.1.6.Usage: nvm arch : Show if node is running in 32 or 64 bit mode. nvm install &lt;version&gt; [arch] : The version can be a node.js version or "latest" for the latest stable version. Optionally specify whether to install the 32 or 64 bit version (defaults to system arch). Set [arch] to "all" to install 32 AND 64 bit versions. Add --insecure to the end of this command to bypass SSL validation of the remote download server. nvm list [available] : List the node.js installations. Type "available" at the end to see what can be installed. Aliased as ls. nvm on : Enable node.js version management. nvm off : Disable node.js version management. nvm proxy [url] : Set a proxy to use for downloads. Leave [url] blank to see the current proxy. Set [url] to "none" to remove the proxy. nvm node_mirror [url] : Set the node mirror. Defaults to https://nodejs.org/dist/. Leave [url] blank to use default url. nvm npm_mirror [url] : Set the npm mirror. Defaults to https://github.com/npm/npm/archive/. Leave [url] blank to default url. nvm uninstall &lt;version&gt; : The version must be a specific version. nvm use [version] [arch] : Switch to use the specified version. Optionally specify 32/64bit architecture. nvm use &lt;arch&gt; will continue using the selected version, but switch to 32/64 bit mode. nvm root [path] : Set the directory where nvm should store different versions of node.js. If &lt;path&gt; is not set, the current root will be displayed. nvm version : Displays the current running version of nvm for Windows. Aliased as v. 如上所示，打印出了正确的 nvm 版本，就表示 nvm 已经安装成功了，接下来使用 nvm 的安装命令来安装你需要的 node 版本。 下载源配置由于 nvm 默认的下载地址 http://nodejs.org/dist/ 是外国外服务器，网速不快的时候，经常会导致 npm 下载失败，所以可以设置 node 和 npm 的下载源地址为淘宝镜像，速度还是很可观的。 12345# 设置 nodejs 的下载源地址nvm node_mirror https://npm.taobao.org/mirrors/node/# 设置 npm 的下载源地址nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 你也可以通过直接修改 nvm 安装包里的 settings.txt 文件： 12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ 简单使用1nvm install 10.19.0 安装完成后，使用 nvm ls 命令，可以查看你已经安装了哪些版本的 node。 然后再使用 nvm on 命令启用 nvm。 接着再使用 nvm use 10.19.0 命令，切换到 node v10.19.0。 为了检验是否切换成功了，可以使用下面的方式进行检查。 1234567elenh@elenh MINGW64 ~/Desktop$ node -vv10.16.3elenh@elenh MINGW64 ~/Desktop$ npm -v6.9.0 打印出了正确的 node 和 npm 版本，就表示切换成功了。 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 查看nvm是否安装成功，安装成功则会显示当前版本号和一些命令说明nvm -v# 查看nvm的当前版本nvm version# 安装最新版nodenvm install# 安装某个版本的node# 例：nvm install v10.15.2 64 安装64位的，版本为 10.15.2 的nodenvm install &lt;version&gt; [arch]# 卸载某个版本nvm uninstall &lt;version&gt;# 开启 nvmnvm on# 禁用 nvmnvm off# 查看已被管理的版本nvm ls# 查看可安装的 nodejs 版本nvm list available# 切换node版本nvm use &lt;version&gt; [arch]# 显示当前版本nvm current# 给不同的版本号添加别名nvm alias &lt;name&gt; &lt;version&gt;# 删除已定义的别名nvm unalias &lt;name&gt;# 查看设置与代理nvm proxy # 设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/nvm node_mirror [url] # 设置或者查看setting.txt中的npm_mirror，如果不设置的话默认的是 https://github.com/npm/npm/archive/.nvm npm_mirror [url] # 设置和查看root路径（nvm的安装路径）nvm root [path] # 在当前版本node环境下，重新全局安装指定版本号的npm包nvm reinstall-packages &lt;version&gt;]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h-picker移动端滑动单选组件说明]]></title>
    <url>%2F2019%2F01%2F01%2Fvue%2Fh-ui%2Fh-picker%2F</url>
    <content type="text"><![CDATA[介绍个人实现的 移动端滑动选择效果 组件 h-picker 的使用。 Usage以基于 vue-cli 构建的单文件系统为示例说明。 123456789101112131415161718192021// in main.jsimport Vue from 'vue'import App from './App.vue'// 假定你已经将核心文件拷贝到你的 components 文件夹下（到仓库中拷贝即可）// 为什么还来个假定这么骚的操作？ 因为在下不想发 npm 包 ，占用包名， 这类滑动选择组件各大 ui 库都包含// 本例作为学习参考import HPicker from '@/components/HPicker' //导入Vue.use(HPicker) //安装new Vue(&#123; el: "#app", render(h)&#123; return h(App) &#125; &#125;) in App.vue 12345678910&lt;template&gt;&lt;div&gt; &lt;h-picker :data="list" @change="handleChange"&gt;&lt;/h-picker&gt;&lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536export default &#123; name: 'App', data()&#123; return &#123; list: [ &#123;label: "测试文字项1"&#125;, &#123;label: "测试文字项2"&#125;, &#123;label: "测试文字项3"&#125;, &#123;label: "测试文字项4"&#125;, &#123;label: "测试文字项5"&#125;, &#123;label: "测试文字项6"&#125;, &#123;label: "测试文字项7"&#125;, &#123;label: "测试文字项8"&#125;, &#123;label: "测试文字项9"&#125;, &#123;label: "测试文字项10"&#125;, &#123;label: "测试文字项11"&#125;, &#123;label: "测试文字项12"&#125;, &#123;label: "测试文字项13"&#125;, &#123;label: "测试文字项14"&#125;, &#123;label: "测试文字项15"&#125;, &#123;label: "测试文字项16"&#125;, &#123;label: "测试文字项17"&#125;, &#123;label: "测试文字项18"&#125;, &#123;label: "测试文字项19"&#125;, &#123;label: "测试文字项20"&#125;, ] &#125; &#125;, methods: &#123; //选择项变化时触发句柄 handleChange( data , index)&#123; console.log( data , index); &#125; &#125;&#125; Properties 特性 类型 默认值 可选值 说明 data Array of Object [] - 选项数据，当没有使用作用域插槽自定义每一项的模板内容时，每项的 label 字段是必须的 item-height Number 37 - 每个选择项的高度值，单位为 px count Number 5 大于1的整数值 选择器可见选项的个数 Eventschange 当选项被滑动选择时触发，每次手指离开都会触发。 123456789// ***** 省略其他选项methods: &#123; //选择项变化时触发句柄 handleChange( data , index)&#123; console.log( `当前选中项的数据$&#123;data&#125;` , `当前选中项的索引值$&#123;index&#125;`); &#125;&#125;// ***** 省略其他选项 Slotsdefault h-picker 组件中设置了一个默认的作用域插槽，使得你可以对每个选择项的内容进行自定义。 基于 vue 2.5.x 的使用方式 1234&lt;h-picker :data="list"&gt; &lt;div slot-scope="&#123; data , index &#125;"&gt;&#123;&#123; `自定义选项内容$&#123;index&#125;` &#125;&#125;&lt;/div&gt;&lt;/h-picker&gt; 基于 vue 2.6.x 的使用方式 1234567&lt;h-picker :data="list"&gt; &lt;template v-slot:default="&#123; data , index &#125;"&gt;&#123;&#123; `自定义选项内容$&#123;index&#125;` &#125;&#125;&lt;/template&gt; &lt;!-- or --&gt; &lt;template #default="&#123; data , index &#125;"&gt;&#123;&#123; `自定义选项内容$&#123;index&#125;` &#125;&#125;&lt;/template&gt;&lt;/h-picker&gt; 仓库地址仓库地址传送]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>picker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-magnifying-glass放大镜组件说明]]></title>
    <url>%2F2018%2F12%2F28%2Fvue%2Fh-ui%2Fvue-magnifying-glass%2F</url>
    <content type="text"><![CDATA[vue-magnifying-glass放大镜组件使用文档 Usagemain.js 1234567import Vue from 'Vue'//自行拷贝核心文件夹到本地，此组件不发 npm 包，任性。import hMagnifyingGlass from '@/components/magnifyingGlass' Vue.use( hMagnifyingGlass ) demo.vue 1234&lt;h-magnifying-glass small-url="http://localhost:8080/assets/01.jpg" big-url="http://localhost:8080/assets/02.jpg"&gt;&lt;/h-magnifying-glass&gt; Properties 特性 类型 默认值 可选值 说明 small-url String 小图片地址 big-url String 大图片地址 small-size Number 350 小图片大小 big-size Number 800 大图片大小 mask-color String rgba(255, 255, 0, 0.4) 移动遮罩颜色 gap Number 10 小图于大图之间间隔 仓库地址仓库地址]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归组件实现树结构]]></title>
    <url>%2F2018%2F11%2F10%2Fvue%2Fcomponents%2FrecursionTreeWithVuejs%2F</url>
    <content type="text"><![CDATA[本文介绍如何实现一个基于 vue 的递归组件的树结构! 功能 根据树形数据渲染出树形结构 点击某个节点能够收缩其子节点 等其他功能… 实现思路组件在其内部是可以调用其组件自身的，使用递归的思想循环调用树列表组件自身，就可以循环往复的渲染出所有树节点，但是必须确定跳出递归的条件，避免循环引用导致无限循环而出现如下错误。 1Uncaught RangeError: Maximum call stack size exceeded 根据树形数据结构，我们可以将跳出循环的条件设置为 是否存在子节点数据 ，如果有子节点数据，那继续循环，否则，跳出循环，只渲染当前节点。 代码测试代码环境为 vue-cli-3，组件使用单文件组件。 treeList.vue 组件该组件为渲染树本身 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;ul&gt; &lt;li v-for="(child,index) in data" :key="index"&gt; &lt;treeLabel v-if="child.children" :folder="child"&gt;&lt;/treeLabel&gt; &lt;span v-else&gt;&#123;&#123;child.label&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import treeLabel from './treeLabel.vue'export default &#123; name: "treeList", components: &#123; treeLabel &#125;, props: ['data']&#125;&lt;/script&gt;&lt;style scoped&gt; ul &#123; list-style: none;&#125; p &#123; margin: 0&#125;&lt;/style&gt; treeLabel.vue 组件该组件功能为，渲染当前节点标题，及其子组件数据。 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;p&gt; &lt;span @click="toggle"&gt;&#123;&#123;folder.label&#125;&#125;&lt;/span&gt; &lt;treeList v-show="isshow" :data="folder.children"&gt;&lt;/treeList&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;// 异步导入 treeList 组件，告诉模块系统 -&gt; 我们不需要先解析 treeList 组件，等到用到的时候再解析加载const treeList = () =&gt; import('./treeList.vue')export default &#123; name: "treeLabel", data()&#123; return &#123; isshow: false &#125; &#125;, props: ['folder'], components: &#123; treeList &#125;, methods: &#123; toggle()&#123; this.isshow = !this.isshow; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; span &#123; cursor: pointer;&#125;&lt;/style&gt; 注： 如果你使用了模块化构建系统，像包含了 webpack 或 Browserify 的 @vue/cli，你会遇到像下面这样的错误： 1Failed to mount component: template or render function not defined. 为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。 为了解决这个问题，我们需要给模块系统一个点，在那里 A 反正是需要 B 的，但是我们不需要先解析 B。 所以，对于上面我们定义的两个组件，我们可以把 treeLabel 组件作为那个点，而为了告诉 模块系统 我们不需要先解析 treeList 组件，而是等到用到的时候再加载解析她。那么，我们可以这样做： 1const treeList = () =&gt; import('./treeList.vue') 没错！在 webpack 这样的模块系统中，我们可以使用异步的 import() 来注册异步组件，这样只有在 treeList 组件被用到的时候才会被模块系统解析。 对于以上问题，只是会出现在 局部注册组件 时出现，如果你是以 全局注册组件 的显示定义有循环引用的两个组件时就不会出现这样的情况了。 123456Vue.component('treeLabel', &#123; // ...&#125;)Vue.component('treeList', &#123; // ...&#125;) 使用App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div id="app"&gt; &lt;treeList :data="list" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import treeList from './components/treeList.vue'export default &#123; name: "app", components: &#123; treeList &#125;, data()&#123; return &#123; list: [ &#123; label: "一级菜单1", children: [ &#123; label: "二级菜单1", children: [ &#123; label: "三级菜单1" &#125; ] &#125;, &#123; label: "二级菜单2" &#125; ] &#125;, &#123; label: "一级菜单2" &#125;, &#123; label: "一级菜单3", children: [ &#123; label: "二级菜单1" &#125; ] &#125; ] &#125; &#125;&#125;;&lt;/script&gt; 至此就实现了最基本的树结构功能。 仓库地址仓库地址]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>recursionTree</tag>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket教程]]></title>
    <url>%2F2018%2F10%2F20%2Fjavascript%2Fwebsocket%2Fhowtousewebsocket%2F</url>
    <content type="text"><![CDATA[WebSocket 是一种网络通信协议，本文记录关于它的语法说明。 为什么需要 WebSocket？初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 客户端的APIWebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 实例属性ws.readyStatereadyState 属性返回实例对象的当前状态，共有四种: 1234CONNECTING：值为0，表示正在连接。OPEN：值为1，表示连接成功，可以通信了。CLOSING：值为2，表示连接正在关闭。CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 下面是一个实例：1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; 相关事件ws.onopen实例对象的onopen属性，用于指定连接成功后的回调函数。 123ws.onopen = function (e) &#123; ws.send('Hello Server!');&#125; ws.onmessage实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 1234ws.addEventListener("message", function(event) &#123; var data = event.data; // 处理数据&#125;); ws.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。 123456ws.addEventListener("close", function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); ws.onerror实例对象的onerror属性，用于指定报错时的回调函数。 123ws.onerror = function(err)&#123; console.log( err )&#125; 实例方法ws.send()实例对象的send()方法用于向服务器发送数据。 发送文本的例子。 1ws.send('your message'); 发送 Blob 对象的例子。 1234var file = document .querySelector('input[type="file"]') .files[0];ws.send(file); 发送 ArrayBuffer 对象的例子。 1234567// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); ws.close()该方法用于关闭连接。 服务端的实现常用的 node 实现有如下几种： ws Socket.IO µWebSockets WebSocket-Node 具体用法查看其官网文档即可 聊天案例这里有一个 使用 node 实现的简易聊天案例，客户端使用的是原生 api，服务端则使用的是 ws 模块。 案例传送门]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS Flex弹性布局]]></title>
    <url>%2F2018%2F10%2F01%2Fcss%2Fcss3-flex%2F</url>
    <content type="text"><![CDATA[flex弹性布局简介(flexible box)。 基本概念采用flex布局的元素叫做 “容器” ，该元素(容器)内的所有子元素叫做 “项目”。沿着flex元素放置方向延伸的轴（比如页面上横向的行，纵向的列）被称为 “主轴” ，该轴的开始和结束分别称为 main start 和 main end。相反的，垂直于flex元素放置方向上的轴被称为 “交叉轴” 或 “横轴”，该轴的开始和结束分别称为 cross start 和 cross end。 所有标签中的文本节点也可以当做项目来进行 flex 布局，即标签作为容器，文本作为项目。 兼容性 Chrome Firefox Opera Safari IE 21+ 22+ 12.1+ 6.1+ 10+ 使用方式给要应用 flex 布局的元素设置 display:flex 或 display:inline-flex 属性。由于兼容性问题，webkit内核的浏览器需加上 -webkit- 前缀。 1234.box &#123; display: -webkit-flex; display: flex;&#125; 容器属性容器属性有6个可以设置。分别是： 1234561. flex-direction2. flex-wrap3. flex-flow4. justify-content5. align-items6. align-content flex-direction属性规定主轴的方向，即设置项目在容器里的排列方向。 可选值 描述 row (默认)，主轴方向 水平从左向右，即项目依次从左向右排列 row-reverse 主轴方向 水平从左向右，即项目依次从右向左排列 column 主轴方向 垂直从上到下，即项目依次从上到下排列 column-reverse 主轴方向 垂直从下到上，即项目从下往上排列 flex-wrap属性规定当项目在主轴方向上无法放下时，是否换行。 可选值 描述 no-wrap (默认)，不换行 wrap 换行，依次从上到下排列(主轴水平) wrap-reverse 换行，第一行在下方，即从下到上换行 flex-flow属性flex-direction 和 flex-wrap 的简写属性。 可选值 描述 row no-wrap (默认)，主轴从左到右，不换行。第一个值为 flex-direction 属性值第二个值为 flex-wrap 属性值 justify-content属性规定项目在主轴方向上的对齐方式。 可选值 描述 flex-start (默认)，项目向主轴的开始处(main start)对齐 flex-end 项目向主轴的结束处(main end)对齐 center 项目在主轴方向上居中对齐 space-between 项目在主轴方向上均匀分布排列，即项目之间留出空间，但项目与容器边缘不留空间 space-around 项目在主轴方向均匀分布，不但项目与项目之间有间隙，项目与容器边缘也会有间隙 align-items属性规定项目在交叉轴上的对齐方式。 可选值 描述 stretch (默认)，项目不设置高度或为 auto 时，将占满整个容器的高度 flex-start 向交叉轴的起点对齐 flex-end 向交叉轴的终点对齐 center 项目在交叉轴上居中对齐 baseline 向项目的第一行文字的基线对齐 align-content属性规定多根轴线的对齐方式，如果项目只有一个轴线，该属性不起作用。即有多个主轴时，控制主轴在交叉轴上的对齐方式，把一条轴线上的项目作为一个整体进行对齐。 可选值 描述 stretch (默认)，在交叉轴上伸张，拉伸，即占满整个交叉轴 flex-start 与交叉轴的起点对齐 flex-end 与交叉轴的终点对齐 center 在交叉轴上居中对齐 space-between 与交叉轴两端对齐，轴线之间均匀分布 space-around 每根轴线的两侧都相等 项目属性项目属性有6个可以设置，分别为： 1234561. order2. flex-grow3. flex-shrink4. flex-basis5. flex6. align-self order属性规定项目的排列顺序。 整数值，默认为 0 ，数值越小越靠前排列。 123.item &#123; order : 1;&#125; flex-grow属性规定项目的放大比例。 项目在容器中的占据位置比例值。整数值，默认为0，即容器存在多余的空间也不放大。当值大于0时，就按相应的倍数放大。 比如，主轴上有两个项目，分别设置两个项目 flex-grow: 1 。则表示两个项目各占据主轴空间 1/2。123456.left &#123; flex-grow: 1;&#125;.right &#123; flex-grow: 1;&#125; 又比如，主轴上有两个项目，分别设置 flex-grow 如下，则表示 .left 项目占据主轴的全部剩余空间。123456.left &#123; flex-grow: 1; &#125;.right &#123; flex-grow: 0; /* 0 是默认值*/&#125; flex-shrink属性规定项目的缩小比例。 整数值，默认为 1 ，即当容器变小时，项目会按比例缩小。该值不可取负值。 123.item &#123; flex-shrink: 1;&#125; flex-basis属性规定分配多余空间之前，设置项目占据的固定主轴空间(项目的固定宽度)。 可选值是 width 和 height 能设置的值。 123.item &#123; flex-basis: 100px;&#125; flex属性flex-grow , flex-shrink 和 flex-basis 的简写属性。 默认值：0 1 auto该属性有两个快捷值：auto (1 1 auto) , none (0 0 auto)例：12345/* 放大，缩小*/flex: auto;/*不放大，不缩小*/flex: none; align-self属性控制具体的单个项目在交叉轴上的对齐方式。 可选值 描述 stretch (默认)，项目不设置高度或为 auto 时，将占满整个容器的高度 flex-start 向交叉轴的起点对齐 flex-end 向交叉轴的终点对齐 center 在交叉轴上居中对齐 baseline 与项目的第一行文字的基线对齐]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>flex</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-accordions手风琴说明]]></title>
    <url>%2F2018%2F09%2F10%2Fvue%2Fh-ui%2Fvue-accordions%2F</url>
    <content type="text"><![CDATA[基于 vue 的手风琴组件。 vue-accordionsA accordion component for vue.js InstallationUsing npm 123npm install vue-accordions --save# orcnpm install vue-accordions --save UsageIn main.js 123456import Vue from 'vue'import accordion from 'vue-accordions'Vue.use(accordion)// new Vue(&#123; // ... &#125;) 1&lt;accordion :data="imgList" @jump="jumpTo"/&gt; 1234567891011export default &#123; data()&#123; return &#123; imgList: [ &#123;title: '' , src: ''&#125;, &#123;title: '' , src: ''&#125;, //... ] &#125; &#125;&#125; Properties 属性 类型 说明 可选值 是否必需 w Number 容器宽度 1200 (默认) 否 h Number 容器高度 266 (默认) 否 gap Number 折叠间隔 100 (默认) 否 data Array of object 展示的图片数据 实例默认使用的是演示数据 , 设置 data 属性以覆盖 是 注： 在 data 属性中 （对象数组类型） ， 你必须为每个对象提供 src 属性 ，作为每张图片的地址。其他有用的数据，你可以视你所需去添加。 Events@jump： 点击某张展示图片时触发句柄。 html模板 1&lt;accordion @jump="jumpTo"/&gt; js代码 1234567891011export default &#123; data()&#123; return &#123;&#125; &#125;, methods: &#123; jumpTo(info)&#123; // `info` is the data of curr img which you setted the `data` prop , you can use this // do somethig when you click foo img &#125; &#125;&#125; Logs 2018/9/5：init package。]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安利一下自己写的vue插件]]></title>
    <url>%2F2018%2F09%2F10%2Fvue%2Fh-ui%2Fh-ui-list%2F</url>
    <content type="text"><![CDATA[分享一下自己写的几款基于 vue 的组件，都是一些很常用的功能组件，使用起来都很简单。分别有：vue-paginators 分页条vue-slideshows 轮播图vue-whirligig 旋转木马轮播vue-accordions 手风琴效果vue-laydal 整合 layer 和 modal 的弹出层插件 站内搜索即可查看文档说明。]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-laydal弹出层说明]]></title>
    <url>%2F2018%2F09%2F10%2Fvue%2Fh-ui%2Fvue-laydal%2F</url>
    <content type="text"><![CDATA[基于 vue , layer 的弹出层插件。 vue-laydal A popup component for vue.js Introducevue-laydal，其实就是 layer(layui中的弹出层库) 和 modal（bootstrap模态框）的结合体。做这个包的初衷就是因为 layer 并没有 es6 和 CommonJS 模块化的 版本 ，并且 layer 中没有模态框这一功能。于是就有了 vue-laydal,解决日常开发需求。 你可以在安装完 vue-laydal 后 使用 layer 的所有接口api ，其功能完全和 layer 官方文档一样。所以要想知道 layer 的用法，看其官方文档即可。layer官网 另外，我在 vue-laydal 中加入了 modal 组件，其就是 bootstrap 中的 模态框原型，样式完全和 bootstrap-3.x.x 版本一模一样。同时你可以在 modal 组件中使用 bootstrap-3.x.x 的 所有样式。bootstrap3官网 vue-laydal 内置了 jQuery ，版本为 1.12.x ，所以如果你想使用她 ， 你可以 import {$} from &#39;vue-laydal&#39; 来使用。 独立于 layer 且 样式丰富的 loading 服务功能。 InstallationUsing npm1$ npm install vue-laydal --save Usage1.全局安装 全局安装会给所有子组件 添加 layer 函数 ， 即 你可以使用 this.$layer 访问 layer 的所有方法。全局安装同时会给所有子组件注册 &lt;modal /&gt; 组件，你可以在任何组件模板中使用它。 1234567// mian.jsimport Vue from 'vue'import laydal from 'vue-laydal'Vue.use(laydal)// new Vue(&#123; //...&#125;) 2.局部安装 使用解构的方式，在你需要的时候引入。引入 modal 组件时，需要局部注册下。 1234567891011import &#123; layer , modal &#125; from 'vue-laydal'export default &#123; name: "demo", components:&#123; modal &#125;, data()&#123; return &#123;&#125; &#125;, methods: &#123; layer.msg('hello laydal') &#125;&#125; Loading 服务的使用该功能是独立于 layer 的，加载的动画效果相对较好，目前有3种动画效果可选。 使用方式 1234567import &#123; Loading &#125; from 'vue-laydal'var loadingInstance = new Loading()loadingInstance.open(); //开启 loading// 随后使用 `loadingInstance.close()` 关闭 loading 即可 配置你可以向构造函数存入选项配置1var loadingInstance = new Loading(&#123; theme : "wave" , bgcolor: "red"&#125;) 选项 类型 默认值 可选值 描述 theme String three-bounce fading-circle , wave 动画类型 bgcolor String #27A2FF(淡蓝) 合法的 css 颜色值 设置loading 的颜色 &lt;modal /&gt;组件的相关说明 模态框弹出层组件，样式同 bootstrap 。 Slots 名称 说明 title 模态框头部 slot body 模态框主体内容 slot Properties 属性 类型 说明 可选值 默认值 是否必需 v-modal Boolean 控制模态框的显示隐藏 - - 是 width String 模态框的宽度 - 580px 否 height String 模态框的高度 - auto 否 closeText String 关闭按钮的文本 - 关闭 否 saveText String 保存按钮的文本 - 保存 否 hideclosebtn Boolean 是否隐藏关闭按钮 - false 否 hidesavebtn Boolean 是否隐藏保存按钮 - false 否 clickmaskclose Boolean 是否使用点击弹窗遮罩层关闭模态框 - true 否 Events@confirm 点击确定按钮触发事件句柄 12&lt;modal v-model="show" @confirm="yes"&gt;&lt;/modal&gt;&lt;button @click="show = true"&gt;click&lt;/button&gt; 1234567891011121314export default &#123; data()&#123; return &#123; show: false &#125; &#125;, methods: &#123; yes()&#123; // do something you need before hide the modal this.show = false; &#125; &#125;&#125; @shown 模态框显示时触发事件 12&lt;modal v-modal="show" @shown="whenshow" /&gt;&lt;button @click="show = true"&gt;show modal&lt;/button&gt; 123456789101112export default &#123; data()&#123; return &#123; show: false // 默认隐藏 &#125; &#125;, methods: &#123; whenshow()&#123; // do some thing when the modal shown ... &#125; &#125;&#125; @hidden 模态框隐藏时触发事件 12&lt;modal v-modal="show" @hidden="whenhide"/&gt;&lt;button @click="show = true"&gt;show modal&lt;/button&gt; 123456789101112export default &#123; data()&#123; return &#123; show: false // 默认隐藏 &#125; &#125;, methods: &#123; whenhide()&#123; // do some thing when the modal hidden ... &#125; &#125;&#125; Logs 2018-10-1 新增 loading 服务功能。 结束语写这些插件的初衷是为了简化日常开发需求，也希望可以帮助到有相关需求的同学（虽然很多UI组件库都有这些功能,但是有的时候也不是都需要对吗?）。]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-whirligig旋转木马说明]]></title>
    <url>%2F2018%2F09%2F03%2Fvue%2Fh-ui%2Fvue-whirligig%2F</url>
    <content type="text"><![CDATA[基于 vue 的旋转木马组件。 vue-whirligigA whirligig component for vue.js InstallationUsing npm 123npm install vue-whirligig --save# or cnpm install vue-whirligig --save UsageIn main.js123456import Vue from 'vue'import whirligig from 'vue-whirligig'Vue.use(whirligig)// new Vue(&#123; //...&#125;) In_.vue12&lt;whirligig :containerWidth="800" :containerHeight="300" :currWidth="400" :currHeight="280" :data="imgList" @jump="jumpTo" /&gt; 12345678910111213141516export default &#123; data()&#123; return &#123; imgList: [ &#123;src: ""&#125; // ... ] &#125; &#125;, methods: &#123; jumpTo(info)&#123; // `info` is the data which you setted before // so something when you click current main img &#125; &#125;&#125; Properties 属性 类型 说明 可选值 默认值 是否必需 containerWidth Number 容器宽度 - 800 否 containerHeight Number 容器高度 - 300 否 currWidth Number 中间主图宽度 - 400 否 currHeight Number 中间主图高度 - 280 否 scale Number 两侧卡片缩放比例 - 0.8 否 autoplay Boolean 是否自动播放 false true 否 interval Number 自动播放间隔毫秒数 - 3000 否 data Array of object 展示数据 - 本地演示数据 是 注： data props 为对象数组类型， 且每个对象中必须包含 src (图片地址) 属性。 Events@jump 点击主图时触发句柄1234567891011export default &#123; data()&#123; return &#123;&#125; &#125;, methods: &#123; jumpTo(info)&#123; // `info` is the data which you setted before // so something when you click current main img &#125; &#125;&#125; Logs 2018/9/6 init]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-slideshows轮播图说明]]></title>
    <url>%2F2018%2F09%2F02%2Fvue%2Fh-ui%2Fvue-slideshows%2F</url>
    <content type="text"><![CDATA[基于 vue 的轮播图组件。 vue-slideshowsa slideshow component for vue.js InstallationUsing npm123npm install vue-slideshows --save#orcnpm install vue-slideshows --save UsageIn main.js123456import Vue from 'vue'import slideShows from 'vue-slideshows'Vue.use(slideShows)// new Vue(&#123; //... &#125;) In_.vue 1&lt;slideshow :data="imgList" @jump="jumpTo" /&gt; 1234567891011121314151617181920export default &#123; name: "demo", data()&#123; return &#123; imgList: [ // the object must have `src` property // `title` : img 's title // `src` : img 's src &#123;title: "defalut" , src: "./images/1.jpg"&#125;, &#123;title: "defalut2" , src: "./images/2.jpg"&#125;, // ... ] &#125; &#125;, methods: &#123; jumpTo()&#123; // do somethig when you click the img ... &#125; &#125;&#125; Properties 属性 类型 说明 可选值 是否必需 w String 轮播图宽度 100% (默认) 否 h String 轮播图高度 340px ( 默认) 否 data Array of object 轮播数据 默认展示的本地测试图片 使用 :data 覆盖即可 是 autoplay Boolean 是否开启自动循环轮播 true (默认) 否 interval Number 自动轮播间隔毫秒数 2000 (默认) 否 注意: :data prop 必须是对象数组类型，且该对象中必须包含 src 字段 （图片地址） Events@jump 点击某张图片时触发句柄 1&lt;slideshow @jump="jumpTo" /&gt; 123456789101112export default &#123; name: "demo", data()&#123; return &#123;&#125; &#125;, methods: &#123; jumpTo(info)&#123; // `info` is the data of current img // do somethig when you click the img ... &#125; &#125;&#125; Logs 2018/9/4]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-paginators分页条说明]]></title>
    <url>%2F2018%2F09%2F01%2Fvue%2Fh-ui%2Fvue-paginators%2F</url>
    <content type="text"><![CDATA[基于 vue 的分页条组件，简单易用。 vue-paginators a pagination component for vue.js InstallationUsing npm123npm install vue-paginators --save # orcnpm install vue-paginators --save Usage1234// In main.jsimport Vue from 'vue'import vuePaginators from "vue-paginators"Vue.use(vuePaginators) 1&lt;pagination :totalPages="total" @jump="jumpTo"&gt;&lt;/pagination&gt; 123456789101112export default &#123; data()&#123; return &#123; total: 14 // get this from ajax data &#125; &#125;, methods: &#123; jumpTo(curr)&#123; // do something when you click the pagination bar ... &#125; &#125;&#125; Properties 属性 类型 可选值 是否必需 showItem Number 5 (默认) 否 totalPages Number 无 (默认) 是 first String 首页 (默认) 否 prev String 上一页 (默认) 否 next String 下一页 (默认) 否 last String 末页 (默认) 否 pageStyle String default (默认) boot (bootstrap风格) 否 skin String(任意css颜色值) #0E90D2 (默认) 否 Events@jump 点击分页时触发句柄 1&lt;pagination :totalPages="total" :showItem="5" @jump="jumpTo"&gt;&lt;/pagination&gt; 123456789101112export default &#123; data()&#123; return &#123; total: 14 &#125; &#125;, methods : &#123; jumpTo(curr)&#123; // do something when you click the pagination bar ... &#125; &#125;&#125; Logs 2018/9/2 新增 pageStyle 属性， 可选为 boot 即bootstrap风格分页条 新增 skin 属性，可自行设置分页条的颜色。默认为 #0E90D2]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决js浮点数计算精度丢失问题]]></title>
    <url>%2F2018%2F05%2F22%2Fjavascript%2Finstance%2FcalcInJavascript%2F</url>
    <content type="text"><![CDATA[解决前端浮点数之间运算精度丢失问题。 实现11234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 加Number.prototype['add'] = function (...arg) &#123; var r1, r2, m, result = this; arg.forEach(value =&gt; &#123; try &#123; r1 = result.toString().split(".")[1].length &#125; catch (e) &#123; r1 = 0 &#125; try &#123; r2 = value.toString().split(".")[1].length &#125; catch (e) &#123; r2 = 0 &#125; m = Math.pow(10, Math.max(r1, r2)); result = Math.round(result * m + value * m) / m; &#125;); return result;&#125;;// 减Number.prototype['sub'] = function (...arg) &#123; var r1, r2, m, result = this; arg.forEach(value =&gt; &#123; try &#123; r1 = result.toString().split(".")[1].length &#125; catch (e) &#123; r1 = 0 &#125; try &#123; r2 = value.toString().split(".")[1].length &#125; catch (e) &#123; r2 = 0 &#125; m = Math.pow(10, Math.max(r1, r2)); var n = (r1 &gt;= r2) ? r1 : r2; result = (Math.round(result * m - value * m) / m).toFixed(n); &#125;); return result;&#125;;// 乘Number.prototype['mul'] = function (...arg) &#123; var result = this; arg.forEach(value =&gt; &#123; var m = 0, s1 = result.toString(), s2 = value.toString(); try &#123; m += s1.split(".")[1].length &#125; catch (e) &#123; &#125; try &#123; m += s2.split(".")[1].length &#125; catch (e) &#123; &#125; result = Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m); &#125;); return result;&#125;;// 除Number.prototype['div'] = function (...arg) &#123; var result = this; arg.forEach(value =&gt; &#123; var t1 = 0, t2 = 0, r1, r2; try &#123; t1 = result.toString().split(".")[1].length &#125; catch (e) &#123; &#125; try &#123; t2 = value.toString().split(".")[1].length &#125; catch (e) &#123; &#125; r1 = Number(result.toString().replace(".", "")); r2 = Number(value.toString().replace(".", "")); result = (r1 / r2) * Math.pow(10, t2 - t1); &#125;); return result;&#125;; 使用方式12345678// 0.1 + 0.2console.log(0.1.add(0.2)); // 0.3 // 同时支持传入多个参与计算的数var a = 5;// a * 2 * 3console.log(a.mul(2, 3)); // 30 实现21234567891011121314151617181920212223242526272829303132333435363738394041424344const calc = &#123; //加法 add : function (arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(".")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(".")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)); return (arg1*m+arg2*m)/m; &#125;, //减法 sub : function (arg1,arg2)&#123; var r1,r2,m,n; try&#123;r1=arg1.toString().split(".")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(".")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)); n=(r1&gt;=r2)?r1:r2; return ((arg1*m-arg2*m)/m).toFixed(n); &#125;, //乘法 mul : function (arg1,arg2) &#123; var m=0,s1=arg1.toString(),s2=arg2.toString(); try&#123;m+=s1.split(".")[1].length&#125;catch(e)&#123;&#125; try&#123;m+=s2.split(".")[1].length&#125;catch(e)&#123;&#125; return Number( s1.replace(".","") ) * Number( s2.replace(".","") ) / Math.pow(10,m); &#125;, //除法 div : function (arg1,arg2)&#123; var t1=0,t2=0,r1,r2; try&#123;t1=arg1.toString().split(".")[1].length&#125;catch(e)&#123;&#125; try&#123;t2=arg2.toString().split(".")[1].length&#125;catch(e)&#123;&#125; r1=Number(arg1.toString().replace(".","")); r2=Number(arg2.toString().replace(".","")); return calc.mul( (r1/r2), Math.pow(10,t2-t1) ); &#125;&#125; 使用方式123456789101112// 1 + 2.33 calc.add( 1 , 2.33)// 6 - 3.33calc.sub( 6 , 3.33)// 5 * 2.33calc.mul( 5 , 2.33 )// 7 / 4.55calc.div( 7 , 4.55 )]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>精度丢失</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于sass的样式工具]]></title>
    <url>%2F2018%2F04%2F15%2Fsass%2Fscss-util%2F</url>
    <content type="text"><![CDATA[scss 实用工具样式，开箱即用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172$color-primary: #F56C6C;$color-danger: #409EFF;$color-info: #909399;$color-success: #67C23A;$color-warning: #E6A23C;.f-l&#123; float:left !important; _display: inline;&#125;.f-r&#123; float:right !important; _display: inline;&#125;.clearfix &#123; &amp;:after &#123; display: block; overflow: hidden; font-size: 0; content: " "; clear: both; height: 0; &#125;&#125;.text-r&#123; text-align: right;&#125;.text-l&#123; text-align: left;&#125;.text-c&#123; text-align: center;&#125;// 单行溢出省略号....text-overflow-1&#123; display: block !important; overflow: hidden; text-overflow: ellipsis; white-space: nowrap&#125;// 多行溢出省略号....text-overflow-2&#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125;.block-center&#123; margin: 0 auto;&#125;.boxsizing-border&#123; box-sizing: border-box;&#125;//弹性布局.flex&#123; display: -webkit-flex; display: flex; flex-wrap: wrap; //单行放不下时换行 align-items: flex-start; //交叉轴从轴开始的位置开始排列&#125;//主轴对齐方式-居中对齐.justify-c&#123; justify-content: center;&#125;.justify-start&#123; justify-content: flex-start;&#125;// margin-* padding-* 的快捷类使用 0---45px$total: 45;@while $total &gt;= 0 &#123; .mt-#&#123;$total&#125;&#123; margin-top: #&#123;$total&#125;px; &#125; .mr-#&#123;$total&#125;&#123; margin-right: #&#123;$total&#125;px; &#125; .mb-#&#123;$total&#125;&#123; margin-bottom: #&#123;$total&#125;px; &#125; .ml-#&#123;$total&#125;&#123; margin-left: #&#123;$total&#125;px; &#125; .pt-#&#123;$total&#125;&#123; padding-top: #&#123;$total&#125;px; &#125; .pr-#&#123;$total&#125;&#123; padding-right: #&#123;$total&#125;px; &#125; .pb-#&#123;$total&#125;&#123; padding-bottom: #&#123;$total&#125;px; &#125; .pl-#&#123;$total&#125;&#123; padding-left: #&#123;$total&#125;px; &#125; $total: $total - 1;&#125;// 字体颜色.fc-primary &#123; color: $color-primary;&#125;.fc-danger &#123; color: $color-danger;&#125;//字体大小$total-f: 30;@while $total-f &gt;= 8 &#123; .f-#&#123;$total-f&#125;&#123; font-size: #&#123;$total-f&#125;px; &#125; $total-f: $total-f - 2;&#125;// label.h-label&#123; display: inline-block; float: right; padding-right: 15px; line-height: 34px; color: #4A4A4A; font-weight: normal; &amp;.h-star::before&#123; content: "*"; color: #F56C6C; display: inline; margin-right: 4px; &#125;&#125;.h-text&#123; display: inline-block; float: left; line-height: 34px; color: #4A4A4A; font-weight: normal;&#125;]]></content>
      <categories>
        <category>sass相关</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>样式工具</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass语法]]></title>
    <url>%2F2018%2F04%2F14%2Fsass%2Fsass%2F</url>
    <content type="text"><![CDATA[记录 css 预编译语言 sass 的 基本使用。sass使用编程式的写法，赋予 css 更强的生命力。 基础注释单行注释1// 这是单行注释，编译时，不会被编译进 .css 文件 多行注释1/* 这是多行注释 ，编译时，会被一同 编译进 .css 文件*/ 变量sass 使用 $ 符号开头定义 变量名 ， 使用 : 赋值。 例12345$color: red;.fc&#123; color: $color;&#125; 编译结果:12.fc &#123; color: red; &#125; 计算sass 支持 + - * / % 运算。 123.w&#123; width: 50px + 50px;&#125; 编译结果:12.w &#123; width: 100px; &#125; 嵌套规则sass 支持 选择器 嵌套书写，同时支持 属性嵌套书写。 嵌套选择器12345div &#123; span&#123; color: rosybrown; &#125;&#125; 编译结果:12div span &#123; color: rosybrown; &#125; 属性嵌套属性嵌套时，属性名后必须加 :。 1234567.far&#123; border: &#123; style: solid; width: 1px; color: pink; &#125;&#125; 编译结果:1234.far &#123; border-style: solid; border-width: 1px; border-color: pink; &#125; 使用 &amp; 引用父元素12345678.far &#123; a&#123; color: #000; &amp;:hover&#123; color: red; &#125; &#125;&#125; 编译结果:1234.far a &#123; color: #000; &#125; .far a:hover &#123; color: red; &#125; 继承使用 @extend 命令实现继承，允许一个选择器继承另一个选择器的样式。比如：继承 .foo 类 的样式 12345678.foo&#123; height : 500px;&#125;.test&#123; width : 200px; @extend .foo;&#125; 编译结果:12345.foo, .test &#123; height: 500px; &#125;.test &#123; width: 200px; &#125; Mixin混合，通过 @mixin 命令定义 样式块 ， 使用 @include 命令包含引入 定义过的 样式块，达到样式代码复用的作用。Mixin有点像C语言的宏（macro），是可以重用的代码块。 12345678@mixin baz &#123; float: left; margin-left: 10px;&#125;div &#123; @include baz;&#125; 编译结果:123div &#123; float: left; margin-left: 10px; &#125; 带参数的Mixin跟其他编程语言一样， mixin 可以 定义 形参。 1234567@mixin bar( $w , $s , $c) &#123; border: $w $s $c;&#125;div &#123; @include bar(1px , solid , red)&#125; 编译结果:12div &#123; border: 1px solid red; &#125; @import@import 用来插入外部文件 1@import &apos;./a.scss&apos;; 高级用法@if 条件语句使用 @if , @else if , @else 命令来定义条件语句块。 例1234567891011span &#123; @if 1+1 ==2 &#123; color: red;&#125;&#125;$temp : 2px;p &#123; @if 2px &gt; $temp &#123; color: red&#125; @else if 3px &gt; $temp &#123; color: pink&#125; @else &#123; color: skyblue&#125;&#125; 编译结果:12345span &#123; color: red; &#125;p &#123; color: pink; &#125; @for循环1234567@for $i from 5 to 10&#123; .mb-#&#123;$i&#125;&#123; margin-bottom: #&#123;$i&#125;px; &#125;&#125; 编译结果:1234567891011121314.mb-5 &#123; margin-bottom: 5px; &#125;.mb-6 &#123; margin-bottom: 6px; &#125;.mb-7 &#123; margin-bottom: 7px; &#125;.mb-8 &#123; margin-bottom: 8px; &#125;.mb-9 &#123; margin-bottom: 9px; &#125; @while循环123456789$total: 55;@while $total &gt;= 5 &#123; .mt-#&#123;$total&#125;&#123; margin-top: #&#123;$total&#125;px; &#125; $total: $total - 5;&#125; 编译结果:1234567891011121314151617181920212223242526272829303132.mt-55 &#123; margin-top: 55px; &#125;.mt-50 &#123; margin-top: 50px; &#125;.mt-45 &#123; margin-top: 45px; &#125;.mt-40 &#123; margin-top: 40px; &#125;.mt-35 &#123; margin-top: 35px; &#125;.mt-30 &#123; margin-top: 30px; &#125;.mt-25 &#123; margin-top: 25px; &#125;.mt-20 &#123; margin-top: 20px; &#125;.mt-15 &#123; margin-top: 15px; &#125;.mt-10 &#123; margin-top: 10px; &#125;.mt-5 &#123; margin-top: 5px; &#125; @each遍历作用与 @for 相似。12345@each $value in 5,10,15,20&#123; .pt-#&#123;$value&#125;&#123; padding-top: #&#123;$value&#125;px; &#125;&#125; 编译结果:1234567891011.pt-5 &#123; padding-top: 5px; &#125;.pt-10 &#123; padding-top: 10px; &#125;.pt-15 &#123; padding-top: 15px; &#125;.pt-20 &#123; padding-top: 20px; &#125; @function自定义函数使用 @function 定义一个函数 , @return 后接返回值。1234567@function step($n)&#123; @return $n * 5&#125;div &#123; width: step(5px);&#125; 编译结果:12div &#123; width: 25px; &#125; 编译方式koala图形界面工具koala 是一款国人开发的，用来将 sass / less 文件 编译成 浏览器可执行的 .css文件的一款图形界面的 css 预编译工具。详细使用方式请查阅其官网: https://koala-app.com webpack构建工具node-sass sass-loader]]></content>
      <categories>
        <category>css预编译</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2018%2F04%2F14%2Fgit%2Fgit%2F</url>
    <content type="text"><![CDATA[记录Git的常用操作命令，方便日后查看。 配置配置用户名1git config --global user.name [yourname] 配置邮箱1git config --global user.email [youremail] 查看配置信息1git config --list 编辑配置文件12# 使用此命令，会进入 vim 编辑器git config -e --global 配置忽略文件通过在项目根目录下创建 .gitignore 文件来配置定义 一些文件(夹) 不被提交到 远程仓库。比如，当前项目的一些测试代码文件、编辑器配置文件、npm管理包 node_modules 等。可以使用 touch .gitignore 命令来生成该文件。windows 下 无法 创建无名字的文件（其会把 . 后的认作后缀名）。 .gitignore文件示例 123456test/node_modules/.git.idea/.vscode.gitignore 基本操作git init初始化git仓库，在项目文件夹中打开git bash，输入 git init 即可创建git仓库。项目文件夹中会生成一个.git文件夹。里面创建有暂存区和本地仓库区。1git init git status查看当前项目中的文件状态，即做出了何种类型的修改（增、删、改），文件是否被追踪。1git status git add将文件添加至暂存区。 12345678# 将指定文件添加至暂存区git add [文件名] # 将所有文件添加至暂存区git add .# orgit add -A# orgit add --all git commit将暂存区中的文件提交至本地仓库区。1234567git commit -m '提交时的辅助说明信息'# 也可以不带 -m 参数，直接回车，此时会进入 vim 编辑器 ，在这里书写你此次提交的信息git commit# 使用一次新的commit , 替代上一次的提交，如果代码没有改变，则更新上一次的提交信息。git commit -amend -m [message] git log查看提交日志。 12345678# 查看当前head 及 以前的 日志git log# 查看简洁的日志，每条提交日志以一条的形式展示git log --oneline# 查看所有的提交日志git reflog git checkout将文件从暂存区还原到工作区。 1git checkout [文件名.xxx] git reset将指定版本项目从本地仓库区还原到工作区。 1git reset --hard [版本号] 打标签像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 列出标签在 Git 中列出已有的标签是非常简单直观的。 只需要输入 git tag： 1234567891011# 列出所有标签$ git tagv1.0v2.0# 按照指定模式列出标签$ git tag -l 'v1.8.*'v1.8.2v1.8.4 新建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。 附注标签在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项： 12345$ git tag -a v1.4 -m 'my version 1.4'$ git tagv0.1v1.3v1.4 -m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行vim编辑器要求你输入信息。 通过使用 git show 命令可以看到标签信息与对应的提交信息： 123456789101112$ git show v1.4tag v1.4Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 轻量标签另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： 1234567$ git tag v1.4-lw$ git tagv0.1v1.3v1.4v1.4-lwv1.5 这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息: 123456$ git show v1.4-lwcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 后期打标签你也可以对过去的提交打标签。 假设提交历史是这样的： 1234567891011$ git log --pretty=oneline15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support0d52aaab4479697da7686c15f77a3d64d9165190 one more thing6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function4682c3261057305bdd616e23b64b0857d832627b added a todo file166ae0c4d3f420721acbb115cc33848dfcc2121a started write support9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）。 1$ git tag -a v1.2 9fceb02 可以看到你已经在那次提交上打上标签了： 1234567891011121314151617181920$ git tagv0.1v1.2v1.3v1.4v1.4-lwv1.5$ git show v1.2tag v1.2Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Feb 9 15:32:16 2009 -0800version 1.2commit 9fceb02d0ae598e95dc970b74767f19372d61af8Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;Date: Sun Apr 27 20:43:35 2008 -0700 updated rakefile... 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。 123456789git push origin v1.5Counting objects: 14, done.Delta compression using up to 8 threads.Compressing objects: 100% (12/12), done.Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.Total 14 (delta 3), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new tag] v1.5 -&gt; v1.5 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。 1git push origin --tags 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 分支操作git branch查看当前项目中的所有分支，在当前分支的前面会有一个 * 。 1234567891011121314# 查看本地分支列表，不包含远程分支git branch# 查看远程分支列表git branch -r# 查看所有分支列表，包含本地和远程分支git branch --all # or git branch -a# 删除分支，对于已经合并过的分支可以进行删除，删除的是本地分支git branch -d [分支名] git branch -vv如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。 12345$ git branch -vv iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets master 1ae2a45 [origin/master] deploying index fix* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it testing 5ea463a trying something new 这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。 需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：git fetch --all; git branch -vv。 git checkout切换分支，可以从当前分支切换到指定分支上。 1234# 切换分支git checkout [分支名]# 创建新的分支，并切换到这个分支git checkout -b [分支名] 注：当需要同步远程分支到本地仓库时，可以执行 git checkout -b [branch] [remotename]/[branch] 命令。将指定远程分支 [remotename]/[branch] 同步到本地仓库。 例： 123# 需要同步远程分支 develop 到本地仓库git checkout -b develop origin/develop 运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式： 1git checkout --track origin/serverfix 该操作表示，在本地创建 serverfix 分支，并跟踪远程分支 origin/serverfix。当执行 git pull 命令时，会自动更新 origin/serverfix 远程分支的代码到 serverfix 分支上。 git merge将指定分支合并到当前分支。git内部使用的是指针操作原理。 1git merge [分支名] 注：在执行合并操作前，你首先需要切换到 要合入 的分支上，然后再执行合并操作。 例： 你需要将 trunk 分支的代码合并到 develop 分支上，首先你需要切换到 develop 分支上。 1git checkout develop 然后执行合并操作。 1git merge trunk 此时，trunk 分支上的新代码就被合并到了 develop 分支上。 远程仓库git clone从远程仓库拷贝项目至本地。 1git clone [远程仓库地址] [重命名项目名] 项目名称参数不提供时，会默认使用原项目名称。 git fetch当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。 由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。 git pull更新远程仓库代码至本地。用于更新项目其他成员提交的代码。一般在 push 前，一定要先 pull。 1git pull [远程仓库地址/仓库别名] [分支名] git push将本地仓库中的代码提交至远程仓库。 1git push [远程仓库地址/仓库别名] [分支名] 删除远程分支假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令： 123$ git push origin --delete serverfixTo https://github.com/schacon/simplegit - [deleted] serverfix 基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。 git remote123456# 查看所有的仓库别名git remote# 新增仓库别名git remote add [别名] [远程仓库地址]# 删除仓库别名git remote remove [别名] SSH免密码登陆github配置git 支持多种数据传输协议例： https协议：https://github.com/jquery/jquery.git ssh协议：git@github.com:jquery/jquery.git 每次 push 或者 pull 代码，如果使用 https 协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。github 为了账户的安全，需要对每一次 push 请求都要验证用户的身份，只有合法的用户才可以 push，使用 ssh协议，配置 ssh 免密码，可以做到免密码往 github 推送代码。 SSH 免密码登录配置命令 创建 SSH Key：ssh-keygen -t rsa。 在文件路径 C:\用户\当前用户名\ 找到 .ssh 文件夹。 文件夹中有两个文件： 私钥：id_rsa，公钥：id_rsa.pub。 在 github -&gt; settings -&gt; SSH and GPG keys 页面中，新创建 SSH key。 粘贴公钥 id_rsa.pub 内容到对应文本框中。 在 github 中新建仓库或者使用现在仓库，拿到 git@github.com:用户名/仓库名.git。 此后，再次 SSH 方式与 github “通信”，不用输入密码确认身份了。]]></content>
      <categories>
        <category>Git相关</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6之模块加载]]></title>
    <url>%2F2018%2F02%2F14%2FmoduleDefinition%2FesModule%2Fes6-module%2F</url>
    <content type="text"><![CDATA[本文记录 esModule 的语法及使用。 前言在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 、AMD 和 CMD 三种。前者用于服务器，后两种用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS ，AMD 和 CMD 规范，成为浏览器和服务器通用的模块解决方案。 es6的模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。 export 命令一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。下面是一个 JS 文件，里面使用 export 命令输出变量。 12export var foo = 1export var str = '' 如上代码，向外导出了 foo 和 str 两个变量。 除了使用上面的导出方式，还可以这样导出对外接口： 123456var foo = 1var str = ''export &#123; foo, str&#125; 你可以像上面代码一样，在 export 后面使用一个大括号将一组变量导出。推荐优先使用这样的导出方式，这样就可以在文件的尾部一眼看出导出了多少变量。 export 命令除了导出变量，还可以导出函数或类。 123456789export const say()&#123; console.log('hello')&#125;export class Person &#123; constructor()&#123; // ... &#125;&#125; 如上代码，导出了 say 函数 和 Person 类。 通常情况下，export 导出的变量就是原来的名字，但是可以使用 as 关键字修改导出变量的名字。 1234567var foo = 1var fn = function()&#123;&#125;export &#123; foo as baz, fn&#125; 上面代码共导出了 2 个变量，其中，导出的foo 被重新命名为了 baz。 需要特别注意的是，export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 下面这样的写法是错误的： 123456// 报错export 1// 报错var foo = 2export foo 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。 123var a = 1export &#123;a&#125;export const b = 2 另外，export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量 foo，值为 bar，500 毫秒之后变成 baz。 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。 注意：export 命令除了不能放在块级作用域内，模块顶层任何位置都可以。 1234function foo()&#123; // 报错 export var a = 1&#125; import 命令使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。 123456// main.jsimport &#123; firstName, lastName, year &#125; from './profile.js';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 上面代码的 import 命令，用于加载 profile.js 文件，并从中输入变量。import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名。 1import &#123; lastName as surname &#125; from './profile.js'; import 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。 123import &#123;a&#125; from './xxx.js'a = &#123;&#125;; // Syntax Error : 'a' is read-only; 上面代码中，脚本加载了变量 a，对其重新赋值就会报错，因为 a 是一个只读的接口。但是，如果 a 是一个对象，改写 a 的属性是允许的。 123import &#123;a&#125; from './xxx.js'a.foo = 'hello'; // 合法操作 上面代码中，a 的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。 import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 1import &#123;myMethod&#125; from 'util'; 上面代码中，util 是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 注意，import 命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from 'my_module'; 上面的代码不会报错，因为 import 的执行早于 foo 的调用。这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前。 由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12345678910111213// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125; else &#123; import &#123; foo &#125; from 'module2';&#125; 上面三种写法都会报错，因为它们用到了 表达式、变量 和 if 结构。在静态分析阶段，这些语法都是没法得到值的。 最后，import 语句会执行所加载的模块，因此可以有下面的写法。 1import 'lodash'; 上面代码仅仅执行 lodash 模块，但是不输入任何值。 如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。 12import 'lodash';import 'lodash'; 上面代码加载了两次 lodash，但是只会执行一次。 12345import &#123; foo &#125; from 'my_module';import &#123; bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module'; 上面代码中，虽然 foo 和 bar 在两个语句中加载，但是它们对应的是同一个 my_module 实例。也就是说，import 语句是 Singleton 模式。 目前阶段，通过 Babel 转码，CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个模块里面，但是最好不要这样做。因为 import 在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。 123require('core-js/modules/es6.symbol');require('core-js/modules/es6.promise');import React from 'React'; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号 * 指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法 area 和 circumference。 123456789// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 现在，加载这个模块。 123456// main.jsimport &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下。 1234import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。 12345import * as circle from './circle';// 下面两行都是不允许的circle.foo = 'hello';circle.area = function () &#123;&#125;; export default一个模块中，还可以有默认导出，es6 中使用 export default 来导出默认接口。 1234// foo.jsexport default function()&#123; // ...&#125; 上面代码，默认导出了一个函数。然后，我们可以这样使用它： 12import foo from './foo.js'foo() 一个模块只能有一个默认导出，在使用一个模块的默认导出时，import 命令后可以不使用大括号，并且可以使用任意的变量名来命名这个默认导出。 与上面的导入方式等价的如下： 12import &#123; default as foo &#125; from './foo.js'foo() 本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。 import() 函数前面介绍过，import 命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import命令叫做 连接 binding 其实更合适）。所以，下面的代码会报错。 1234// 报错if (x === 2) &#123; import MyModual from './myModual';&#125; 上面代码中，引擎处理 import 语句是在编译时，这时不会去分析或执行 if 语句，所以 import 语句放在 if 代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import 和 export 命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。 这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为require 是运行时加载模块，import 命令无法取代 require 的动态加载功能。 12const path = './' + fileName;const myModual = require(path); 上面的语句就是动态加载，require 到底加载哪一个模块，只有运行时才知道。import 命令做不到这一点。 因此，有一个提案，建议引入 import() 函数，完成动态加载。 1import(specifier) 上面代码中，import 函数的参数 specifier，指定所要加载的模块的位置。import 命令能够接受什么参数，import() 函数就能接受什么参数，两者区别主要是后者为动态加载。 import() 返回一个 Promise 对象。下面是一个例子。 123456789const main = document.querySelector('main');import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;) .catch(err =&gt; &#123; main.textContent = err.message; &#125;); import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同。import() 类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。 注意点import() 加载模块成功以后，这个模块会作为一个对象，当作 then 方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。 1234import('./myModule.js').then((&#123;export1, export2&#125;) =&gt; &#123; // ...·&#125;); 上面代码中，export1 和 export2 都是 myModule.js 的输出接口，可以解构获得。 如果模块有 default 输出接口，可以用参数直接获得。 1234import('./myModule.js').then(myModule =&gt; &#123; console.log(myModule.default);&#125;); 上面的代码也可以使用具名输入的形式。 1234import('./myModule.js').then((&#123;default: theDefault&#125;) =&gt; &#123; console.log(theDefault);&#125;); 如果想同时加载多个模块，可以采用下面的写法。 12345678Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'),]).then(([module1, module2, module3]) =&gt; &#123; ···&#125;); import() 也可以用在 async 函数之中。 1234567891011async function main() &#123; const myModule = await import('./myModule.js'); const &#123;export1, export2&#125; = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);&#125;main(); 在浏览器中的加载方式es6 规定，要想在浏览器中使用 esModule 功能，需要在 &lt;script&gt; 标签上使用 type=&quot;module&quot; 的属性。 1234&lt;script type="module"&gt; import dom from './dom.js' // some code here ...&lt;/script&gt; 如上所示，type=&quot;module&quot; 的属性告诉 javascript 引擎，这个脚本是一个 es6 模块。它的加载方式同 defer 属性，也是异步的，会等到页面渲染完成后再下载执行。 如果有多个 &lt;script&gt; 标签，它会按顺序执行。 es6 模块与 CommonJS 的区别它们有两个重大差异。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 下面重点解释第一个差异。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件 lib.js 的例子。 123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。然后，在 main.js 里面加载这个模块。 123456// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3 上面代码说明，lib.js 模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。 1234567891011// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 上面代码中，输出的 counter 属性实际上是一个取值器函数。现在再执行 main.js ，就可以正确读取内部变量 counter 的变动了。 123$ node main.js34 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 还是举上面的例子。 1234567891011// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 上面代码说明，ES6 模块输入的变量 counter 是活的，完全反应其所在模块 lib.js 内部的变化。 再举一个出现在export一节中的例子。 12345678// m1.jsexport var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500);// m2.jsimport &#123;foo&#125; from './m1.js';console.log(foo);setTimeout(() =&gt; console.log(foo), 500); 上面代码中，m1.js 的变量 foo，在刚加载时等于 bar，过了 500 毫秒，又变为等于 baz。 让我们看看，m2.js 能否正确读取这个变化。 1234$ babel-node m2.jsbarbaz 上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 12345678// lib.jsexport let obj = &#123;&#125;;// main.jsimport &#123; obj &#125; from './lib';obj.prop = 123; // OKobj = &#123;&#125;; // TypeError 上面代码中，main.js 从 lib.js 输入变量 obj ，可以对 obj 添加属性，但是重新赋值就会报错。因为变量 obj 指向的地址是只读的，不能重新赋值，这就好比 main.js 创造了一个名为 obj 的 const 变量。 最后，export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。 12345678910// mod.jsfunction C() &#123; this.sum = 0; this.add = function () &#123; this.sum += 1; &#125;; this.show = function () &#123; console.log(this.sum); &#125;;&#125; 1export let c = new C(); 上面的脚本 mod.js，输出的是一个 C 的实例。不同的脚本加载这个模块，得到的都是同一个实例。 1234567891011// x.jsimport &#123;c&#125; from './mod';c.add();// y.jsimport &#123;c&#125; from './mod';c.show();// main.jsimport './x';import './y'; 现在执行 main.js，输出的是 1。 12$ babel-node main.js1 这就证明了 x.js 和 y.js 加载的都是 C 的同一个实例。]]></content>
      <categories>
        <category>模块化相关</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>esModule</tag>
        <tag>export</tag>
        <tag>import</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XMLHttpRequest Level 2 实现文件下载]]></title>
    <url>%2F2018%2F01%2F14%2Fjavascript%2Finstance%2FdownloadWithXHR2%2F</url>
    <content type="text"><![CDATA[在 XMLHttpRequest level 2 中可以利用 Ajax 实现对二进制文件的下载功能，通过设置 responseType=&#39;blob&#39;告诉浏览器放回的数据类型为二进制流大文件类型，即可触发浏览器的下载功能。 依赖 element-ui 加载层、提示层模块 moment 时间日期格式处理模块 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// 如果想使用其他提示层，可以修改提示部分的逻辑代码import &#123; Loading, Message &#125; from "element-ui";import moment from 'moment';/** * @author: hongwenqing * @desc: 文件下载功能 * @url: 请求地址 * @data: post 请求参数 * @params: get 请求参数 * @method: 请求方式 * @filename: 自定义文件名 * @loadingText: loading 提示文本内容 * @errorText: 下载失败时提示文本 * @returns: Promise */const download = (&#123; url, // 请求地址 data, // post 请求参数 params, // get 请求参数 method = "post", // 请求方式 filename, // 文件名 loadingText = "正在下载...", // loading 提示文本内容 errorText = "下载失败", // 下载失败时提示文本 handleErr // 自定义文件下载时，系统级抛错时处理函数，非 http 错误&#125;) =&gt; &#123; let loadingInstance = Loading.service(&#123; // 创建加载提示实例 background: "transparent", fullscreen: true, text: loadingText &#125;); // for post data = data ? JSON.stringify(data) : false; // for get if (params) &#123; url += '?' + decodeURIComponent( new URLSearchParams( params ) ) &#125; return new Promise((resolve, reject) =&gt; &#123; let x = new XMLHttpRequest(); x.open(method, url, true); if (method === "post" || method === "POST") x.setRequestHeader("content-type", "application/json;charset=utf-8"); // 设置请求头，格式为json x.responseType = "blob"; // 返回类型为二进制流 x.onload = function(e) &#123; let client_msg = errorText, blob = this.response, status = this.status; // 获取文件名 filename = getFileName( filename , this ) if (status == 504) &#123; client_msg = "网络忒卡，连接超时"; &#125; loadingInstance.close(); // 关闭 if (status == 200) &#123; //文件下载/导出异常处理 if (blob.type.indexOf("application/json") !== -1) &#123; blobToJson(blob).then(res =&gt; &#123; handleErr &amp;&amp; handleErr(res); &#125;); return; &#125; //文件正常下载 if (window.navigator.msSaveOrOpenBlob) &#123; // for IE window.navigator.msSaveOrOpenBlob(blob, filename); &#125; else &#123; // 现代浏览器 let eleLink = document.createElement("a"), // 创建隐藏的可下载链接 objectUrl = URL.createObjectURL(blob); // 将内容转为 blob 地址 eleLink.setAttribute("download", filename); // 设置文件名 eleLink.style.display = "none"; eleLink.href = objectUrl; document.body.appendChild(eleLink); // 插入body eleLink.click(); // 触发点击 document.body.removeChild(eleLink); // 然后移除 &#125; resolve(); &#125; else &#123; Message.error(&#123; message: client_msg &#125;); reject(e); &#125; &#125;; x.onerror = function(e) &#123; loadingInstance.close(); // 关闭 Message.error(&#123; message: errorText &#125;); reject(e); &#125;; // 发送 if (data) x.send(data); else x.send(); &#125;);&#125;;// blob数据转json处理函数function blobToJson(blob) &#123; return new Promise((resolve, reject) =&gt; &#123; let reader = new FileReader(); reader.readAsText(blob); reader.onload = e =&gt; &#123; let jsonRes = JSON.parse(e.target.result); resolve(jsonRes); &#125;; &#125;);&#125;// 文件名获取方式（来自自定义或响应头）function getFileName( customFilename, xhr )&#123; let name = ''; if ( customFilename )&#123; name = customFilename &#125;else &#123; let headers = xhr.getResponseHeader('content-disposition') || moment( +new Date() ).format('YMDHmm'), index = headers.search('filename='), start = index === -1 ? 0 : index; name = decodeURIComponent( headers.slice( start + 9 ) ); &#125; // 如果没有扩展名，默认加上 .xls return name.lastIndexOf('.') !== -1 ? name : ( name + '.xls' );&#125;export default download; 上方代码可直接应用到实际项目中，使用方式就是按照正常的 Ajax 请求那样调用此函数即可。 使用实例1234567891011121314151617181920212223// foo.jsimport download from './download.js'download(&#123; url: '/foo/bar/download' data: &#123; fileId: 1 &#125;, filename: '自定义文件名.xls', handleErr( res )&#123; // 系统级抛错处理回调 console.log( res ) &#125;&#125;).then( () =&gt; &#123; // download success // do something else ...&#125;).catch(err =&gt; &#123; // download failed // do something else ... console.log( err )&#125;) 说明 如果想要自定义下载的文件名称，请始终保持你设置的 filename （必须包含文件名扩展后缀）。 该方法仅支持 post 、get 请求。 Logs 2018-12-1 优化下载方法。 2019-3-1 新增 handleErr。 2019-5-27 去除 mimetype 参数，该参数无需传入。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>XMLHttpRequest2</tag>
        <tag>blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs之模块加载]]></title>
    <url>%2F2018%2F01%2F01%2FmoduleDefinition%2FcommonJs%2Fnodejs-module%2F</url>
    <content type="text"><![CDATA[本文介绍 nodejs 中的模块加载方式及用法。 前言在 Node.js 模块系统中，每个文件都被视为一个独立的模块。 例如，假设有一个名为 foo.js 的文件： 12const circle = require('./circle.js');console.log(`半径为 4 的圆的面积是 $&#123;circle.area(4)&#125;`); 在第一行中， foo.js 加载了与 foo.js 在同一目录中的 circle.js 模块。 以下是 circle.js 的内容： 12345const &#123; PI &#125; = Math;exports.area = (r) =&gt; PI * r ** 2;exports.circumference = (r) =&gt; 2 * PI * r; circle.js 模块导出了 area() 和 circumference() 函数。 通过在特殊的 exports 对象上指定额外的属性，可以将函数和对象添加到模块的根部。 模块内的本地变量是私有的，因为模块由 Node.js 封装在一个函数中（详见模块封装器）。 在这个例子中，变量 PI 对 circle.js 是私有的。 可以为 module.exports 属性分配新的值（例如函数或对象）。 下面的例子中， bar.js 使用了导出 Square 类的 square 模块： 123const Square = require('./square.js');const mySquare = new Square(2);console.log(`mySquare 的面积是 $&#123;mySquare.area()&#125;`); square 模块定义在 square.js 中： 12345678910// 赋值给 `exports` 不会修改模块，必须使用 `module.exports`。module.exports = class Square &#123; constructor(width) &#123; this.width = width; &#125; area() &#123; return this.width ** 2; &#125;&#125;; 模块系统在 require(‘module’) 模块中实现。 模块定义在 nodejs 中，一个模块的定义或者说导出方式是使用 module.exports 或者 exports。 12345678// foo.jsmodule.exports = &#123; name: 'foo' say()&#123; console.log('this is '+ this.name +' module') &#125; // ...&#125; 如上，我们定义了 foo.js 模块，你可以是使用 require 函数来引用她。 使用 exports 向外提供接口。 1234// baz.jsexports.say = function( text )&#123; console.log( 'hello' + text + '!' )&#125; 如上，baz 模块向外提供了 say 方法。 模块导入在 nodejs 中，使用 require 函数来引用一个模块。 123// bar.jsconst foo = require('./foo.js')foo.say() // this is foo module 如上代码，我们引用了 foo.js 模块，并使用了 foo.say 方法。 exports 和 module.exports我们已经知道了在 nodejs 中 模块的定义及引用方式，那么 exports 和 module.exports 这两种导出方式有何不同呢？ 当你使用 require 函数引用一个模块时，她返回的永远是 module.exports 对象。 类似于对 exports 重新赋值对外导出接口的方式是无效的： 12345// foo.jsexports = &#123; msg: 'wow' // ...&#125; 1234// bar.jsconst foo = require('./foo.js')console.log( foo.msg ) // msg is undefinedconsole.log( foo ) // &#123;&#125; 如上代码的导出方式可以简单的这样理解： 1234567var a = &#123;&#125;var b = a;b = &#123; msg: 'wow'&#125;console.log( a ) // &#123;&#125; 所以，你可以为 exports 快捷方式添加属性，但是不可以对其直接重新赋值。 nodejs 中的模块加载规则模块类型在 nodejs 中，存在不同类型的模块：外部模块，核心模块，文件模块，文件夹模块。那么对于这些模块的加载规则都有所不同。 外部模块所谓 外部模块 指的是使用 npm 管理的第三方模块，即安装在 node_modules 文件夹中的模块。比如：koa等。 核心模块核心模块 指的是 nodejs 自身提供的一些内部模块，无需安装，可直接 require 引用。比如：http, path, fs 等。 文件模块在本地自己新建的 *.js 、*.json 、*.node 被称作 文件模块。 目录模块根据模块加载规则，nodejs 中，我们认为一个文件夹也是一个模块，也就是说，我们可以 require(&#39;./directory&#39;) 来引用一个模块。 123// foo 是一个文件夹，该文件夹下存在一个 index.js 文件const foo = require('./foo')// do something... 具体为什么可以这么引用，在接下来的模块加载规则中会详细说明。 加载规则先看如下伪代码描述的高级算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051require(X) from module at path Y1. If X is a core module, a. return the core module b. STOP2. If X begins with &apos;/&apos; a. set Y to be the filesystem root3. If X begins with &apos;./&apos; or &apos;/&apos; or &apos;../&apos; a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X)4. LOAD_NODE_MODULES(X, dirname(Y))5. THROW &quot;not found&quot;LOAD_AS_FILE(X)1. If X is a file, load X as JavaScript text. STOP2. If X.js is a file, load X.js as JavaScript text. STOP3. If X.json is a file, parse X.json to a JavaScript Object. STOP4. If X.node is a file, load X.node as binary addon. STOPLOAD_INDEX(X)1. If X/index.js is a file, load X/index.js as JavaScript text. STOP2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP3. If X/index.node is a file, load X/index.node as binary addon. STOPLOAD_AS_DIRECTORY(X)1. If X/package.json is a file, a. Parse X/package.json, and look for &quot;main&quot; field. b. If &quot;main&quot; is a falsy value, GOTO 2. c. let M = X + (json main field) d. LOAD_AS_FILE(M) e. LOAD_INDEX(M) f. LOAD_INDEX(X) DEPRECATED g. THROW &quot;not found&quot;2. LOAD_INDEX(X)LOAD_NODE_MODULES(X, START)1. let DIRS = NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. LOAD_AS_FILE(DIR/X) b. LOAD_AS_DIRECTORY(DIR/X)NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = [GLOBAL_FOLDERS]4. while I &gt;= 0, a. if PARTS[I] = &quot;node_modules&quot; CONTINUE b. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;) c. DIRS = DIRS + DIR d. let I = I - 15. return DIRS 翻译过来的具体行为如下： 假设你要引用一个模块 x （x 可以是 nodejs 的核心模块，外部第三方模块，文件模块或者一个目录）。 1const x = require(x) 判断模块 x 是否为 nodejs 核心模块，如果是，直接返回该核心模块。 不满足1时，判断 x 是否是以 / 、./ 、 ../ 开头，如果是，这 x 被认为是 本地模块（文件模块或目录模块）。 如果根据路径找到的是文件类型 *.js、*.json、*.node ，则根据扩展名解析返回为不同的数据。 如果是 x.js 文件，则返回 javascript 文本。 如果是 x.json 文件，则将其解析为 javascript 对象并返回。 如果是 x.node 文件，则将其作为 node 的二进制插件并返回。 如果根据路径找到的是文件夹类型，那么 node 会继续在该文件夹下查找以 index.* 的文件，包括 index.js、index.json 、index.node等文件并将其返回。像在使用 webpack 这样的构建系统的 @vue/cli 项目中，index.vue 也会被匹配到。 如果根据以上条件都没有匹配到模块文件，那么 node 会将 x 视为 第三方外部模块。 满足条件 8 时，node 会以当前引用 x 模块的文件为原点，递归向外查找 node_modules 文件夹，直到项目根目录。 只要找到了第一个 node_modules 文件夹，那么 node 便会停止递归查找，并在该 node_modules 文件夹下查找 x 文件夹。 如果在 node_modules 中没有找到 x 文件夹，那么抛出 not found 错误。 如果在 node_modules 找到了 x 文件夹，那么 node 会查看解析 x 文件夹下的 package.json 文件 再查看该 package.json 文件中是否存在 main 字段，该字段表示 x 模块的入口文件路径，node 会根据该文件路径解析出具体的文件并将其返回。 如果 package.json 文件都不存在，那么 node 会尝试查找 x 文件夹下是否存在一个 index.js 的文件，如果有，直接将其返回，如果没有抛出 not found 错误。 至此，如果根据以上规则都没有找到指定的模块，那么 node 就不会再查找了，直接抛出 not found 错误。 模块封装器在执行模块代码之前，Node.js 会使用一个如下的函数封装器将其封装： 123(function(exports, require, module, __filename, __dirname) &#123;// 模块的代码实际上在这里&#125;); 通过这样做，Node.js 实现了以下几点： 它保持了顶层的变量（用 var、 const 或 let 定义）作用在模块范围内，而不是全局对象。 它有助于提供一些看似全局的但实际上是模块特定的变量，例如： 实现者可以用于从模块中导出值的 module 和 exports 对象。包含模块绝对文件名和目录路径的快捷变量 __filename 和 __dirname 。]]></content>
      <categories>
        <category>模块化相关</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>nodejs</tag>
        <tag>CommonJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端rem布局]]></title>
    <url>%2F2017%2F07%2F06%2Fcss%2Fcss3-rem%2F</url>
    <content type="text"><![CDATA[rem （root em） 属于相对单位， 其不是像 em 单位那样是相对于当前元素的字体大小 font-size 计算得出的值，rem 始终相对于页面根元素，即 html 的 font-size 大小计算得出。 所以我们可以使用 rem 作为页面布局主单位，再利用 媒体查询(@media screen) 或 javascript 动态计算并设置在不同屏幕大小下根元素 html 的 font-size 属性值，使得页面元素可以响应式的显示合适的大小。 动态设置 html 元素 font-size 的几种方式配置固定媒体查询法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960html,body&#123; margin: 0; /*font-size : 54px;*/&#125;/*设置媒体查询 E (来自苏宁手机端媒体查询数据)*/ @media screen and (min-width: 320px)&#123; html&#123; font-size: 21.33px; &#125; &#125; @media screen and (min-width: 360px)&#123; html&#123; font-size: 24px; &#125; &#125; @media screen and (min-width: 375px)&#123; /*UI设计图宽度为750px*/ html&#123; font-size: 25px; &#125; &#125; @media screen and (min-width: 384px)&#123; html&#123; font-size: 25.6px; &#125; &#125; @media screen and (min-width: 400px)&#123; html&#123; font-size: 26.67px; &#125; &#125; @media screen and (min-width: 414px)&#123; html&#123; font-size: 27.6px; &#125; &#125; @media screen and (min-width: 424px)&#123; html&#123; font-size: 28.27px; &#125; &#125; @media screen and (min-width: 480px)&#123; html&#123; font-size: 32px; &#125; &#125; @media screen and (min-width: 540px)&#123; html&#123; font-size: 36px; &#125; &#125;/*设置媒体查询 S */ js动态计算12345678910111213141516171819202122232425//利用js动态控制不同屏幕大小下html的font-size大小//以 640px宽度的屏幕,此时html的font-size为54px 作为参考//苏宁的媒体查询基准为：540px屏宽下html的font-size为36px//设动态获得的屏幕宽度为w,w宽度下html的font-size为x//则得出公式为：x = w * 54 / 640var html = document.querySelector("html"); var w = document.body.offsetWidth; var htmlFontSize = w * 54 / 640; html.style.fontSize = htmlFontSize + "px";window.addEventListener( "resize", function()&#123; var w = document.body.offsetWidth; var htmlFontSize = w * 54 / 640; if( htmlFontSize &gt; 54 )&#123; //控制根元素font-size值最大不超过54px htmlFontSize = 54; &#125; html.style.fontSize = htmlFontSize + "px";&#125;); 基于rem和vw的计算方式1234567891011121314151617181920212223242526272829303132html &#123; font-size: 16px;&#125;@media screen and (min-width: 375px) &#123; html &#123; /* iPhone6的375px尺寸作为16px基准，414px正好18px大小, 600 20px */ font-size: calc(100% + 2 * (100vw - 375px) / 39); font-size: calc(16px + 2 * (100vw - 375px) / 39); &#125;&#125;@media screen and (min-width: 414px) &#123; html &#123; /* 414px-1000px每100像素宽字体增加1px(18px-22px) */ font-size: calc(112.5% + 4 * (100vw - 414px) / 586); font-size: calc(18px + 4 * (100vw - 414px) / 586); &#125;&#125;@media screen and (min-width: 600px) &#123; html &#123; /* 600px-1000px每100像素宽字体增加1px(20px-24px) */ font-size: calc(125% + 4 * (100vw - 600px) / 400); font-size: calc(20px + 4 * (100vw - 600px) / 400); &#125;&#125;@media screen and (min-width: 1000px) &#123; html &#123; /* 1000px往后是每100像素0.5px增加 */ font-size: calc(137.5% + 6 * (100vw - 1000px) / 1000); font-size: calc(22px + 6 * (100vw - 1000px) / 1000); &#125;&#125; 实际应用配合 sass 在实际项目中使用通常我们想要使用 rem 布局，那么就需要解决 px 转 rem 的问题。以便在使用时，直观，易于理解。 借助 sass 中的 @function 将 px 转换成 rem： 1234@function px2rem($px)&#123; @return $px / 16px * 1rem;&#125; 上面代码表示，在当前页面的 html 元素的 font-size 值为：16px 时，将 $px 转换为 rem 单位值。 1234.box &#123; width: px2rem(200px);&#125; 上面代码将被编译为： 123.box&#123; width : 12.5rem; /* 200px / 16px = 12.5rem */&#125; 在实际项目开发时，我们可以将 此功能函数封装在一个单独的 util.scss 文件中 1234567// 假定在页面 html 元素 font-size 为 16px 的屏幕宽 375px 下开发$base-root-font-size: 16px; @function px2rem($px)&#123; @return $px / $base-root-font-size * 1rem;&#125; 将动态处理 html 元素的 font-size 的样式文件单独全局引入。 然后在你的 某个页面 的样式文件中引入你的功能函数。 12345678@import '@/style/util.scss'// 开始你的表演 ....foo &#123; width: px2rem(200px);&#125; 就像上面代码那样，你只需要像之前你使用 px 进行布局一样简单，只不过是需要 加上 px2rem()。]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>css</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法说明]]></title>
    <url>%2F2017%2F06%2F06%2Fmarkdown%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[介绍 markdown 基本语法，方便日后查看。 markdown编辑器 Typora Mou MacDown 标题标题使用 # 号开头来表示 h1 - h6 。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表无序列表使用 + 或 - 开头的方式来定义无需列表。 12+ 无序列表1- 无序列表2 有序列表使用 1. 开头的方式来定义有序列表。 1231. 有序列表12. 有序列表2... 强调粗体使用 ** ** 双星号包裹文字的方式来加粗文字。或者使用 __ __ 来加粗文字。 12**加粗字体**__加粗文字__ 斜体使用* * 单星号包裹文字的方式来倾斜文字。你也可以使用 _ _ 下划线的方式包裹文字倾斜字体。 12*斜体字*_斜体字_ 删除线使用 ~~ ~~ 来给文字添加删除中线。 1~~被删除的文字~~ 高亮代码块使用 2个反引号 高亮行内代码，使用 3个反引号 来包裹代码块，表示代码块时在 反引号 后可以指定代码块的语言类型。 123456​(``` javascript) function hello ()&#123; console.log('hello markdown!') &#125;​(```) （） 是防止转义。 分割线使用 ***** 、----- 、_____ 或 +++++ 来添加分割线，每个符号保持 5 个以上即可。 1234*****-----_____+++++ 区块引用使用 &gt; 开头的方式可以添加区块引用的效果，并且可嵌套使用。 123&gt; 这段文字会在一个区块内显示&gt;&gt; 还可以嵌套... 表格表格的实现语法同样简单，如下： 1234| 表头1 | 表头2 | 表头3 || :--- | :---:| ---: || 文字左对齐 | 文字居中 | 文字右对齐 || 第二行文字 | 第二行文字 | 第二行文字 | 插入图片使用 ![]{} 的方式来插入图片。[title] 中可以书写图片的标题，{} 中为图片地址，可以是本地地址，也可以是远程地址。 1![图片]&#123;./imgs/1.jpg&#125; 超链接使用 []{} 的方式使用超链接，[title] 中添加标题，{} 中为链接地址。你也可以使用 html 中的 &lt;a&gt; 标签来使用超链接。 12[百度]&#123;http://www.baidu.com&#125;&lt;a href="http://www.baidu.com"&gt;百度&lt;/a&gt; 流程图将流程图代码包裹在 3个反斜杠 + flow 和 另一个 3反斜杠 之间即可。 1234567891011​(``` flow) st=&gt;start: 开始 io1=&gt;inputoutput: 输入用户名密码 cond1=&gt;condition: 确定要修改密码吗? op=&gt;operation: 修改用户密码 e=&gt;end: 结束 st-&gt;io1-&gt;cond1 cond1(no)-&gt;io1 cond1(yes)-&gt;op-&gt;e​(```) （） 是防止转义。 流程图代码分两块，上面一块是创建你的流程（创建元素），然后隔一行，创建流程的走向(连接元素)。 创建流程（元素）：tag=&gt;type: content:&gt;url tag 是流程图中的标签，在第二段连接元素时会用到。名称可以任意，一般为流程的英文缩写和数字的组合。 type 用来确定标签的类型，=&gt;后面表示类型。由于标签的名称可以任意指定，所以要依赖type来确定标签的类型 标签有6种类型：start end operation subroutine condition inputoutput content 是流程图文本框中的描述内容，: 后面表示内容，中英文均可。特别注意，冒号与文本之间一定要有个空格 url是一个连接，与框框中的文本相绑定，:&gt;后面就是对应的 url 链接，点击文本时可以通过链接跳转到 url 指定页面 ​ 指向流程(连接元素)：标识（类别）-&gt;下一个标识 使用 -&gt; 来连接两个元素 对于condition类型，有yes和no两个分支，如示例中的cond(yes)和cond(no) 每个元素可以制定分支走向，默认向下，也可以用right指向右边，如示例中cond2(yes,right)。 123456789st=&gt;start: 开始io1=&gt;inputoutput: 输入用户名密码cond1=&gt;condition: 确定要修改密码吗?op=&gt;operation: 修改用户密码e=&gt;end: 结束st-&gt;io1-&gt;cond1cond1(no)-&gt;io1cond1(yes)-&gt;op-&gt;e 表情图标使用双冒号 : : 中间加入表情名的方式来插入表情图。 1:emojiName: 例： :smile: :smile: 人物 图标 语法 :smile: :smile: :cry: :cry: :kissing: :kissing: :blush: :blush: :smirk: :smirk: :kissing_closed_eyes: :kissing_closed_eyes: :satisfied: :satisfied: :stuck_out_tongue_winking_eye: :stuck_out_tongue_winking_eye: :sleeping: :sleeping: :anguished: :anguished: :confused: :confused: :unamused: :unamused: :disappointed_relieved: :disappointed_relieved: :disappointed: :disappointed: :cold_sweat: :cold_sweat: :sob: :sob: :scream: :scream: :angry: :angry: :sleepy: :sleepy: :heartpulse: :heartpulse: 符号 图标 语法 :warning: :warning: :link: :link: :one: :one: :four: :four: :seven: :seven: :keycap_ten: :keycap_ten: :hash: :hash: :arrow_down: :arrow_down: :capital_abcd: :capital_abcd: :arrow_lower_left: :arrow_lower_left: :arrow_up: :arrow_up: :arrow_double_down: :arrow_double_down: :arrow_heading_down: :arrow_heading_down: :arrow_right_hook: :arrow_right_hook: :arrow_up_small: :arrow_up_small: :rewind: :rewind: :ok: :ok: :repeat_one: :repeat_one: :up: :up: :ng: :ng: :signal_strength: :signal_strength: :sa: :sa: :womens: :womens: :parking: :parking: :baggage_claim: :baggage_claim: :potable_water: :potable_water: :congratulations: :congratulations: :left_luggage: :left_luggage: :cl: :cl: :no_entry_sign: :no_entry_sign: :do_not_litter: :do_not_litter: :no_pedestrians: :no_pedestrians: :eight_spoked_asterisk: :eight_spoked_asterisk: :vs: :vs: :chart: :chart: :taurus: :taurus: :leo: :leo: :scorpius: :scorpius: :aquarius: :aquarius: :six_pointed_star: :six_pointed_star: :b: :b: :on: :on: :diamond_shape_with_a_dot_inside: :diamond_shape_with_a_dot_inside: :copyright: :copyright: :interrobang: :interrobang: :heavy_plus_sign: :heavy_plus_sign: :white_flower: :white_flower: :ballot_box_with_check: :ballot_box_with_check: :curly_loop: :curly_loop: :trident: :trident: :white_check_mark: :white_check_mark: :black_circle: :black_circle: :large_blue_circle: :large_blue_circle: :small_blue_diamond: :small_blue_diamond: :small_red_triangle_down: :small_red_triangle_down:]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个分页函数的实现]]></title>
    <url>%2F2017%2F05%2F06%2Fjavascript%2Finstance%2FpagingDeviceFunction%2F</url>
    <content type="text"><![CDATA[本文介绍如何使用 es5 高阶函数实现分页函数。 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function paging( condition , origin , &#123; currentPage, pageSize &#125; = &#123; currentPage: 0, pageSize: 0, &#125;)&#123; origin = !origin ? [] : origin let start_index = ( currentPage - 1 ) * pageSize, end_index = start_index + pageSize, isAllConditionNull = condition.every( v =&gt; v.value === '' || v.value === null ); // filter data let filterArr = origin.filter( ori =&gt; &#123; let valids = &#123;&#125;; condition.forEach( v =&gt; &#123; let o = &#123;&#125; valids[v.key] = true &#125;) for ( let k in valids )&#123; if ( valids.hasOwnProperty(k) )&#123; let curr = condition.find( v =&gt; v.key === k ) // 某条件信息对象 if ( curr.daterange )&#123; // 日期范围 let start = +new Date( curr.value ? curr.value[0] : 0 ), end = +new Date( curr.value ? curr.value[1] : 0 ), now = +new Date( ori[k] ); valids[k] = (start &lt;= now &amp;&amp; end &gt;= now) || !start &#125;else&#123; // 模糊、全匹配 valids[k] = (curr.fuzzy ? ori[k].search( curr.value ) !== -1 : ori[k] == curr.value) || curr.value == '' &#125; &#125; &#125; for ( let k in valids ) if( !valids[k] ) return false return true &#125;) // pagination data from condition filter let data = currentPage &amp;&amp; pageSize ? filterArr.slice( start_index , end_index ) : filterArr; let total = data.length, // pagination total data originTotal = origin.length; // origin total data // get all origin data when all condition is null character string. if ( isAllConditionNull )&#123; data = currentPage &amp;&amp; pageSize ? origin.slice( start_index , end_index ) : origin total = origin.length &#125; return &#123; total, originTotal, data, currentPage, pageSize, &#125;&#125; 参数说明condition [Array of Object] 条件配置该参数用来配置条件数据。 单个键配置实例： 123456&#123; key: '', //关键字，String 类型 value: '', //该关键字的值 Any 类型 fuzzy: true, //是否对该字段进行模糊匹配，Boolean 类型 daterange: false, //该字段是否为日期范围匹配，Boolean 类型&#125; origin [Array of Object] 源数据该参数表示需要进行分页的源数据。注意该源数据数组中的每一项都必须包含 condition 参数所需的 key 属性。 pagination [Object] 分页参数分页配置，可控制从第几页 currentPage 开始获取数据以及每页抓取的数据条数 pageSize。 1234&#123; currentPage: 0, pageSize: 0&#125; returns [Object]返回经过条件筛选出的新数据。 1234567&#123; data: Array of Object, // 当前页数据 originTotal： Number, // 源数据总条数 total: Number, // 分页数据总条数 currentPage: Number, // 当前页码 pageSize: Number // 每页条数&#125; 使用假设我们有如下的数据需要进行分页过滤。 12345678const originArr = [ &#123; name: 'a' , age: 18 &#125;, &#123; name: 'b' , age: 18 &#125;, &#123; name: 'c' , age: 17 &#125;, &#123; name: 'd' , age: 18 &#125;, &#123; name: 'e' , age: 19 &#125; /* ... */ ] 使用 paging 函数进行分页抓取源数据。 123456789let pagingArr = paging( [ &#123; key: 'name', value: 'c' &#125;], originArr )console.log( pagingArr )// [&#123; name: 'c' , age: 17 &#125;] 如果需要加入多个条件进行匹配，向 condition 参数添加其他要限制的过滤条件配置即可。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>分页算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seajs之define函数]]></title>
    <url>%2F2017%2F01%2F28%2FmoduleDefinition%2Fcmd%2Fseajs-define%2F</url>
    <content type="text"><![CDATA[本文介绍 seajs 的模块定义方式。 define(factory) 函数定义模块在 seajs 中，使用 define 函数来定义一个模块，其接受 id , dependencies 和一个工厂函数 factory 作为参数。其中，前两个参数可选。 12define(id?, dependencies?, factory); id 参数当前模块的唯一标识。该参数可选。如果没有指定，默认为模块所在文件的访问路径。如果指定的话， 必须是顶级或绝对标识（不能是相对标识）。 dependencies 参数当前模块所依赖的模块，是一个由模块标识组成的数组。该参数可选。如果没有指定，模块加载器会从 factory.toString() 中解析出该数组。 注意：强烈推荐不要设定 id 和 dependencies 参数。 在开发阶段，模块加载器会自动获取这两个参数。部署上线时，则可以通过优化工具来提取这两个参数。 factory 参数模块的工厂函数。模块初始化时，会调用且仅调用一次该工厂函数。factory 可以是函数， 也可以是对象、字符串等任意值，这时 module.exports 会直接设置为 factory 值。 factory 函数在调用时，会始终传入三个参数： require、exports 和 module， 这三个参数在所有模块代码里可用。 123456define(function (require, exports, module) &#123; // The module code goes here...&#125;); require 函数require 函数用来访问其他模块提供的 API。 12345678910define(function( require, exports , module )&#123; // 访问 util.js 模块 var util = require('/utils/util') // do something...&#125;) require.async 异步加载函数该方法可用来异步加载模块，并在加载完成后执行回调函数。 12345678910111213141516171819define( function(require, exports, module) &#123; // 加载一个模块 require.async('./b', function(b) &#123; b.doSomething(); &#125;); // 加载多个模块 require.async(['./c', './d'], function(c, d) &#123; // do something &#125;);&#125;); require.resolve 函数使用 require() 的内部机制来解析并返回模块路径。该函数不会加载模块，只返回解析后的路径。 require.load 函数该方法可用来异步加载脚本，并在加载完成后，执行指定的回调函数。开发插件时， 可以通过覆盖该方法来实现自定义的资源加载。 require.constructor 属性有时候，我们需要给所有 require 参数对象添加一些公用属性或方法。这时， 使用 require.constructor 来实现会非常方便。 exports 对象我们可以在 exports 对象上挂载对外的接口。 12345678910// foo.jsdefine(function( require, exports , module )&#123; exports.foo = function()&#123; console.log('this is foo module') &#125;&#125;) 如上代码所示，我们定义了一个 foo.js 模块，并向外导出了一个 foo 方法。那么，我们可以这样在其他模块中使用她： 1234567891011define(function( require, exports , module )&#123; // 引入 foo.js 模块，假设该文件在根目录下的 some 文件夹下 var foo = require('/some/foo'); // 使用 foo() 方法 foo.foo() // this is foo module&#125;) module 对象我们也可以使用 module.exports 对象向外导出接口。 123456789101112131415161718// bar.jsdefine(function( require, exports , module )&#123; // some code ... module.exports = &#123; name: 'bar', bar: function()&#123; console.log('this is ' + this.name + 'module') &#125; &#125;&#125;) 如上代码所示，我们在 bar.js 模块中导出了对象作为对外接口。我们在引用她试试： 123456789define(function( require, exports , module )&#123; // 引入 bar.js 模块，假设该文件在根目录下的 some 文件夹下 var bar = require('/some/bar') // 调用 bar.bar() // this is bar module&#125;) module.id 属性当前模块的唯一标识。 require(module.id) 必然返回此模块的 exports。 1234567define(function(require, exports, module) &#123; console.log(module.id); // http://path/to/this/file.js console.log(require(module.id) === exports); // true&#125;); module.dependencies 属性module.dependencies 是一个数组，表示当前模块的依赖列表。该数组只读：模块加载完成后，修改该数组不会有任何效果。 module.exports 对象exports 对象由模块系统创建，这不能满足开发者的所有需求， 有时候会希望 exports 是某个类的实例。 这时可用 module.exports 来实现： 12345678910define(function(require, exports, module) &#123; console.log(module.exports === exports); // true module.exports = new SomeClass(); console.log(module.exports === exports); // false&#125;); 注意，对 module.exports 的赋值需要同步执行，它不能放在回调函数里。 下面这样是不行的。 x.js 12345678910define(function( require, exports , module )&#123; setTimeOut(function()&#123; module.exports = &#123; name: 'a' &#125; &#125;)&#125;) y.js 12345678define(function( require, exports , module )&#123; var x = require('./x') console.log(x.name) // undefined&#125;) module.constructor 属性有时候，我们需要给所有 module 参数对象添加一些公用属性或方法。在这种情况下， 使用 module.constructor 可以很好地满足需求。 extend.js 12345678910111213141516// extend.jsdefine(function(require, exports, module) &#123; var Module = module.constructor; Module.prototype.filename = function() &#123; var id = this.id; var parts = id.split('/'); return parts[parts.length - 1]; &#125;;&#125;); a.js 123456// a.jsdefine(function(require, exports, module) &#123; exports.filename = module.filename();&#125;); exports 和 module 的区别sea.js 的这部分实现，借鉴了 CommonJs 规范，即 node.js 中的模块实现。也就是说，exports 只是 module.exports 的一个引用，require 函数返回的永远是 module.exports 对象。所以对于如下操作是不对的： 12345678910define(function( require , exports , module )&#123; exports = &#123; name: 'baz' &#125;&#125;) 注：不能直接对 exports 直接重新赋值，重新赋值后，exports 就不再指向 module.exports 对象了，当你 require 该模块时，其返回的永远都是 {}。]]></content>
      <categories>
        <category>模块化相关</category>
      </categories>
      <tags>
        <tag>CMD规范</tag>
        <tag>模块化</tag>
        <tag>define</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seajs之config]]></title>
    <url>%2F2017%2F01%2F27%2FmoduleDefinition%2Fcmd%2Fseajs-config%2F</url>
    <content type="text"><![CDATA[本文介绍 seajs 的配置方式。 seajs.config() 模块系统配置同样的， seajs 也可以进行配置。使用 seajs.config 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162seajs.config(&#123; // 模块加载基础路径 base: 'http://example.com/path/to/base/', // 别名配置 alias: &#123; 'es5-safe': 'gallery/es5-safe/0.9.3/es5-safe', 'json': 'gallery/json/1.0.2/json', 'jquery': 'jquery/jquery/1.10.1/jquery' &#125;, // 路径配置 paths: &#123; 'gallery': 'https://a.alipayobjects.com/gallery' &#125;, // 变量配置 vars: &#123; 'locale': 'zh-cn' &#125;, // 映射配置 map: [ ['http://example.com/js/app/', 'http://localhost/js/app/'] ], // 预加载项 preload: [ Function.prototype.bind ? '' : 'es5-safe', this.JSON ? '' : 'json' ], // 调试模式 debug: true, // 文件编码 charset: 'utf-8'&#125;) seajs.config详细说明alias [Object]当模块标识很长时，可以使用 alias 来简化。 123456789101112131415161718192021222324seajs.config(&#123; alias: &#123; 'jquery': 'jquery/jquery/1.10.1/jquery', 'app/biz': 'http://path/to/app/biz.js', &#125;&#125;);define(function(require, exports, module) &#123; var $ = require('jquery'); //=&gt; 加载的是 http://path/to/base/jquery/jquery/1.10.1/jquery.js var biz = require('app/biz'); //=&gt; 加载的是 http://path/to/app/biz.js&#125;); 使用 alias，可以让文件的真实路径与调用标识分开，有利于统一维护。 paths [Object]当目录比较深，或需要跨目录调用模块时，可以使用 paths 来简化书写。 123456789101112131415161718192021222324seajs.config(&#123; paths: &#123; 'gallery': 'https://a.alipayobjects.com/gallery', 'app': 'path/to/app', &#125;&#125;);define(function(require, exports, module) &#123; var underscore = require('gallery/underscore'); //=&gt; 加载的是 https://a.alipayobjects.com/gallery/underscore.js* var biz = require('app/biz'); //=&gt; 加载的是 path/to/app/biz.js*&#125;); paths 配置可以结合 alias 配置一起使用，让模块引用非常方便。 vars [Object]有些场景下，模块路径在运行时才能确定，这时可以使用 vars 变量来配置。 123456789101112131415161718seajs.config(&#123; vars: &#123; 'locale': 'zh-cn' &#125;&#125;);define(function(require, exports, module) &#123; var lang = require('./i18n/&#123;locale&#125;.js'); //=&gt; 加载的是 path/to/i18n/zh-cn.js&#125;); vars 配置的是模块标识中的变量值，在模块标识中用 {key} 来表示变量。 map [Array]该配置可对模块路径进行映射修改，可用于路径转换、在线调试等。 123456789101112131415161718seajs.config(&#123; map: [ [ '.js', '-debug.js' ] ]&#125;);define(function(require, exports, module) &#123; var a = require('./a'); //=&gt; 加载的是 path/to/a-debug.js&#125;); preload [Array]使用 preload 配置项，可以在普通模块加载前，提前加载并初始化好指定模块。 1234567891011121314// 在老浏览器中，提前加载好 ES5 和 json 模块seajs.config(&#123; preload: [ Function.prototype.bind ? '' : 'es5-safe', this.JSON ? '' : 'json' ]&#125;); preload 中的空字符串会被忽略掉。 注意：preload 中的配置，需要等到 use 时才加载。比如： 12345678910seajs.config(&#123; preload: 'a'&#125;);// 在加载 b 之前，会确保模块 a 已经加载并执行好seajs.use('./b'); preload 配置不能放在模块文件里面： 123456789101112seajs.config(&#123; preload: 'a'&#125;);define(function(require, exports) &#123; // 此处执行时，不能保证模块 a 已经加载并执行好&#125;); debug [Boolean]值为 true 时，加载器不会删除动态插入的 script 标签。插件也可以根据 debug 配置，来决策 log 等信息的输出。 base [String]Sea.js 在解析顶级标识时，会相对 base 路径来解析。详情请参阅 模块标识 注意：一般请不要配置 base 路径，把 sea.js 放在合适的路径往往更简单一致。 charset [String | Function]获取模块文件时，&lt;script&gt; 或 &lt;link&gt; 标签的 charset 属性。 默认是 utf-8 charset 还可以是一个函数： 1234567891011121314151617181920seajs.config(&#123; charset: function(url) &#123; // xxx 目录下的文件用 gbk 编码加载 if (url.indexOf('http://example.com/js/xxx') === 0) &#123; return 'gbk'; &#125; // 其他文件用 utf-8 编码 return 'utf-8'; &#125;&#125;); 注：多次配置自动合并，seajs.config 可以多次运行，每次运行时，会对配置项进行合并操作： 12345678910111213141516171819202122232425262728seajs.config(&#123; alias: &#123; 'jquery': 'path/to/jquery.js', 'a': 'path/to/a.js' &#125;, preload: ['seajs-text']&#125;);seajs.config(&#123; alias: &#123; 'underscore': 'path/to/underscore.js', 'a': 'path/to/biz/a.js' &#125;, preload: ['seajs-combo']&#125;); 上面两处 config 运行的结果是： 123456789101112alias = &#123; 'jquery': 'path/to/jquery.js', 'underscore': 'path/to/underscore.js', 'a': 'path/to/biz/a.js'&#125;;preload = ['seajs-text', 'seajs-combo']; 即：config 会自动合并不存在的项，对存在的项则进行覆盖。 插件的配置，插件可以给 Sea.js 添加配置项，请查看具体插件了解相关配置。 配置文件，配置可以直接写在 html 页面上，也可以独立出来成为一个文件。 12345678// seajs.config.jsseajs.config(&#123; ...&#125;); 推荐将配置文件独立成一个文件放在项目根目录，方便管理，你可以将它命名为 seajs.config.js，方便区分。]]></content>
      <categories>
        <category>模块化相关</category>
      </categories>
      <tags>
        <tag>CMD规范</tag>
        <tag>seajs.config</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seajs教程]]></title>
    <url>%2F2017%2F01%2F26%2FmoduleDefinition%2Fcmd%2Fseajs%2F</url>
    <content type="text"><![CDATA[本文介绍 require.js(AMD) 的近亲 sea.js(CMD) 的基本使用，其基于 CMD(Common Module Definition)规范。该规范明确了模块的基本书写格式和基本交互规则。 至于为什么要使用模块化管理器，这里就不再说明了，自从 require.js 出现后，前端开发再一次发生了巨大变化，让原本无模块化系统的浏览器具备了模块化的功能，页面中&lt;script&gt;标签的引用不再是瀑布式的扑面而来，各模块之间的依赖关系管理变得轻而易举。随后不久，支付宝的 玉伯 开发出了基于 CMD规范 的 sea.js，其与 require.js 有着很大的不同之处，比如 require.js 对模块文件加载方式是 预先加载 ，而 sea.js 则是 按需加载。在使用方式上也存在不同。 获取方式 从 github 下载 seajs 模块系统Sea.js 是一个适用于 Web 浏览器端的模块加载器。在 Sea.js 里，一切皆是模块，所有模块协同构建成模块系统。Sea.js 首要要解决的是模块系统的基本问题： 模块是什么？ 模块之间如何交互？ 在前端开发领域，一个模块，可以是 JS 模块，也可以是 CSS 模块，或是 Template 等模块。在 Sea.js 里，我们专注于 JS 模块（其他类型的模块可以转换为 JS 模块）： 模块是一段 JavaScript 代码，具有统一的基本书写格式。 模块之间通过基本交互规则，能彼此引用，协同工作。 把上面两点中提及的基本书写格式和基本交互规则描述清楚，就能构建出一个模块系统。对书写格式和交互规则的详细描述，就是模块定义规范（Module Definition Specification）。比如 CommonJS 社区的 Modules 1.1.1 规范，以及 NodeJS 的 Modules 规范，还有 RequireJS 提出的 AMD 规范等等。 Sea.js 遵循的是 CMD 规范，会在接下来的文档中详细阐述。 define 函数定义模块seajs 使用 define 函数来定义一个模块。 12345678define(function( require, exports , module )&#123; // 引入依赖的 foo 模块 var foo = require('/some/foo'); // do something ... module.exports = &#123; // 导出一些接口 &#125;&#125;) define() 函数的详细介绍请参考： seajs之define函数 。 对外导出接口seajs 中，对外导出接口的方式有 3 种。 使用 exports 导出接口。 123456// foo.jsdefine(function( require, exports , module )&#123; exports.hello = function()&#123; console.log('this is foo module!') &#125;&#125;) 如上所示，foo 模块向外提供了 foo.hello() 方法。 使用 module.exports 导出接口。 12345678// bar.jsdefine(function( require, exports , module )&#123; module.exports = &#123; say: function()&#123; console.log('this is bar module!') &#125; &#125;&#125;) 如上所示，bar 模块向外提供了 bar.say() 方法。 使用 return 导出接口。 还可以像 requirejs 那样，直接使用 return 向外提供接口。 123456// baz.jsdefine(function()&#123; return &#123; name: 'baz' &#125;&#125;) 如上所示，baz 模块向外导出了一个对象，其包含了一个 name 属性。 seajs.use() 方法加载指定模块seajs 使用 seajs.use 方法加载一个模块。 1seajs.use('./main') 如上代码，加载 main 模块。 seajs.config 配置seajs 也是可配置的，使用 seajs.config() 函数进行配置。 12345seajs.config(&#123; base: '/', alias: &#123;&#125; // ...&#125;) 具体的配置项信息，请参考：seajs之config。 非CMD模块处理没错，sea.js 同样会面对那些非 CMD 规范的模块引用问题，解决方式如下。 在 sea.js-2.1.0 之前的版本，可以使用 shim 插件来解决非 CMD 模块引用问题。例如：jquery，其使用的是标准的 AMD 模块定义方式，所以想要使用 sea.js 加载她，那么你必须对其进行特殊处理。 123456789// seajs.config.jsseajs.config(&#123; // 开启 shim 插件 plugins: ['shim'], alias: &#123; // 配置别名 jquery: '/assets/jquery/jquery-1.12.4' &#125;&#125;) 配置好后，便可以在其他模块使用 require() 函数通过别名 jquery 引用她。 1234define(function( require, exports, module )&#123; var $ = require('jquery'); console.log( $ )&#125;) 在 sea.js-2.1.0 之后的所有版本中，seajs 不再支持 shim 插件的用法，原因是，这种用法使得各模块之间的依赖关系变得极其复杂，代码量剧增，后期维护变得困难，为此玉伯放弃并剔除了这种用法，提出，我们可以对非 CMD 模块进行手动包装一层 define 函数再进行使用。 还是以 jquery 为例： 123456define(function()&#123; // jquery code ... return jQuery&#125;) 如此，你也可以在其他模块直接引入她。 1234define(function( require, exports , module )&#123; var $ = require('/assets/jquery/jquery-1.12.4') console.log( $ )&#125;) 看到这里，相信你跟我一样，对 seajs 的热度瞬间冰封，因为其对非 CMD 模块的支持度太低？ 没错，就是这么现实，随着大前端的不断发展，像 seajs 包括 requirejs 必然会被历史淘汰，耶稣都拉不回来，我说的！ 最佳实践在多页面应用中，每个页面都会对应一个主逻辑文件，那如果，我们每次都在 *.js 文件头部写配置信息的话，那就太蠢了。效率低下而不优雅。 所以，在项目根目录下，创建一个 seajs.config.js 文件，将配置信息写在这个文件中。当然，文件名你可以随便定义，最好能够区分她是谁的配置文件。 对于多页应用来说，通常我们会有如下项目结构： 123456789101112131415161718192021|-www/| |-assets| | |- seajs| | |- sea.js| | |- jquery| | |- jquery.js| | |- ...| |-pages| | |- login| | |- login.html| | |- login.js| | |- demo| | |- demo.html| | |- demo.js| |-utils| | |- dom.js| |-style| |-seajs.config.js| |-README.md... 那么我们会这样使用模块化。 demo.html 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; this is demo page &lt;/div&gt;&lt;script src="/assets/seajs/sea.js"&gt;&lt;/script&gt; &lt;!-- 引入sea.js --&gt;&lt;script src="/seajs.config.js"&gt;&lt;/script&gt; &lt;!-- 引入seajs的配置文件 --&gt;&lt;script&gt; seajs.use('../pages/demo/demo') //页面的主入口文件&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; seajs.config.js 1234567891011seajs.config(&#123; base: "/assets", alias: &#123; jquery: "jquery/jquery", dom: "../utils/dom" &#125; // ...&#125;) demo.js 12345678910define(function( require , exports , module )&#123; //该 主程序文件 依赖于 2个 模块 ， 分别是 jquery, dom var $ = require('jquery'); var dom = require('dom'); //其中 dom 为 自己定义的 模块 // some code here...&#125;)]]></content>
      <categories>
        <category>模块化相关</category>
      </categories>
      <tags>
        <tag>CMD规范</tag>
        <tag>模块化</tag>
        <tag>seajs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requirejs教程]]></title>
    <url>%2F2017%2F01%2F11%2FmoduleDefinition%2Famd%2Frequirejs%2F</url>
    <content type="text"><![CDATA[随着前端项目的不断增大，js 文件越来越多，大部分都是 js 的依赖模块，传统的引入方式已经无法满足当前开发需求，急需模块化的方案来替我们管理这些依赖。但，javascript 天生并不支持模块化，无法将多个模块文件分离出去，在使用时再将多个模块合并起来。事情总是需要解决，也总是不缺乏造轮子的人。于是，前端模块化的始祖，require.js 出现了，其基于 AMD 规范。使用 define 函数定义模块，利用 require 函数 导入模块。详细使用方式请继续往下看。 获取方式 官方地址: https://requirejs.org/ github: https://github.com/requirejs/requirejs 为什么要使用 require.js?最早的时候，所有 Javascript 代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。 123456 &lt;script src="1.js"&gt;&lt;/script&gt; &lt;script src="2.js"&gt;&lt;/script&gt; &lt;script src="3.js"&gt;&lt;/script&gt; &lt;script src="4.js"&gt;&lt;/script&gt; &lt;script src="5.js"&gt;&lt;/script&gt; &lt;script src="6.js"&gt;&lt;/script&gt; 这段代码依次加载多个 js 文件。 这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于 js 文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js 要在 2.js 的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 require.js 的诞生，就是为了解决这两个问题： 123（1）实现js文件的异步加载，避免网页失去响应。（2）管理模块之间的依赖性，便于代码的编写和维护。 模块加载规则RequireJS 以一个相对于 baseUrl 的地址来加载所有的代码。 即 baseUrl + paths 的解析过程。 baseUrl的确定规则 以含有 data-main 属性的 script 的 html 页面所在文件目录为 baseUrl。 页面顶层 &lt;script&gt; 标签含有一个特殊的属性 data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。 以 paths 配置为准。(下面会介绍如何配置) 注：RequireJS 默认假定所有的依赖资源都是 js 脚本，因此无需在 module ID 上再加 .js 后缀，RequireJS 在进行 module ID 到 path 的解析时会自动补上后缀。你可以通过 paths config 设置一组脚本，这些有助于我们在使用脚本时码更少的字。 有时候你想避开 baseUrl + paths 的解析过程，而是直接指定加载某一个目录下的脚本。此时可以这样做：如果一个 module ID 符合下述规则之一，其ID解析会避开常规的 baseUrl + paths 配置，而是直接将其加载为一个相对于当前 HTML 文档的脚本： 1231. 以 ".js" 结束.2. 以 "/" 开始.3. 包含 URL 协议, 如 "http:" or "https:". 文件结构 123456789101112|-www/| |-libs| | |- require.js| | |- jquery.js| | |- layer.js| |-utils| | |- dom.js| |-pages| | |-login| | | |- login.html| | | |- login.js| |-style login.html 123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script data-main="./login.js" src="/libs/require.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dom.js该模块导出了一个对象。12345define(function()&#123; return &#123; name: "dom module" &#125;&#125;) login.js 在 login.js 中，引用了 dom 模块，此时，baseUrl 为 login.html 所在的目录。所以，要想找到 dom.js，需要连跳两层文件夹，再进入 utils文件夹。 123require(['../../utils/dom'] , function( dom )&#123; console.log( dom.name ) // dom module&#125;) 这里有个需要注意的地方，如果你引用了那些定义了 模块名 的文件，是无法保证主逻辑文件和依赖文件的加载顺序的，也就是说，你很有可能获取不到依赖文件导出的变量。例如 jquery.js ，其内部 定义模块时，加上了模块名参数 jquery。 123define("jquery" , function()&#123; // ...&#125;) 基于这种情况，require.js 会根据 paths 配置查找文件路径 (关于配置下面会介绍)。如果没有配置 paths 的话，require.js 只会简单的将该依赖文件通过含有 async 属性的 &lt;script&gt; 标签加载到 &lt;head&gt; 中，并不会处理文件之间的依赖关系。所以，当你引用一个含有模块名定义的依赖，又没有为其配置 paths 时，就会出现如下状况： 1234// login.jsrequire(['../../libs/jquery'] , function($)&#123; console.log( $ ) // undefined&#125;) 所以此时，我们需要对依赖进行配置 paths： 12345678910111213141516171819// login.jsrequire.config(&#123; baseUrl: "/libs", paths: &#123; jquery: "jquery" &#125;&#125;)require(['jquery'] , function($)&#123; console.log( $ ); /* ƒ ( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery… */ &#125;) 现在，我们就可以拿到 jquery 导出的全局变量 $ 了。 API介绍data-main属性指定页面主逻辑文件的的路径，它有点像 c语言 中 main()函数，所有的代码都从这开始运行。同时，它也默认确定了 baseUrl 的值为当前页面所在的目录。 require.config()配置方法require.config.js文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546require.config(&#123; //配置模块的基本路径 //当在服务器模式下时，如果不使用 `/` 开头指定模块别名的路径的话，即当前的路径环境就是 根目录下的 assets 文件夹下 //通常，多页面开发中，我们将第三方资源放在 assets 文件夹中 baseUrl: '/assets', //配置模块别名,也可以称作路径别名 //当配置 baseUrl 属性的 时候 ， 此时就不需要加上 `/assets/` 了 // requirejs 会自动帮你拼上，同时，其默认处理的就是 js 文件，所以文件的 .js 后缀也不需要加。 paths : &#123; jquery : 'jquery/jquery.min' //资源地址除了上面的 字符串格式，还可以是 数组格式，如： //其作用是：优先加载远程资源，当加载不成功时，则加载本地资源文件 bootstrap : ['https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js' , 'bootstrap/bootstrap.min' ], foo : '../js/foo' // 配置一个自己定义的模块 //... &#125;, //处理不支持AMD模块化的第三方依赖 //比如 bootstrap ，其不支持 AMD 规范 ，即其没有使用 define 函数进行模块定义 //随后进行 define 函数 的 使用说明 shim : &#123; //需要 shim (垫) 的模块 ， 上方已配置了 路径别名 bootstrap : &#123; //配置依赖项 deps : ['jquery'], //配置导出变量名 exports : 'bootstrap' &#125; //... &#125; //其他配置项 // ... &#125;)// 至此，require.config.js 配置文件的配置就 基本完成了 ，当要引入其他模块时，继续配置即可。// 支持AMD规范的 只需在 path 字段中 加个 配置 ， 不支持 AMD 规范的 再在 shim 字段中 垫 一下即可。 define() 函数AMD 规范要求 ，定义一个模块时 ，必须使用 define() 函数 来进行模块的 定义。 define 函数的参数说明 在定义一个模块时，其实 define 函数 接受 3个 参数。 参数1 : String类型，定义该模块的名字(一般不会写这个参数，使用路径的方式引用模块更易控)参数2 : Array类型，该模块依赖，使用配置好的路径别名 或 路径参数3 : callback, 该模块的主逻辑体 ， callback 回调函数的 可接收 一些参数，这些参数就是 该模块的依赖项所导出的模块变量值得注意的是，你需要按照 参数2 模块依赖 数组中参数的顺序来 配置 回调函数 的 形参顺序。 @returns : 任意类型，指定定义模块导出的接口。 例： 定义了一个 foo 模块，该模块依赖于 jquery输出打印了一些信息导出了一个对象 1234567define(['jquery'] , function($)&#123; console.log($) console.log('这是foo模块') return &#123; name: "foo"&#125; // 导出接口&#125;) require() 函数有定义，就有引用，AMD规范中，使用 require() 函数 来引用模块。 require 函数的参数说明 参数1 : Array类型，模块依赖参数2 : callback , 主体逻辑 例： 123require(['jquery' , 'foo'] , function( $ )&#123; // your main logic code ...&#125;); 最佳实践在多页面应用中，每个页面都会对应一个主逻辑文件，那如果，我们每次都在 *.js 文件头部写配置信息的话，那就太蠢了。效率低下而不优雅。 所以，在项目根目录下，创建一个 require.config.js 文件，将配置信息写在这个文件中。当然，文件名你可以随便定义，最好能够区分她是谁的配置文件。 对于多页应用来说，通常我们会有如下项目结构： 12345678910111213141516171819202122|-www/| |-assets| | |- requirejs| | |- require.js| | |- jquery| | |- jquery.js| | |- ...| |-pages| | |- login| | |- login.html| | |- login.js| | |- demo| | |- demo.html| | |- demo.js| |-utils| | |- dom.js| |-style| |-require.config.js| |-README.md... 那么我们会这样使用模块化。 demo.html12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; this is demo page &lt;/div&gt;&lt;script src="/assets/requirejs/require.js"&gt;&lt;/script&gt; &lt;!-- 引入require.js --&gt;&lt;script src="/require.config.js"&gt;&lt;/script&gt; &lt;!-- 引入requirejs的配置文件 --&gt;&lt;script&gt; require(['../pages/demo/demo']) //页面的主入口文件&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; require.config.js 123456789require.config(&#123; baseUrl: "/assets", paths: &#123; jquery: "jquery/jquery", dom: "../utils/dom" &#125; // ...&#125;) demo.js 12345require(['jquery' , 'dom'] , function($ , dom)&#123; //该 主程序文件 依赖于 2个 模块 ， 分别是 jquery, dom //其中 dom 为 自己定义的 模块 // some code here...&#125;) 也许你会想，哇！这不还是加载了 3 个 script 标签引用吗？ -- || 当你有 100 个 js 文件依赖时，你就不会这么想了！不信你可以试试。祝你好运！ 兼容性12345IE 6+ .......... 兼容 ✔Firefox 2+ ..... 兼容 ✔Safari 3.2+ .... 兼容 ✔Chrome 3+ ...... 兼容 ✔Opera 10+ ...... 兼容 ✔ 结束语这篇文章仅记录 require.js 的简单使用，可以帮助你快速入门，一般项目开发足够了，需要更多有关 require.js 的信息，可以翻阅 requirejs 官网 。]]></content>
      <categories>
        <category>模块化相关</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>AMD规范</tag>
        <tag>requirejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery队列操作案例]]></title>
    <url>%2F2016%2F07%2F06%2Fjquery%2Fdocs%2Fjquery-queue%2F</url>
    <content type="text"><![CDATA[由于页面中动态数据较多，比如动态ajax获取下拉框option数据，当页面中需要对select元素进行操作时，其DOM操作必须后与select框数据渲染完成后，此时队列操作至关重要。使得异步操作同步化。 实现1234567891011121314151617/** 初始化队列函数* @fnarr 函数数组，异步执行的代码块集合* @name 队列名**/function initQueue(name , fnarr)&#123; $(document).queue( name , fnarr); dequeue( name );&#125;/** 出队函数* @name 队列名*/function dequeue(name)&#123; $(document).dequeue( name );&#125; 调用方式1234567891011121314151617181920212223242526272829//定义函数数组var fnarr = [ function()&#123; console.log("action one"); dequeue("myqueue"); //出队操作，保证下一排队函数可继续执行 &#125;, function()&#123; console.log("action two"); dequeue("myqueue"); &#125;, // more action ... function()&#123; console.log("action three"); //所有异步操作结束后,执行页面主函数 main(); &#125; ];//激活队列initQueue("myqueue" , fnarr);function main()&#123; //这是页面主函数&#125;]]></content>
      <categories>
        <category>jquery相关</category>
      </categories>
      <tags>
        <tag>queue</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery核心]]></title>
    <url>%2F2016%2F05%2F26%2Fjquery%2Fdocs%2Fjquery-core%2F</url>
    <content type="text"><![CDATA[记录jQuery 的核心知识。 jQuery框架结构代码12345678910111213141516171819202122232425262728293031323334//1.函数自调用，防止内部变量泄露，污染全局中的其他变量，将window作为实参传入，方便代码压缩 (function(window)&#123; //3.定义工厂函数 jQuery var jQuery = function()&#123; //4.这里面封装了构造函数init,将通过new关键字创建jQuery实例对象的方法返回 return new jQuery.fn.init(); &#125; //5.jQuery中封装的所有功能方法都会绑定在jQuery 的原型对象上，这样jQuery 的实例对象可以使用这些方法和属性。并且给jQuery的原型对象取了个别名: jQuery.fn。 jQuery.fn = jQuery.prototype = &#123; constructor: jQuery // 为了不破坏原型链，指回了jQuery 工厂函数 //jQuery 的 各种功能方法在此封装 &#125; //6.定义 构造函数 init var init = jQuery.fn.init = function()&#123; &#125; //7.为了方便以后扩展插件功能，共享原型 //将构造函数init的prototype 指向 工厂函数jQuery的 prototype init.prototype = jQuery.fn; //2.将jQuery工厂函数暴露到全局中，$ 是 jQuery 的别名，方便用户使用 window.jQuery = window.$ = jQuery; &#125;)(window); jquery框架设计结构图 jQuery中的extend方法jq中的extend的方法来给工厂函数jQuery以及jQuery的原型对象扩展方法（给jq实例扩展方法）。 实现原理： 12345678910111213141516171819//首先给jQuery的原型和工厂函数jQuery添加extend方法 jQuery.fn.extend = jQuery.extend = function(obj)&#123; for(var k in obj)&#123; if(obj.hasOwnProperty(k))&#123; //判断属性k是不是obj 自身的，而不是原型链上的 this[k] = obj[k]; //谁调用给谁添加属性K &#125; &#125; &#125;// 注：for...in 遍历会遍历原型链上的属性和方法，消耗性能 jQuery.extend(&#123; toArray : function()&#123; //给jQuery工厂函数扩展方法 alert("hello"); &#125; &#125;); jQuery插件的扩展原理型123456//原理：给 $ 或 jQuery函数的原型对象添加属性和方法。//例：$.prototype.accordion = function()&#123;...&#125; jQuery对象jQuery对象是一个伪数组，通过$(selector)获取到的对象是JQuery对象，这个对象里存储了length个dom对象。 ###jQuery对象和dom对象 通过Jquery获取页面元素得到的对象就是jquery对象。而dom对象是通过js获取页面元素得到的对象。 jQuery对象是一个对象，它是一个包装集, 包装了很多 dom 对象的集合。 jQuery对象不能直接调用dom对象的方法，我们可以通过两种方法获取到jQuery对象包装集里的dom对象，来调用dom对象的方法。 方法1：通过下标的方式 12var lis = ("li");$lis[0].style.backgroundColor = "red"; 方法2：利用get()方法 12var lis = ("li");$lis.get(0).style.backgroundColor = "red"; dom对象转jq对象方法： 将dom对象丢进$() 中。 dom对象不能直接调用jQuery对象的方法，我们可以将dom对象转换成jQuery对象再使用。 例： 12var cloth = document.getElementById("cloth");$(cloth).text("我是通过jQuery设置的文本内容"); ###jQuery对象中的实例成员和静态成员 1.静态成员 绑定在构造函数上的属性和方法，供构造函数自己使用。此时的构造函数作为对象来理解。 2.实例成员 设置在构造函数体中的属性和方法以及构造函数原型上的属性和方法，供构造函数创建的实例对象使用。 例： 1234567891011function Person()&#123; name = "elen"; // 实例成员 age = 18; // 实例成员&#125;Person.prototype.say = function()&#123; // 实例成员 alert("hello");&#125;Person.sex = "male"; // 静态成员 ###jQuery实例对象的方法 方法 说明 index() 作用：求元素的索引值语法：index(obj)参数：obj : dom对象1. 不传参数：表示返回该元素在兄弟元素中的索引值 2. 传参数：表示返回在dom对象这个集合中对应的索引值 each() 作用：以每一个匹配的元素作为上下文来执行一个函数。即遍历操作dom元素。 意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。 返回 ‘false’ 将停止循环 (就像在普通的循环中使用 ‘break’)。返回 ‘true’ 跳至下一个循环(就像在普通的循环中使用’continue’)。语法：each(function(index, ele){…})注：实例方法each() 实际上用的就是jq的静态成员方法each()源码如下：each : function(callback){ return jQuery.each(this, callback);}终止循环遍历使用 return false size() 返回jQuery对象中元素的个数 get() 这能够让你选择一个实际的DOM 元素并且对他直接操作，而不是通过 jQuery 函数。$(this).get(0)与$(this)[0]等价。语法：$(selector).get(index)参数：index 索引值返回值：返回jq对象（伪数组）中索引为index的dom对象不传参时返回的由dom对象组成的伪数组 ###jQuery对象的属性 属性 说明 length jQuery 对象（伪数组）中元素的个数。 ###jQuery对象中的静态成员方法 绑定在工厂函数jQuery上的方法。 方法 说明 each() 作用：遍历对象语法：$.each(obj, function(index, element){})参数：obj 要遍历的对象（数组，对象，伪数组）index 索引值element 元素的值返回值：遍历的对象obj注：1.执行时，回调函数中的this 指向遍历的每一个值（element）2.如果想中断遍历，在回调函数中return false 即可3.each返回遍历的对象，即会将obj 又返回 ###静态成员方法each()的封装 123456789101112131415161718192021function each(obj, callback)&#123; // 如果obj 是数组或伪数组 if("length" in obj)&#123; for ( var i = 0; i&lt; obj.length ; i++)&#123; if( callback.call (obj[i], i , obj[i] ) === false ) &#123; break; &#125; &#125; &#125;else&#123; //如果obj是对象 for(var k in obj)&#123; if ( callback.call( obj[k], k, obj[k] ) === false)&#123; break; &#125; &#125; &#125;&#125; ​ ​]]></content>
      <categories>
        <category>jquery相关</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery语法标准]]></title>
    <url>%2F2016%2F05%2F22%2Fjquery%2Fdocs%2Fjquery-standard%2F</url>
    <content type="text"><![CDATA[jQuery基本语法记录。 多库共存jQuery 函数 可以使用 $ 和 jQuery 两个变量来调用。 1noConflict() 作用：释放 jQuery中 $ 的使用，使用户有能力将 $ 改变为其他代替字符。 用法1 jQuery文件引入在下，其他库文件在上时 1234var jq = $.noConflict();jq(function()&#123; some jq code here...&#125;); 用法2：jQuery文件引入在上，其他库文件在下时 1234567var jq = jQuery.noConflict();jq(function()&#123; some jq code here...&#125;); jQuery选择器 基本选择器 语法 id选择器 $(&quot;#box&quot;).action() 类选择器 $(&quot;.hwq&quot;).action() 标签选择器 $(&quot;li&quot;).action() 并集选择器 $(&quot;#box,.hwq,li&quot;).action() 交集选择器 $(&quot;li.hwq&quot;).action() 上面的功能跟css选择器的用法一模一样。 层级选择器 描述 子代选择器 $(&quot;#box &gt; p&quot;).action() 选择的 #box 的直接子代 p，不包括孙子元素 p 后代选择器 $(&quot;#box p&quot;).action() 选择的是 #box 的所有后代 p ，包括所有的孙子元素 p 过滤选择器 :eq() 语法：$(&quot;li:eq(index)&quot;).action() index：表示索引值 作用：表示选择索引为 index 的那个 li 标签元素 :odd 语法：$(&quot;li:odd&quot;).action() 作用：选择索引值为 奇数 的 li标签元素 :even 语法：$(&quot;li:even&quot;).action() 作用：选择索引值为 偶数 的li标签元素 注：当获取的元素对象是一个伪数组时，给这个维数组添加 action() 操作时，JQuery 会进行隐式迭代，即 JQ 会自动遍历这个维数组里的 dom 对象，并给每一个 dom 对象进行 action() 操作。 筛选方法查找 方法 描述 children(&quot;selector&quot;) 语法：$(&quot;li&quot;).chlidren(&quot;ul&quot;).action() 参数：selector 表示选择器 作用：找 li 的直接子元素（不包括孙子元素），并且这个子元素的标签类型是 ul find(&quot;selector&quot;) 语法：$(&quot;#box&quot;).find(&quot;li&quot;).action() 参数：selector 表示选择器 作用：找 #box 的所有后代元素（包括孙子元素），并且这个后代元素标签类型是 li siblings(&quot;selector&quot;) 语法：$(&quot;li&quot;).siblings(&quot;.prev&quot;).action() 参数：selector 表示选择器 作用：找 li 的所有兄弟元素，并且这个 li 带有 .prev 类名 next(&quot;selector&quot;) 语法：$(&quot;span&quot;).next(&quot;.sel&quot;).action() 参数：selector 表示选择器 作用：找到每个 span 的之后紧邻的一个兄弟元素，并且这个兄弟元素带 .sel 类名。通常不用加这个类名限定。 prev(&quot;selecto&quot;) 语法：$(&quot;span&quot;).prev(&quot;.sel&quot;).action() 参数：selector 表示选择器 作用：找到每个 span 紧邻的前一个同辈元素中类名为sel的元素。 nextAll(&quot;selector&quot;) 语法：$(&quot;span&quot;).nextAll(&quot;.sel&quot;).action() 作用：找 span 标签之后的所有含有 .sel 类名的兄弟元素 prevAll(&quot;selector&quot;) 语法：$(&quot;span&quot;).prevAll(&quot;.sel&quot;).action() 作用：找 span 标签之前的所有含有 .sel 类名的兄弟元素 parent(&quot;selector&quot;) 语法：$(&quot;li&quot;).parent(&quot;.selector&quot;).action() 作用：查找 li 的父元素且类名为 .selector 过滤 方法 描述 eq(index) 语法：$(&quot;li&quot;).eq(index).action() 参数： index 一个正整数时，指示元素基于 0 的位置，这个元素的位置是从0 算起。 -index 一个负整数时，指示元素的位置，从集合中的最后一个元素开始倒数。(1算起) 作用：获取第 n 个元素 效果在所有效果操作中，除非设置了 speed 参数，否则不能设置callback参数。 v1.4.3 及以上版本才有 Easing 参数。 show() 显示元素​显示已隐藏的元素，对于设置了 display:none 或 使用了 hide() 方法的元素都有效。 在设置速度的情况下，元素从隐藏到完全可见的过程中，会将 display 设置为 bolck 并逐渐地改变其高度、宽度、外边距、内边距和透明度。 语法：$(selector).show( speed, easing , callback) 参数： speed 设置完成显示效果的时间，比如 “slow”, “fast”, “normal” 或毫秒数 easing 字符串类型，显示效果的动画曲线，默认是 “swing”，可用参数 “linear”。v1.4.3 及以上版本才有此参数。 callback 回调函数，显示效果完成后执行的动作，除非设置了 speed 否则不能使用该参数。 hide()隐藏元素​隐藏已显示的元素，对于设置了 display:block 或 使用了 show() 方法的元素都有效。 在设置速度的情况下，元素从可见到完全隐藏的过程中，会将 display 设置为 none 并逐渐地改变其高度、宽度、外边距、内边距和透明度。 语法：$(selector).hide( speed, easing , callback) 参数： speed 数字类型，设置完成隐藏效果的时间，毫秒数 easing 字符串类型，隐藏效果的动画曲线 callback 回调函数，隐藏效果完成后执行的动作 toggle()显示隐藏切换toggle 方法 会隐藏显示的元素，显示隐藏的元素。 语法：$(selector).toggle(speed, easing , callback) 参数： speed 数字类型，设置完成效果的时间，毫秒数 easing 字符串类型，效果的动画曲线 callback 回调函数，效果完成后执行的动作 fadeIn()淡入显示fadeIn方法会对元素的 opacity 属性和 display 属性进行渐变设置，即首先将 display 设置为 block，然后逐渐将 opacity 设置为 1 。 语法：$(selector).fadeIn(speed , easing , callback ) 参数： speed 数字类型，效果完成的时间，毫秒数 easing 字符串类型，效果的动画曲线 callback 回调函数，效果完成后的动作 fadeOut()淡出隐藏fadeOut 方法会对元素的 opacity 属性和 display 属性进行渐变设置，即首先将 display 设置为 none，然后逐渐将 opacity 设置为0。 语法：$(selector).fadeOut(speed , easing , callback ) 参数： speed 数字类型，效果完成的时间，毫秒数 easing 字符串类型，效果的动画曲线 callback 回调函数，效果完成后的动作 fadeToggle()淡入淡出切换对已显示的元素进行淡出隐藏，已隐藏的元素进行淡入显示。 语法：$(selector).fadeToggle(speed , easing , callback ) 参数： speed 数字类型，效果完成的时间，毫秒数 ​easing 字符串类型，效果的动画曲线 ​callback 回调函数，效果完成后的动作 fadeTo()渐变元素的不透明度语法：$(selector).fadeTo(speed, opacity , callback ) 参数： speed （必需）效果过渡的时间，单位为毫秒数 ​opacity （必需）渐变至的不透明度（0-1） ​callback （可选）回调函数，渐变效果结束后执行的动作 slideDown()下拉显示将已隐藏的元素以下拉的方式显示，会将 display:none 的元素属性 display 设置为 block。 语法：$(selector).slideDown(speed , easing , callback ) 参数： speed 数字类型，效果完成的时间，毫秒数 ​easing 字符串类型。效果的动画曲线 ​callback 回调函数，效果完成后执行的动作 slideUp()上拉隐藏将已显示的元素以上拉的方式隐藏，会将 display:block 的元素属性 display 设置为 none。 语法：$(selector).slideUp(speed , easing , callback ) 参数： speed 数字类型，效果完成的时间，毫秒数 ​easing 字符串类型。效果的动画曲线 ​callback 回调函数，效果完成后执行的动作 slideToggle() 上拉下拉切换将已隐藏的元素以下拉的方式显示，已显示的元素以上拉的方式隐藏。 语法：$(selector).slideToggle(speed , easing , callback ) 参数： speed 数字类型，效果完成的时间，毫秒数 ​easing 字符串类型。效果的动画曲线 ​callback 回调函数，效果完成后执行的动作 自定义动画animate我们可以利用 jquery 的 animate 函数制作自定义动画。给同个元素设置的多个animate 动画会被 push 进叫做 fx 的标准动画队列中。 语法：$(selector).animate( {params}, speed , easing , callback ) 参数： {params} ： 对象类型，定义元素结束位置的样式状态 speed : 数字类型，设置元素过渡的时间，单位为毫秒数 easing : 动画曲线，支持 easing.js 插件 callback : 回调函数，定义动画结束后执行的操作（代码块） 注： （1）默认的：元素是静态定位，需要手动设置元素定位为：relative /absolute /fixed 才会有移动效果 （2）animate() 可以使用队列功能，即你可以对同个元素使用多个animate() 定义不同的状态，她会逐步的执行它们。 （3）当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 （4）也可以对css属性定义相对值（该值相对于元素的当前值）。 需要在值的前面加上 += 或 -= ，使用相对值时，必须加上单位px，以字符串的形式设置。 （5）可以把属性的动画值设置为 “show”、”hide” 或 “toggle”。 （6）设置属性值时，如果带上px单位，使用引号包裹，不想带px 直接写数字即可。 例： 12345678910111213141516$(".btn").click(function()&#123; var box = $(".box"); box.animate( &#123;left:"+=200px"&#125; , 1000); box.animate( &#123;top: "+=200px" &#125; , 1000); box.animate( &#123;fontSize:"20px"&#125; , 1000); box.animate( &#123;left:"+=200px"&#125; , 1000); box.animate(&#123;top : 100 &#125;, 1000 );&#125;); stop()停止动画或效果停止当前正在运行的动画。 语法：$(selector).stop( stopAll , gotoend ) 参数： stopAll 布尔类型，是否停止被选元素的所有加入队列的动画。默认值为 false 即表示不清除动画队列中的动画，true 表示清除。 gotoend 布尔类型，规定是否允许在清除动画队列中的动画后完成当前的动画。该参数只能在设置了 stopAll 参数时使用。默认值为 false，即表示不完成，true 表示要完成。 delay()延迟动画设置一个时间来推迟队列后动画的执行。 语法：$(selector).delay( duration , queuename ).fadeIn(200) 参数： duration 延迟时间 queuename 队列名，默认是Fx（动画队列） finish()当.finish()在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值（所有动画的目标值）。所有排队的动画将被删除。 .finish()方法和 .stop(true, true) 很相似，.stop(true, true) 将清除队列，并且当前的动画跳转到其最终值。但是，不同的是，.finish() 会导致所有排队的动画的 CSS 属性跳转到他们的最终值。 语法：$(selector).finish( queue ) 参数： queue 停止动画队列的名称 控制队列queue()queue() 方法返回被匹配元素上排队动画的个数，或操作在匹配元素上执行的函数队列。 当通过 .queue() 添加函数时，我们应当确保最终调用了 .dequeue()，这样下一个排队的函数才能执行。 语法1：$(selector).queue( queuename ) 参数： queue 队列名，字符串值，包含序列的名称。默认是 fx，标准的效果序列。 返回值： 数组类型，存储了动画队列中函数。 例： 1234567891011121314151617181920212223242526272829$("#show").click(function () &#123; var n = $("div").queue("fx"); // 返回值类型为数组 $("span").text("Queue length is: " + n.length);&#125;);function runIt() &#123; $("div").show("slow"); $("div").animate(&#123;left:'+=200'&#125;,2000); $("div").slideToggle(1000); $("div").slideToggle("fast"); $("div").animate(&#123;left:'-=200'&#125;,1500); $("div").hide("slow"); $("div").show(1200); $("div").slideUp("normal", runIt);&#125;runIt(); 语法2：$(selector).queue( fn ) 参数： fn 向匹配元素的标准动画队列最后添加的函数，该函数中可以设置一些其他的动画效果。 例： 1234567891011$("div").animate(&#123;left:'-=200'&#125;,500);$("div").queue(function () &#123; $(this).removeClass("newcolor"); $(this).dequeue();&#125;);$("div").slideUp(); dequeue()dequeue()的定义是”删除队列中最顶部的函数，并且执行它”。这样函数队列中的下一个函数才能继续执行。 语法：$(selector).dequeue( queuename ) 参数： queuename （可选）队列名，默认为fx，即标准动画队列。 例：使用 dequeue() 终止一个自定义的队列函数 1234567$("div").queue(function () &#123; $(this).toggleClass("red"); $(this).dequeue();&#125;); queue和dequeue配合使用当需要对不同的元素做连续动画或效果时，除了使用回调地狱这样的冗余嵌套外。我们还可以使用操作元素的动画队列来实现连续的动画和效果。 例：当我们需要在 A元素出现后（可以添加一系列其他动画），B元素再出现以及做些其他动画效果。这时我们没有必要写冗余的回调函数，直接操作A元素的标准动画队列 fx 即可。 即给A元素的动画队列的尾部添加一个操作B元素的动画函数，就可以实现不同元素之间的连续动画或效果。 如果是通过触发事件的方式来开始动画，不想同一系列动画重复执行，可以在 queue 中定义的动画函数里不加 dequeue()，这样动画就只会触发一次。或者你可以写dequeue()，只要对动画做节流处理即可。 代码如下： 123456789&lt;body&gt;&lt;div class="A"&gt;&lt;/div&gt;&lt;div class="B"&gt;&lt;/div&gt;&lt;button&gt;显示&lt;/button&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738 $(function()&#123; // 在有dequeue的情况下，重复触发click会向 A 的动画队列中加入很多待执行动画 $("button").click(function()&#123; $(".A").show(300); $(".A").animate(&#123;left : 200 &#125;); $(".A").queue(function()&#123;//向.A元素的动画队列的最后添加一个动画：让.A显示 $(".B").show(800);//在队列函数中，我们可以控制其他的元素进行动画，并且有连续帧的效果 $(".B").animate(&#123;left:100&#125;,1000); console.log("B"); //显示.A的动画函数完成后dequeue，让之后的动画队列中的函数继续执行$(".A").dequeue(); // 不加此句，动画就不会重复触发 &#125;); console.log("A"); $("A").animate(&#123; left : 0&#125;,800); &#125;); &#125;); clearqueue()当调用 .clearQueue() 方法时，序列中未被执行的所有函数都会被从序列中删除。如果不使用参数，则 .clearQueue() 从 fx（标准效果序列）中删除剩余的函数。在这种方式中，它类似于 .stop(true)。不过，.stop() 方法只用于动画，而 .clearQueue() 也可用于删除通过 .queue() 方法添加到通用 jQuery 序列的任何函数。 语法：$(selector).clearqueue(ueuename) 参数： ueuename 队列名，默认为 fx，即标准动画队列。 例：清空队列 1$("div").clearQueue(); next()我们还可以使用v1.4以上版本提供的 next()方法让队列中函数继续执行下去。 例： 123456789$('div').slideUp('slow').queue(function(next)&#123; $('#object').css(&#123;"background":"red"&#125;); next();&#125;);$("div").show(); 自定义函数队列语法1：$(selector).queue( queuename , callback(next) ) 参数： queuename string类型，队列名 callback(next) 回调函数，函数体内定义你需要的功能，这么定义的队列，队列里就只有一个函数，如果需要多个函数，可以用函数数组作为第二个参数。 123456789$("div").queue("custom", function(next) &#123; $('div').css(&#123;'background':'red'&#125;); next();&#125;).dequeue("custom"); //this is the key 语法2：$(selector).queue( queuename , fnArray) 参数： queuename 函数队列名。 fnArray 函数数组，数组中的每个元素是一个函数，作为自定义的函数队列中的每个成员。 例：要两个div依次向左移动 12345678910111213141516171819202122232425262728293031var FUNC=[ function() &#123;$("#block1").animate(&#123;left:"+=100"&#125;,aniCB);&#125;, //每次执行完一个函数后执行回调函数aniCB，即执行一次dequeue() 使得队列能继续下去 function() &#123;$("#block2").animate(&#123;left:"+=100"&#125;,aniCB);&#125;, function() &#123;$("#block1").animate(&#123;left:"+=100"&#125;,aniCB);&#125;, function() &#123;$("#block2").animate(&#123;left:"+=100"&#125;,aniCB);&#125;, function() &#123;$("#block1").animate(&#123;left:"+=100"&#125;,aniCB);&#125;, function()&#123;alert("动画结束")&#125; ]; var aniCB=function() &#123; // 定义回调函数，调用一次即触发一次dequeue()方法 $(document).dequeue("myAnimation"); &#125; $(document).queue("myAnimation",FUNC); //自定义一个函数队列 aniCB(); //开始执行队列中的第一个函数 1，首先建议建立了一个函数数组，里边是一些列需要依次执行的动画 2，然后定义一个函数，用dequeue方法用来执行队列中的下一个函数 3，接着把这个函数数组放到document上的myAnimation的队列中（可以选择任何元素，我只是为了方便而把这个队列放在document上） 4，最后我开始执行队列中的第一个函数 这样做的好处在于函数数组是线性展开，增减起来非常方便。 而且，当不要要继续进行接下来动画的时候(比如用户点了某个按钮)，只需要清空那个队列即可。而要增加更多则只需要加入队列即。 1234567//清空队列 $(document).queue("myAnimation",[]); //加一个新的函数放在最后 $(document).queue("myAnimation",function()&#123;alert("动画真的结束了！")&#125;); jQuery基本操作css操作css()方法可以设置单个样式或者设置多个样式。 设置单个样式： 语法： 1$(selector).css(name,value) 参数： name：string类型，表示css属性名。属性名的写法支持原本的css属性名写法和驼峰命名法。如font-size 和 fontSize 都可以。 value： string类型，表示css属性值。 例： 1$("li").css("color","red"); 设置多个样式： 利用对象传参即可 语法：$(selector).css(obj) 例： 1234$("li").css(&#123; background: "red", fontSize: "20px"&#125;); 获取css样式值： 语法：$(“el”).css(name) 参数： name 样式名 返回值： 样式名为 name 的样式值，当获取到的对象是一个维数组时，返回的则是第一个对象的样式值。 class操作1.添加类名 语法：$(selector).addClass(name) 参数： name 要添加的类名 例： 1$("li").addclass("on"); //不需要加. 2.删除类名 语法：$(selector).removeClass(name) 参数： name 要删除的类名，不传参时，会将当前 selector 元素的所有类型全部删除。 3.切换类名 语法：$(selector).toggleClass(name) 参数： name 要切换的类名 作用： 当 selector 元素有 name 类名时，toggleClass() 会删除 name 类名，反之会添加 name 类名。 4.判断类 语法：$(selector).hasClass(name) 参数： name 要判断的类名 返回值： boolean 类型，有 name 类名则放回 true，反之返回 false。 text和html方法1.text() 作用： 设置或返回所选元素的文本内容。 注：在获取元素的内容时，只会获取元素的纯文本，不包含标签元素。在设置元素内容时，如果含有标签元素，会把标签元素当纯文本输出。即 text(...) 在遇到标签时，会转义。 例： 1$("#test1").text("&lt;h1&gt;Hello world!&lt;/h1&gt;"); 页面展示内容为： 1&lt;h1&gt;Hello world!&lt;/h1&gt; 2.html() 作用：设置或返回所选元素的内容（包括 HTML 标记）。 注：在获取元素的内容时，标签和纯文本都会获取到。设置内容时，含有标签元素时，该标签元素会在文档中生效。 例：： 123$("#test2").html("&lt;b&gt;Hello world!&lt;/b&gt;");//会将&lt;b&gt;标签渲染出来 设置或获取属性attr()attr() 方法用于设置/改变/获取属性值。使用方法和 css() 方法的格式一模一样。 jq 底层是通过 getAttribute 和 setAttribute 实现的。可以设置自定义属性（特有属性）。 1.设置一个属性： 语法：$(selector).attr(name,value) 参数：name 参数名 value 值 例: 1$("#w3s").attr("href","http://www.w3school.com.cn/jquery"); 2.设置多个属性： 语法：$(selector).attr(obj) 参数：obj 包含多个属性和值的对象 例： 1234$("img").attr(&#123; src : "1.jpg", alt : "图破了"&#125;); 3.获取属性值 语法：$(selecor).attr(name) 参数： name （string类型 ） 属性名。 返回值： name的属性值。 删除属性removeAttr()删除指定元素上的属性。 语法：$(selector).removeAttr( name ) 参数： name 属性名。 设置或获取属性prop()获取或设置 dom 属性，jq 底层是通过获取或设置 dom 属性的值来实现的。 如：checked = false/true，不可以设置自定义属性（特有属性）。 语法：$(selector).prop(name,value) 参数： name 属性名value 属性值 例：利用 jq 控制复选框的选中状态时，使用 prop() 方法。 1$("#check").prop("checked",false); // 设置不选中 获取或设置表单值val()可以获取和设置表单元素的 value 值。 语法：$(selector).val() 1.获取value值： 1var val = $("input").val(); 2.设置value值： 1$("input").val("提交"); jQuery DOM操作append() 添加最后一个子元素给指定元素添加最后一个子元素，当操作的元素是页面中已经存在的 dom 元素时，会有剪切效果，即被操作元素节点会从原来的位置消失。 语法：append( jqobj | htmlstr ) 参数： 可以是 jq 对象或者 html 字符串。 例： 方法1： 123var span = $("&lt;span&gt;我是新添加的span&lt;/span&gt;");$("li").append(span); 方法2： 1$("li").append("&lt;span&gt;我是新添加的span&lt;/span&gt;"); 注： $( A ).append( B ) 与 $( B ).appendTo( A ) 操作等价。 prepend() 添加最前一个子元素给指定元素添加最前一个子元素（即添加第一个子元素），当操作的元素是页面中已经存在的 dom 元素时，会有剪切效果，即被操作元素节点会从原来的位置消失。 语法：prepend( jqobj | htmlstr) 参数： 可以是 jq 对象或者 html 字符串。 注： $( A ).prepend( B ) 与 $( B ).prependTo( A ) 操作等价。 before() 添加前一个兄弟元素给指定元素添加前一个兄弟元素，当操作的元素是页面中已经存在的 dom 元素时，会有剪切效果，即被操作元素节点会从原来的位置消失。 语法：brefore( jqobj | htmlstr) 参数： 可以是jq对象或者html字符串。 after() 添加后一个兄弟元素给指定元素添加后一个兄弟元素，当操作的元素是页面中已经存在的 dom 元素时，会有剪切效果，即被操作元素节点会从原来的位置消失。 语法：after( jqobj | htmlstr) 参数： 可以是jq对象或者html字符串。 empty() 清空元素的内容清空操作元素的所有后代节点（不包括该操作元素本身）。empty() 方法会防止内存泄露。 其在清空后代节点时，会把后代节点上绑定的事件同时清除掉，这不同于 html() 方法。 语法：$(selector).empty() 例： 12345678&lt;div&gt; &lt;ul&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789$("div").empty();/*完成清空操作后的dom结构为：&lt;div&gt;&lt;/div&gt; // div 元素节点本身不会被删除*/ remove() 删除元素删除操作节点本身及其所有后代节点。 语法：$(selector).remove() 例： 12345678910&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 123456789$("div").remove();/*完成删除操作后的dom结构为：&lt;body&gt;&lt;/body&gt; // div 元素节点本身也会被删除*/ clone()克隆元素clone() 方法默认不传参数就是深度复制，而原生 js 的 cloneNode(true) 需要传参数 true 才是深度复制。 语法：$(selector).clone(bool) 参数： boollean 类型，false(默认)深度复制，不复制元素上的方法，true 深度复制，并且复制元素上的方法。 例： 123var p = ("p").clone(); // 先克隆$("#box").append(p); //后添加到id 为box 的元素中 jQuery尺寸操作获取/设置内容的宽度width()width()方法会返回元素内容（content）的宽度，返回的是一个数值类型。可以设置宽度值。 语法：$(selector).width(val) 参数： val 要设置的值 返回值： number类型，content 的宽度值。 innerWidth()获取元素的 padding + content 的宽度，返回的是一个数字类型。不能设置。 语法：$(“selector”).innerWidth() 返回值： number类型，padding + content 的宽度值 获取/设置内容的高度height()height() 方法会返回元素内容（content）的高度，返回的是一个数值类型。可以设置高度值。 语法：$(“selector”).height(val) 参数： val 要设置的高度值 返回值： number类型，content 的高度值。 innerHeight()获取元素的 padding + content 的高度，返回的是一个数字类型。不能设置。 语法：$(“selector”).innerHeight() 返回值： number类型，padding + content 的高度值。 outerWidth()/outerHeight()可以获取 border + padding + content 或者 margin + border + padding + content 的宽度或高度值。不能设置。 语法：$(“selector”).outerWidth(bool) 参数： bool（boolean类型）false（默认）表示获取 border + padding + content 的宽度值，true 表示获取 margin + border + padding + content 的宽度值。 返回值： number 类型值 注：outerHeight() 与 outerWidth() 用法相同。 jQuery 位置操作offset()获取或设置元素相对于 document 的 top 和 left 整型值。这不同于原生 js 中的 offsetTop 和 offsetLeft。 注：如果被操作元素没有设置定位属性，jq 会补上 relative，所以即使没有给元素设置定位属性，该元素同样可以进行偏移。 1.获取 语法：$(“selector”).offset() 返回值： object 对象类型，{top, left}。包含 top 和 left 值。 2.设置 语法：$(selector).offset(obj) 参数： obj（对象类型），{top:value, left:value} position()获取相对于有定位父元素的 top 和 left 值。只能获取不能进行设置操作。 注：不计算 margin 的值。 语法：$(el).position() 返回值： 带有 top 和 left 属性的对象 {top, left} scrollTop()获取或设置页面垂直方向卷去的距离。 1.获取 语法：$(selector).scrollTop() 返回值： 页面垂直方向卷去距离的整型值。 2.设置 语法：$(seletor).scrollTop(val) 参数： val （string/number类型），卷去的距离量 scrollLeft()获取或设置页面水平方向卷去的距离。 1.获取 语法：$(selector).scrollLeft() 返回值： 页面水平方向卷去距离的整型值。 2.设置 语法：$(seletor).scrollLeft(val) 参数： val（string/number类型），卷去的距离量 数据缓存data() 在某元素上存储数据data() 函数可以在 dom 元素上存储任意类型的数据。 语法：$(selector).data(‘dataname’ , value ) 参数： dataname : string 类型，向元素上添加的数据名​value : boolean|number|string|object|array 类型，数据的值 data() 获取在元素上存储的数据语法：$(selector).data(“dataname”) 参数： dataname 数据名 返回值： 通过 data() 方法存储的数据值 data() 获取自定义属性值通过 data-name 标准格式自定义的属性，也可以是使用 data() 方法来获取其属性值。 注：HTML5 后，在设置自定属性时，在属性名前加上 data- 前缀。该dom元素上的所有自定属性以键值对的形式存入dataset对象中。 语法：$(selector).data(“name”) 参数： name data- 后面的属性名，注意在获取属性值时不要加 data- 返回值： 自定义属性的值 removeData() 从某元素删除数据removeData() 函数可以从 dom 元素上删除由 data() 函数存储的数据。 语法：$(selector).removeData(‘dataname’) 参数： dataname : 数据名]]></content>
      <categories>
        <category>jquery相关</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap-paginator分页插件的使用]]></title>
    <url>%2F2016%2F05%2F22%2Fbootstrap%2Fbootstrap-paginator%2F</url>
    <content type="text"><![CDATA[​Bootstrap Paginator是一款基于Bootstrap的js分页插件，功能很丰富，个人觉得这款插件已经无可挑剔了。它提供了一系列的参数用来支持用户的定制，提供了公共的方法可随时获得插件状态的改变，以及事件来监听用户的动作。目前经过测试的浏览器包括： Firefox 5+, Chrome 14+, Safari 5+, Opera 11.6+ and IE 7+。 GitHub 官网地址：https://github.com/lyonlai/bootstrap-paginator html结构1&lt;ul id="pagintor"&gt;&lt;/ul&gt; &lt;!--版本3.x使用ul元素--&gt; 调用方式123456789$("#pagintor").bootstrapPaginator(&#123; bootstrapMajorVersion:3,//默认是2，如果是bootstrap3版本，这个参数必填 currentPage:1,//当前页 totalPages:10,//总页数 size:"small",//设置控件的大小，mini, small, normal,large onPageClicked:function(event, originalEvent, type,page)&#123; //为按钮绑定点击事件 page:当前点击的按钮值 &#125;&#125;); 参数介绍 数据类型 参数名 描述 默认值 number bootstrapMajorVersion 搭配使用的Bootstrap版本，2.X 的 分页必须使用div元素，3.X分页的必须使用ul元素。请注意与所使用的bootstrap版本对应上。 2 string size 设置控件的显示大小，是个字符串. 允许的值: mini, small, normal,large。值：mini版的、小号的、正常的、大号的。 “normal” function itemContainerClass 该参数接收一个函数，返回一个字符串，该字符串是一个我们自定义的class类样式。当控件内的每个操纵按钮被渲染(render)时，都会调用该函数，同时把有关该按钮的信息作为参数传入。参数：type,page, current 。type为该控件的操作按钮的类型，如上图所示的五种类型：first、prev、page、next、last。page为该按钮所属第几页。current 指示整个控件的当前页是第几页。 number currentPage 设置当前页. 1 number numberOfPages 设置控件显示的页码数.即：类型为”page”的操作按钮的数量。 5 number totalPages 设置总页数. 1 function pageUrl 实际上，控件内的每个操作按钮最终会被渲染成超链接，该参数的作用就是设置超链接的链接地址。该参数是个函数，参数为：type,page, current。这样我们就可以通过这个函数为每个操作按钮动态设置链接地址。如：”http://example.com/list/page/&quot;+page boolean/function shouldShowPage 该参数用于设置某个操作按钮是否显示，可是个布尔值也可是个函数。当为true时，显示。当为false时，不显示。如果该参数是个函数，需要返回个布尔值，通过这个返回值判断是否显示。函数有3个参数: type, page, current。使用函数的好处是，可以对每个操作按钮进行显示控制。 true function itemTexts 控制每个操作按钮的显示文字。是个函数，有3个参数: type, page, current。通过这个参数我们就可以将操作按钮上的英文改为中文，如first–&gt;首页，last–&gt;尾页。 function tooltipTitles 设置操作按钮的title属性。是个函数，有3个参数: type, page, current。 boolean useBootstrapTooltip 设置是否使用Bootstrap内置的tooltip。 true是使用，false是不使用,默认是不使用。注意：如果使用，则需要引入bootstrap-tooltip.js插件。 false object bootstrapTooltipOptions Default: { animation: true, html: true, placement: ‘top’, selector: false, title: “”, container: false }该参数是个js对象。当参数useBootstrapTooltip为true时，会将该对象传给Bootstrap的bootstrap-tooltip.js插件。 function onPageClicked 为操作按钮绑定click事件。回调函数的参数：event, originalEvent, type,page。 function onPageChanged 为操作按钮绑定页码改变事件，回调函数的参数：event, oldPage, newPage。 公共命令另外该插件还提供了几个公共的命令，可以通过如下方法调用，如： 12$('#example').bootstrapPaginator("show",3); //调用show命令$('#example').bootstrapPaginator("getPages"); //调用getPages命令 命令名 参数 返回值 描述 show page show命令用于直接跳转到特定的page，与直接点击操作按钮的效果是一样的。使用方法，如：$(&#39;#example&#39;).bootstrapPaginator(&quot;show&quot;,3) 直接跳转到第3页 showFirst showFirst 命令用于直接跳转到首页，与点击first按钮相同。使用方法：$(&#39;#example&#39;).bootstrapPaginator(&quot;showFirst&quot;) showPrevious showPrevious 命令用于直接跳转到上一页。使用方法：$(&#39;#example&#39;).bootstrapPaginator(&quot;showPrevious&quot;) showNext showNext命令用于直接跳转到下一页。 showLast showLast 命令用于直接跳转到上一页。 getPages object getPages命令用于返回当前控件中显示的页码，以数组形式返回。使用方法：var arra = $(&#39;#example&#39;).bootstrapPaginator(&quot;getPages&quot;) setOptions object setOptions命令用于重新设置参数，使用方法：$(&#39;#example&#39;).bootstrapPaginator(&quot;setOptions&quot;,newoptions) 事件Events​ Bootstrap Paginator 提供了俩个事件：page-clicked和page-changed。这俩个事件作为参数使用，分别对应onPageClicked和onPageChanged。 事件名 回调函数 描述 page-clicked function(event, originalEvent, type, page) 同上文。另外，参数event, originalEvent是俩个jquery事件对象，可参考jquery相关文档 page-changed function(event, oldPage, newPage) 同上文 注意：分页样式用BootStrap 的，如果单独使用，请去BootStrap中把分页样式拷出来。jQuery版本需要1.8及以上。]]></content>
      <categories>
        <category>bootstrap相关</category>
      </categories>
      <tags>
        <tag>bootstrap-paginator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap-validator表单校验插件的使用]]></title>
    <url>%2F2016%2F05%2F21%2Fbootstrap%2Fbootstrap-validator%2F</url>
    <content type="text"><![CDATA[基于bootstrap的表单校验插件使用说明。 参考文档 http://blog.csdn.net/nazhidao/article/details/51542508 http://blog.csdn.net/u013938465/article/details/53507109 http://www.cnblogs.com/v-weiwang/p/4834672.html?ptvd http://bootstrapvalidator.votintsev.ru/api/ 引包引入bootstrap-validator的css文件注意bootstrap-validator是bootstrap插件，因此依赖与bootstrap。 12&lt;link rel="stylesheet" href="lib/bootstrap/css/bootstrap.css"&gt;&lt;link rel="stylesheet" href="lib/bootstrap-validator/css/bootstrapValidator.css"&gt; 引入js文件123&lt;script src="lib/jquery/jquery.js"&gt;&lt;/script&gt;&lt;script src="lib/bootstrap/js/bootstrap.js"&gt;&lt;/script&gt;&lt;script src="lib/bootstrap-validator/js/bootstrapValidator.js"&gt;&lt;/script&gt; html结构1234567&lt;form id="demo_form"&gt; ... &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;!--当需要自动触发验证时，type必须为submit--&gt;&lt;/form&gt;&lt;!--也可以是表单元素外的提交按钮,加上关联属性form即可--&gt;&lt;button type="submit" form="demo_form"&gt;提交&lt;/button&gt; 初始化表单校验插件 bootstrap-validator插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//使用表单校验插件$(formSelector).bootstrapValidator(&#123; //1. 指定不校验的类型，默认为[':disabled', ':hidden', ':not(:visible)'],可以不设置 // excluded: [':disabled', ':hidden', ':not(:visible)'], //2. 指定校验时的图标显示，默认是bootstrap风格 feedbackIcons: &#123; valid: 'glyphicon glyphicon-ok', invalid: 'glyphicon glyphicon-remove', validating: 'glyphicon glyphicon-refresh' &#125;, //3. 指定校验字段 fields: &#123; //校验用户名，对应name表单的name属性 username: &#123; validators: &#123; //不能为空 notEmpty: &#123; message: '用户名不能为空' &#125;, //长度校验 stringLength: &#123; min: 6, max: 30, message: '用户名长度必须在6到30之间' &#125;, //正则校验 regexp: &#123; regexp: /^[a-zA-Z0-9_\.]+$/, message: '用户名由数字字母下划线和.组成' &#125; &#125; &#125;, email : &#123; validators : &#123; notEmpty: &#123; message: '用户名不能为空' &#125;, emailAddress: &#123; message: '邮箱地址格式有误' &#125; &#125; &#125; &#125;&#125;); 注册表单验证成功事件当表单校验成功时，会触发success.form.bv事件，此时会提交表单，这时候，通常我们需要禁止表单的自动提交，使用ajax进行表单的提交。 1234567891011121314151617181920//1.当提交按钮是: [type="submit"] 表单元素时，会在提交之前自动去进行表单验证$("#form").on('success.form.bv', function (e) &#123; e.preventDefault(); //使用ajax提交逻辑&#125;);//2.当提交按钮是 普通按钮时$("buttonName").on("click", function()&#123; //获取表单对象 var bootstrapValidator = $("form").data('bootstrapValidator'); bootstrapValidator.validate(); //手动触发验证 if(bootstrapValidator.isValid())&#123; //验证通过时执行相关操作 //表单提交的方法、比如ajax提交 &#125;&#125;); 常用方法获取validator实例(对象)当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的validator实例，通过validator实例调用一些方法来完成某些功能。 1234var validator = $("#form").data('bootstrapValidator'); //获取表单校验实例//使用表单校验实例可以调用一些常用的方法。validator.methodName(params); 1.手动触发表单验证 1234//触发全部验证$(formName).data("bootstrapValidator").validate();//触发指定字段的验证$(formName).data("bootstrapValidator").validateField('fieldName'); 2.获取当前表单验证状态 12// flag = true/false , 返回true表示验证通过var flag = $(formName).data(“bootstrapValidator”).isValid(); 重置表单重置表单中设置过校验的内容，将隐藏所有错误提示和图标。 12//方法1:validator.resetForm();//重置表单，并且会隐藏所有的错误提示和图标 123456789//方法2://注册模态框关闭事件,模态框关闭后清除所有验证样式,隐藏所有的错误提示和图标 $('#mymodal').on('hidden.bs.modal', function (e) &#123; e.preventDefault(); //清除验证样式 $("#user_form").data("bootstrapValidator").destroy(); $("#user_form").data("bootstrapValidator" , null); formValidator(); //封装的验证函数 &#125;); 更新字段的状态BootstrapValidator在用户输入内容的时候，会做校验，当调用bootstrap的插件的方法可以手动会改变字段值的状态。可以使用updateStatus(field, status, validatorName)方法更新字段的状态 12345678910//参数说明：// field 字段名// status 校验状态// validatorName 验证器名字（例如：notEmpty）//status的值有：// "NOT_VALIDATED" //未校验的// "VALIDATING" //校验中的// "INVALID" //校验失败的// "VALID" //校验成功的。]]></content>
      <categories>
        <category>bootstrap相关</category>
      </categories>
      <tags>
        <tag>bootstrap-validator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-fileupload.js文件上传插件的使用]]></title>
    <url>%2F2016%2F05%2F20%2Fjquery%2Fplugins%2Fjquery-fileuploadjs%2F</url>
    <content type="text"><![CDATA[基于 jquery 的文件上传插件。 仓库及文档github地址：https://github.com/blueimp/jQuery-File-Upload 中文文档：http://www.jq22.com/jquery-info230 使用方式引包1234567891011&lt;!-- jquery-fileupload依赖于jquery --&gt;&lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- jquery ui小部件，上传插件依赖了jquery ui的小部件 --&gt;&lt;script src="js/vendor/jquery.ui.widget.js"&gt;&lt;/script&gt;&lt;!-- 如果上传图片需要跨域，那么需要引入这个js文件，如果不跨域，则不需要引入 --&gt;&lt;script src="js/jquery.iframe-transport.js"&gt;&lt;/script&gt;&lt;!-- jquery上传插件 --&gt;&lt;script src="js/jquery.fileupload.js"&gt;&lt;/script&gt; 注：如果文件上传是跨域的，那么需要引入 jquery.iframe-transport.js 库。请按顺序引入。 html结构name属性指定文件上传时该文件的键名，data-url 指定图片上传时的接口地址。data-url 属性可不指定在 file 域中，使用 fileupload({}) 方法的配置参数 url 也是可以的，且推荐使用本方式。 单文件上传 1&lt;input id="fileupload" type="file" name="fileFiled" data-url="server/php/"&gt; 多文件上传 12&lt;!-- 加 multiple 属性，指定多文件上传 --&gt;&lt;input id="fileupload" type="file" name="files[]" data-url="server/php/" multiple&gt; 注： 当没有为 &lt;input type=&quot;file&quot; name=&quot;&quot; /&gt; 文件域指定 name 属性时，在上传时，该插件会将 name 属性值默认设置为 “files[]” 所以，当后端无法获取到上传的文件时，请检查 name 属性是否设置正确。 fileupload 函数使用方式也很简单，jquery-fileupload.js 在 jQuery.fn 上挂载了名为 fileupload 的方法，所以你可以通过如下方式调用她。 12345$("file-selector").fileupload( options );// file-selector 文件域选择器// options 文件上传配置对象 选择文件后自动上传默认的，选择文件后会自动上传。 1234567891011$("#fileupload").fileupload(&#123; url: '文件上传请求地址', dataType: 'json', done: function (e , data)&#123; // 文件上传成功后触发回调 // &#125;&#125;) 手动上传向 fileupload 方法中传递 add 函数，可以做到手动触发上传。 12345678910111213141516171819202122232425262728//文件上传初始化$("#fileupload").fileupload(&#123; url : "上传文件的请求地址" //同样也可以在input元素里使用data-url属性来指定请求地址 dataType:"json", //预期服务器返回的数据类型 done:function (e, data) &#123; //图片上传成功后的回调函数，处理上传成功后的动作 console.log(data); //done回调函数参数注释： //data : 图片上传后的对象，通过data.result.picAddr可以获取上传后的图片地址 //e : 事件对象 &#125;, add : function(e,data)&#123; //文件上传前触发回调 // 逻辑处理 ... //给某个按钮绑定点击事件，点击后开始上传 $(".somebtn").on("click" , function(e)&#123; data.submit(); &#125;); //data.submit(); //条件满足后手动触发上传 &#125; &#125;); 注意：如果添加加了 add() 回调函数，必须要调用 data.submit() 方法才会触发文件上传，否则不会执行上传动作。 附加参数的添加如果需要一次传递除文件外的其他参数，可以在文件上传前添加。这里有两种方式，第一种是在 fileupload 的自定义事件 fileuploadsubmit 中添加。第二种则是在 add() 函数中处理添加。 文件上传前事件 fileuploadsubmit 1234567891011$('#fileupload').bind('fileuploadsubmit', function (e, data) &#123; data.formData = &#123; // 如果需要额外添加参数可以在这里添加 // UserID 只是演示，传递什么参，怎么获取，由你自己决定 UserID: '666' &#125;; &#125;); 在 add() 函数中添加 12345678910111213141516171819$("#fileupload").fileupload(&#123; // ... // 忽略其他配置 add: function (e, data)&#123; data.formData = &#123; // 在这里添加附件参数 customKey: "customKey's value", // other params ... &#125; // 不要忘记调用 data.submit() 方法。 data.submit() &#125;&#125;) 注：更多配置参数及用法，请查看该插件文档。]]></content>
      <categories>
        <category>jquery插件相关</category>
      </categories>
      <tags>
        <tag>jquery插件</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2016%2F04%2F14%2Fjavascript%2Finstance%2FrepetitionHandle%2F</url>
    <content type="text"><![CDATA[数组去重的常用方法 es5 Array.prototype.reduce 法 reduce() 方法对累计器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。 123456789var arr = [1,3,2,8,6,7,9,9,3,1,1,6,6,2 , "a" , "a"]var res = arr.sort().reduce( ( init , curr )=&gt; &#123; if ( init.length === 0 || (init[init.length-1]) !== curr ) init.push(curr); return init;&#125; , [])console.log( res ); // [1, 2, 3, 6, 7, 8, 9, "a"] es6 Set数据结构法 ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 123var result = [...new Set(arr)];console.log( result ); // [1, 2, 3, 6, 7, 8, 9, "a"]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2016%2F01%2F01%2Fjavascript%2Fregexp%2Fregexp%2F</url>
    <content type="text"><![CDATA[概述正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。 1var regex = /xyz/; 另一种是使用RegExp构造函数。 1var regex = new RegExp('xyz'); 上面两种写法是等价的，都新建了一个内容为xyz的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。 RegExp构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。1234var regex = new RegExp('xyz', 'i');// 等价于var regex = /xyz/i; 上面代码中，正则表达式/xyz/有一个修饰符i。 修饰符g修饰符默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。 i修饰符默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。 元字符 元字符 描述 \d 查找数字 [0-9] \D 非数字字符 [^0-9] \w 单词字符 [a-zA-Z0-9_] \W 非单词字符 [^a-zA-Z0-9_] \s 不可见字符，包含空格 [\f\r\n\t\v] \S 非不可见字符 [\f\r\n\t\v] \t 查找制表符 . 除了换行和回车之外的任一字符 [^\n\r] 运算符 运算符 描述 () 提升优先级，优先级最高 ，一个 () 表示一个组匹配 [] 表示一个字符的位置，[] 中定义需要匹配的字符 ^ [] 中表示非 ， // 中表示匹配开始位置 {} 定义量词，表示某字符出现的次数 | 表示或者，优先级最低。 注：1. 在 [] 中，特殊字符不需要使用 \ 进行转义处理，但是如果需要使用 [] 匹配 \ 自身的话，那么就需要转义。2. 对于字符 - 来说，如果是放在数字或字母之间，则表示匹配这一段范围的字符，否则就是匹配 - 自身。 123456789101112131415// 匹配 \(/[\\]/.test('\\'))// true// 匹配其他特殊字符(/[+]/.test('+'))// true// 匹配 -(/[-]/.test('-'))// true// 匹配 0-9 a-z(/[0-9a-z]/.test('5'))// true 量词 格式 描述 x{n,m} 表示 x 出现 n 至 m 次 ， x&gt;=n &amp;&amp; x&lt;=m x{n,} x 出现 n 个以上 ，x&gt;=n x{n} x 出现 n 个 ，x==n x+ x 出现 1个 或 1个 以上，x&gt;=1 x* x 出现 0个 或 0个 以上，x&gt;=0 x? x 出现 0个 或 1个，x==0 或 x==1 ^x 以x开始 x$ 以x结尾 转义符如果需要匹配特殊字符（比如：RegExp 中使用到的特殊字符）。那么，我们需要对这些字符使用 \ 进行转义。 需要转义的特殊字符有： \ / + - * . { } ^ $ ( ) [ ] 例如，匹配 / 字符时，我们需要转义。 12(/\//.test('/'))// true 注意： 如果是以 new RegExp() 构造函数的方式定义正则表达式，由于其中的参数是字符串类型，所以在转义的时候需要使用两个 \\ 进行转义。 12(new RegExp('\\/').test('/'))// true 特殊的： 在对 \ 进行匹配时，需要进行特殊处理，原因是 \ 本身就是转义符。以下分别是以字面量方式和构造函数定义正则时的写法。 1234567//1. 字面量(/\\/.test('\\'))// true//2. 构造函数(new RegExp('\\\\').test('\\'))// true 注：传入的 \\ 测试字符加入了 2 个，是因为 javascript 引擎会认为需要将右边的引号 &#39; 转义，所以加一个 \。 RegExp实例方法RegExp.prototype.test()检索字符串是否满足正则表达式的要求。参数：string类型，需要检测的字符串 返回值：boolean 类型 ，true 表示匹配满足正则表达式要求，false 表示不满足要求 RegExp.prototype.exec()正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。 123456var s = '_x_x';var r1 = /x/;var r2 = /y/;r1.exec(s) // ["x"]r2.exec(s) // null 上面代码中，正则对象r1匹配成功，返回一个数组，成员是匹配结果；正则对象r2匹配失败，返回null。 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。 1234var s = '_x_x';var r = /_(x)/;r.exec(s) // ["_x", "x"] 上面代码的exec方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。 exec方法的返回数组还包含以下两个属性： input：整个原字符串。 index：整个模式匹配成功的开始位置（从0开始计数）。 1234567var r = /a(b+)a/;var arr = r.exec('_abbba_aba_');arr // ["abbba", "bbb"]arr.index // 1arr.input // "_abbba_aba_" 上面代码中的index属性等于1，是因为从原字符串的第二个位置开始匹配成功。 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。 123456789101112131415161718192021var reg = /a/g;var str = 'abc_abc_abc'var r1 = reg.exec(str);r1 // ["a"]r1.index // 0reg.lastIndex // 1var r2 = reg.exec(str);r2 // ["a"]r2.index // 4reg.lastIndex // 5var r3 = reg.exec(str);r3 // ["a"]r3.index // 8reg.lastIndex // 9var r4 = reg.exec(str);r4 // nullreg.lastIndex // 0 上面代码连续用了四次exec方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回null，正则实例对象的lastIndex属性也重置为0，意味着第四次匹配将从头开始。 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。 1234567891011var reg = /a/g;var str = 'abc_abc_abc'while(true) &#123; var match = reg.exec(str); if (!match) break; console.log('#' + match.index + ':' + match[0]);&#125;// #0:a// #4:a// #8:a 上面代码中，只要exec方法不返回null，就会一直循环下去，每次输出匹配的位置和匹配的文本。 正则实例对象的lastIndex属性不仅可读，还可写。设置了g修饰符的时候，只要手动设置了lastIndex的值，就会从指定位置开始匹配。 常见验证邮箱 前面是字母或者数字必须有@@后面是字母或者数字必须有..后面是字母或者数字 1var r = /^\w+@\w+(\.\w+)+$/; 手机号 11位数字组成号段13[0-9] 147 15[0-9] 177[0178] 18[0-9] 12var r = /^(13[0-9]|147|15[0-9]|17[0178]|18[0-9])\d&#123;8&#125;$/; 中文名 只能是汉字长度2-6位之间汉字范围[\u4e00-\u9fa5] 1var r = /^[\u4e00-\u9fa5]&#123;2,6&#125;$/; 小数位数 只能是数字小数位数不得超过 2 位 1var r = /^\d+(.\d&#123;1,2&#125;)?$/ 金额验证 十进制位及以上不能为 0最多保留2位小数必需为数值可以为空 1var r = new RegExp("^(((^[1-9]\\d*)|(^[0-9]))+(\\.\\d&#123;1,2&#125;)?)?$")]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
</search>
